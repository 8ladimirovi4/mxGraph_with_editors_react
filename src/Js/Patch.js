//Editor.js

import $ from "jquery";
import * as mxgraph from 'mxgraph';
import { Base64 } from 'js-base64';
import { API } from './scada' 
import pako from 'pako';
import * as webix from 'webix/webix.js';
import 'webix/webix.css';
import moment from 'moment';
import html_sanitize from 'html_sanitize'
import Chart from "chart.js"
import jscolor from 'jscolor'
import { template } from './template'
import { Howl } from 'howler';
import mxValueChange from "./mxMethods";


import { 
    mxUndoManager,
    mxPrintPreview,
    mxCellMarker,
    mxSvgCanvas2D, 
    mxVmlCanvas2D,
    mxEdgeStyle,
    mxVertexHandler,
    mxGuide,
    mxRubberband,
    mxCellHighlight,
    mxLayoutManager,
    mxCompactTreeLayout,
    mxHierarchicalLayout,
    mxCircleLayout,
    mxFastOrganicLayout,
    mxConnector,
    mxStencil,
    mxShape,
    mxEllipse,
    mxCellState,
    mxStyleRegistry,
    mxObjectIdentity,
    mxConnectionConstraint,
    mxDictionary,
    mxCellEditor,
    mxPanningHandler,
    mxElbowEdgeHandler,
    mxImageShape,
    mxDragSource,
    mxGraphView, 
    mxStackLayout,
    mxCodec,
    mxClipboard,
    mxMorphing,
    mxKeyHandler,
    mxResources, 
    mxEdgeHandler,
    mxMouseEvent,
    mxConstraintHandler,
    mxObjectCodec,
    mxGenericChangeCodec,
    mxClient, 
    mxPoint,
    mxEventObject,
    mxImageExport,
    mxOutline,
    mxWindow,
    mxXmlCanvas2D,
    mxXmlRequest,
    mxForm,
    mxGraphModel, 
    mxCellTracker,
    mxCodecRegistry,
    mxGraph, 
    mxUtils, 
    mxConstants,
    mxImage,
    mxCellRenderer,
    mxPopupMenu,
    mxEventSource,
    mxCellOverlay,
    mxRectangle,  
    mxEvent,
    mxCell,
    mxGeometry,
    mxPolyline,
    mxGraphHandler,
    mxConnectionHandler,
    mxRectangleShape,
    mxPopupMenuHandler,
    mxCylinder,
    mxActor,
    mxRhombus,
    mxPerimeter,
    mxArrowConnector,
    mxSwimlane,
    mxLabel,
    mxMarker,
    mxHandle,
    mxTriangle,
    mxHexagon,
    mxCloud,
    mxLine,
    mxDoubleEllipse,
    mxArrow,
} from './mxClient'

import { HELP, 
    GUID, 
    isDefined, 
    AJAX, 
    isNullOrEmpty, 
    getExtension, 
    parseNumber } from './client'

const {
    $$
    } = webix

/**
 * Editor constructor executed on page load.
 */
  //export default function Editor (viewMode, themes, model, graph)

  function Editor (viewMode, themes, model, graph)
{
    mxEventSource.call(this);
    this.viewMode = (viewMode != null) ? viewMode : this.viewMode;

    // Disable touchscreen bindings in mxGraph
    Graph.touchStyle = false;

    this.graph = graph || this.createGraph(themes, model);

    // override html rendering in cell
    this.graph.cellRenderer.getLabelValue = function(state)
    {
        var result = mxCellRenderer.prototype.getLabelValue.apply(this, arguments);
        if (state.view.graph.isHtmlLabel(state.cell) && typeof result != "object")
        {
            if (state.style['html'] != 1)
            {
                result = mxUtils.htmlEntities(result, false);
            }
            else
            {
                // do not sanitize table html code
                if (!state?.cell.isTable)
                    result = state.view.graph.sanitizeHtml(result);
            }
        }
   
        return result;
    };

    this.undoManager = this.createUndoManager();

    this.getFilename = function ()
    {
        return this.filename;
    };
    this.getOrCreateFilename = function()
    {
        return this.filename || mxResources.get('drawing') + '.xml';
    };
    
    if (!this.isViewMode())
    {
        // Updates modified state if graph changes
        this.graphChangeListener = function (sender, eventObject) 
        {
            var edit = (eventObject != null) ? eventObject.getProperty('edit') : null;
            if (edit == null || !edit.ignoreEdit)
                this.setModified(true);
        };
        this.graph.getModel().addListener(mxEvent.CHANGE, mxUtils.bind(this, function ()
        {
            this.graphChangeListener.apply(this, arguments);
        }));
    }

    // Sets persistent graph state defaults
    this.graph.resetViewOnRootChange = false;
    this.init();
};


/**
 * Images below are for embedding toolbars.
 */
Editor.helpImage            = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSJub25lIiBkPSJNMCAwaDI0djI0SDB6Ii8+PHBhdGggZD0iTTExIDE4aDJ2LTJoLTJ2MnptMS0xNkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6bTAtMTRjLTIuMjEgMC00IDEuNzktNCA0aDJjMC0xLjEuOS0yIDItMnMyIC45IDIgMmMwIDItMyAxLjc1LTMgNWgyYzAtMi4yNSAzLTIuNSAzLTUgMC0yLjIxLTEuNzktNC00LTR6Ii8+PC9zdmc+';
Editor.checkmarkImage       = 'data:image/gif;base64,R0lGODlhFQAVAMQfAGxsbHx8fIqKioaGhvb29nJycvr6+sDAwJqamltbW5OTk+np6YGBgeTk5Ly8vJiYmP39/fLy8qWlpa6ursjIyOLi4vj4+N/f3+3t7fT09LCwsHZ2dubm5r6+vmZmZv///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OEY4NTZERTQ5QUFBMTFFMUE5MTVDOTM5MUZGMTE3M0QiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OEY4NTZERTU5QUFBMTFFMUE5MTVDOTM5MUZGMTE3M0QiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Rjg1NkRFMjlBQUExMUUxQTkxNUM5MzkxRkYxMTczRCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Rjg1NkRFMzlBQUExMUUxQTkxNUM5MzkxRkYxMTczRCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAEAAB8ALAAAAAAVABUAAAVI4CeOZGmeaKqubKtylktSgCOLRyLd3+QJEJnh4VHcMoOfYQXQLBcBD4PA6ngGlIInEHEhPOANRkaIFhq8SuHCE1Hb8Lh8LgsBADs=';
Editor.maximizeImage        = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVBAMAAABbObilAAAAElBMVEUAAAAAAAAAAAAAAAAAAAAAAADgKxmiAAAABXRSTlMA758vX1Pw3BoAAABJSURBVAjXY8AJQkODGBhUQ0MhbAUGBiYY24CBgRnGFmZgMISwgwwDGRhEhVVBbAVmEQYGRwMmBjIAQi/CTIRd6G5AuA3dzYQBAHj0EFdHkvV4AAAAAElFTkSuQmCC';
Editor.zoomOutImage         = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVBAMAAABbObilAAAAElBMVEUAAAAAAAAsLCxxcXEhISFgYGChjTUxAAAAAXRSTlMAQObYZgAAAEdJREFUCNdjIAMwCQrB2YKCggJQJqMwA7MglK1owMBgqABVApITgLJZXFxgbIQ4Qj3CHIT5ggoIe5kgNkM1KSDYKBKqxPkDAPo5BAZBE54hAAAAAElFTkSuQmCC';
Editor.zoomInImage          = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVBAMAAABbObilAAAAElBMVEUAAAAAAAAsLCwhISFxcXFgYGBavKaoAAAAAXRSTlMAQObYZgAAAElJREFUCNdjIAMwCQrB2YKCggJQJqMIA4sglK3owMzgqABVwsDMwCgAZTMbG8PYCHGEeoQ5CPMFFRD2MkFshmpSQLBRJFSJ8wcAEqcEM2uhl2MAAAAASUVORK5CYII=';
Editor.zoomFitImage         = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVBAMAAABbObilAAAAD1BMVEUAAAAAAAAwMDBwcHBgYGC1xl09AAAAAXRSTlMAQObYZgAAAEFJREFUCNdjIAMwCQrB2YKCggJQJqMwA7MglK1owMBgqABVApITwMdGqEeYgzBfUAFhLxPEZqgmBQQbRUKFOH8AAK5OA3lA+FFOAAAAAElFTkSuQmCC';
Editor.layersImage          = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAMAAACeyVWkAAAAaVBMVEUAAAAgICAICAgdHR0PDw8WFhYICAgLCwsXFxcvLy8ODg4uLi4iIiIqKiokJCQYGBgKCgonJycFBQUCAgIqKiocHBwcHBwODg4eHh4cHBwnJycJCQkUFBQqKiojIyMuLi4ZGRkgICAEBATOWYXAAAAAGnRSTlMAD7+fnz8/H7/ff18/77+vr5+fn39/b28fH2xSoKsAAACQSURBVBjTrYxJEsMgDARZZMAY73sgCcn/HxnhKtnk7j6oRq0psfuoyndZ/SuODkHPLzfVT6KeyPePnJ7KrnkRjWMXTn4SMnN8mXe2SSM3ts8L/ZUxxrbAULSYJJULE0Iw9pjpenoICcgcX61mGgTgtCv9Be99pzCoDhNQWQnchD1mup5++CYGcoQexajZbfwAj/0MD8ZOaUgAAAAASUVORK5CYII=';
Editor.editImage            = 'data:image/gif;base64,R0lGODlhCwALAIABAFdXV////yH5BAEAAAEALAAAAAALAAsAAAIZjB8AiKuc4jvLOGqzrjX6zmkWyChXaUJBAQA7';
Editor.zoomOutLargeImage    = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALXRSTlMA+vTcKMM96GRBHwXxi0YaX1HLrKWhiHpWEOnOr52Vb2xKSDcT19PKv5l/Ngdk8+viAAABJklEQVQ4y4WT2XaDMAxEvWD2nSSUNEnTJN3r//+9Sj7ILAY6L0ijC4ONYVZRpo6cByrz2YKSUGorGTpz71lPVHvT+avoB5wIkU/mxk8veceSuNoLg44IzziXjvpih72wKQnm8yc2UoiP/LAd8jQfe2Xf4Pq+2EyYIvv9wbzHHCgwxDdlBtWZOdqDfTCVgqpygQpsZaojVAVc9UjQxnAJDIBhiQv84tq3gMQCAVTxVoSibXJf8tMuc7e1TB/DCmejBNg/w1Y3c+AM5vv4w7xM59/oXamrHaLVqPQ+OTCnmMZxgz0SdL5zji0/ld6j88qGa5KIiBB6WeJGKfUKwSMKLuXgvl1TW0tm5R9UQL/efSDYsnzxD8CinhBsTTdugJatKpJwf8v+ADb8QmvW7AeAAAAAAElFTkSuQmCC';
Editor.zoomInLargeImage     = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALXRSTlMA+vTcKMM96GRBHwXxi0YaX1HLrKWhiHpWEOnOr52Vb2xKSDcT19PKv5l/Ngdk8+viAAABKElEQVQ4y4WT6WKCMBCENwkBwn2oFKvWqr3L+79es4EkQIDOH2d3Pxk2ABiJlB8JCXjqw4LikHVGLHTm3nM3UeVN5690GBBN0GwyV/3kkrUQR+WeKnREeKpzaXWd77CmJiXGfPIEI4V4yQ9TIW/ntlcMBe731Vts9w5TWG8F5j3mQI4hvrKpdGeYA7CX9qAcl650gVJartxRuhyHVghF8idQAIbFLvCLu28BsQEC6aKtCK6Pyb3JT7PmbmtNH8Ny56CotD/2qOs5cJbuffxgXmCib+xddVU5RNOhkvvkhTlFehzVWCOh3++MYElOhfdovaImnRYVmqDdsuhNp1QrBBE6uGC2+3ZNjGdg5B94oD+9uyVgWT79BwAxEBTWdOu3bWBVgsn/N/AHUD9IC01Oe40AAAAASUVORK5CYII=';
Editor.actualSizeLargeImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAilBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2N2iNAAAALXRSTlMA+vTcKMM96GRBHwXxi0YaX1HLrKWhiHpWEOnOr52Vb2xKSDcT19PKv5l/Ngdk8+viAAABIUlEQVQ4y4WT2XqDIBCFBxDc9yTWNEnTJN3r+79eGT4BEbXnaubMr8dBBaM450dCQp4LWFAascGIRd48eB4cNYE7f6XjgGiCFs5c+dml6CFN6j1V6IQIlHPpdV/usKcmJcV88gQTRXjLD9Mhb+fWq8YG9/uCmTCFjeeDeY85UGKIUGUuqzN42kv7oCouq9oHamlzVR1lVfpAIu1QVRiW+sAv7r4FpAYIZZVsRXB9TP5Dfpo1d1trCgzz1iiptH/sUbdz4CzN9+mLeXHn3+hdddd4RDegsrvzwZwSs2GLPRJidAqCLTlVwaMPqpYMWjTWBB2WRW86pVkhSKyDK2bdt2tmagZG4sBD/evdLQHLEvQfAOKRoLCmG1FAB6uKmby+gz+REDn7O5+EwQAAAABJRU5ErkJggg==';
Editor.printLargeImage      = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAXVBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9RKvvlAAAAHnRSTlMAydnl77qbMLT093H7K4Nd4Ktn082+lYt5bkklEgP44nQSAAAApUlEQVQ4y73P2Q6DIBRF0cOgbRHHzhP//5m9mBAQKjG1cT0Yc7ITAMu1LNQgUZiQ2DYoNQ0sCQb6qgHAfRx48opq3J9AZ6xuF7uOew8Ik1OsCZRS2UAC9V+D9a+QZYxNA45YFQftPtSkATOhw7dAc0vPBwKWiIOjP0JZ0yMuQJ27g36DipOUsqRAM0dR8KD1/ILHaHSE/w8DIx09E3g/BTce6rHUB5sAPKvfF+JdAAAAAElFTkSuQmCC';
Editor.layersLargeImage     = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAmVBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+/v7///+bnZkkAAAAMnRSTlMABPr8ByiD88KsTi/rvJb272mjeUA1CuPe1M/KjVxYHxMP6KZ0S9nYzGRGGRaznpGIbzaGUf0AAAHESURBVDjLbZLZYoIwEEVDgLCjbKIgAlqXqt3m/z+uNwu1rcyDhjl3ktnYL7OY254C0VX3yWFZfzDrOClbbgKxi0YDHjwl4jbnRkXxJS/C1YP3DbBhD1n7Ex4uaAqdVDb3yJ/4J/3nJD2to/ngQz/DfUvzMp4JJ5sSCaF5oXmemgQDfDxzbi+Kq4sU+vNcuAmx94JtyOP2DD4Epz2asWSCz4Z/4fECxyNj9zC9xNLHcdPEO+awDKeSaUu0W4twZQiO2hYVisTR3RCtK/c1X6t4xMEpiGqXqVntEBLolkZZsKY4QtwH6jzq67dEHlJysB1aNOD3XT7n1UkasQN59L4yC2RELMDSeCRtz3yV22Ub3ozIUTknYx8JWqDdQxbUes98cR2kZtUSveF/bAhcedwEWmlxIkpZUy4XOCb6VBjjxHvbwo/1lBAHHi2JCr0NI570QhyHq/DhJoE2lLgyA4RVe6KmZ47O/3b86MCP0HWa73A8/C3SUc5Qc1ajt6fgpXJ+RGpMvDSchepZDOOQRcZVIKcK90x2D7etqtI+56+u6n3sPriO6nfphitR4+O2m3EbM7lh3me1FM1o+LMI887rN+s3/wZdTFlpNVJiOAAAAABJRU5ErkJggg==';
Editor.refreshLargeImage    = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAolBMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8ELnaCAAAANXRSTlMABfyE2QKU+dfNyyDyoVYKwnTv7N+6rntsYlFNQjEqEw316uSzf2c1JB3GvqebiVw6GAjQB4DQr10AAAE7SURBVDjLvZLXcoMwEABPIgRCx3TT3A3udqL//7UgAdGRcR4yk8k+idsdmgS/QyWEqD/axS2JDV33zlnzLHIzQ2MDq9OeJ3m8l76KKENYlxrmM/b65Ys1+8YxnTEZFIEY0vVhszFWfUGZDJpQTDznTgAe5k4XhQxILB7ruzBQn+kkyDXuHfRtjoYDEvH7J9Lz98dBZXXL94X0Ofco2PFlChKbjVzEdakoSlKjoNoqPYkJ/wUZAYwc+PpLj1Ei7+jdoBWlwQZoJv2H1w3CWgRvo7dd9DP5btgwCWz0M02+oVoxCcIWeY9PNmR6B++m9prMxYEISpCBYBlfy9bc745is7UUULAem1Ww7FfalsiA2uaJsgmWP3pQI9q9/yMLkaaHAp2fxhHff/cNq7dBdHXhGW7l+Mo2zU0Cf8knJ2xA0oJ8enwAAAAASUVORK5CYII='; 
Editor.marksImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAA3QAAAN0BcFOiBwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAMNSURBVFiFzZdPaFxVFMZ/57w/M5lMbK2NoUNdhYKUKWRRQSqWlLhqwYULhYJuuhEEFy5cxZV7NxUXLrooaKGLLpQKFYtpg93YhdAQEN1I1BBGkTrpJDPvvXtczCR25s1M7iv99y3ve+d83z33nnvOETPDB7JKzF/pPOjrYHWQQ0CtvPHvpIkmprQIdM0Fdimtbp+3+elNL797CZDrzBC5j4B3gKnB7+X1u3kjFXNxuELI2faZ6soDCZBVYhpuEeEDYHKUg6ECdp1AVoqWk31bp0dFZKiA7q6zKyAnxqnfU0APLtImpeDEsGhojvwmx4jcbR9yX2jipqSV/RRe3Xojx3d/BHrnfRs47OvcJwI7MNXMKsHc/ZHYjYCsEnfD7kc+HcH7NeGzlyY5MhV4CRDnAtrZLVlqVHMCaLhF37DPluHHOeXDw8Kx/SEXXq7yynTkJUITNxXdnfimT4BcZ6Z3273w9vNCKP1r7x4p+5oTtJNXS1c367sCenk+MtUGMWyzz0SSXxwFA1K+BFBZJab7yHjji0Z+7fJv7SIu0E5al6VGNeCtxQWQc0WM19rw8xY8G8KEGV//kfD5r9uFBGAIxJvCjexT4L1i1v+jSBoOwpWjO2GvsHgZBAIvTvSvzR7qXoh7KfzQSIopyNwLYa+qeWFS4Vq9//Fcb1W6vgzmvysWDXFUFKj5GqQG1/4xmlkhntECzEW5WjAOLQfnfjHWil34sVDgz4fnrhhMNFGw9ScmQGkpyNiO5ZEi0DUF99WT4neBXVIOhktA87Gzq1ha3T6vdpQOcPFx87s4XLH56c1uGib6MXBvL6OZGL6tK7NDKm8osPTaPj92AULOQq8c2wIbGJ/sZRcLHK1AacjrYXSfah9kpWh5py3b7Qm7g0f2/biuSIHqQPf13N/912d9y40ld5E2Owc6tZ02/elpSqF3FOhp4HdvrwXI00r85uBskDtNO8kdEj0OduthkbtIm1YJ5tIzE1cGvw0tRrbABgeDUxhe2TESAlk5Wu4c6NRGzYhP73Ca+/ERjef/AfW6ODyK+5txAAAAAElFTkSuQmCC';

Editor.ctrlKey = (mxClient.IS_MAC) ? 'Cmd' : 'Ctrl';

mxUtils.extend(Editor, mxEventSource);

/**
 * Stores initial state of mxClient.NO_FO.
 */
Editor.prototype.originalNoForeignObject = mxClient.NO_FO;

/**
 * Specifies if the canvas should be extended in all directions. Default is true.
 */
Editor.prototype.extendCanvas = true;

/**
 * Specifies if the app should run in view mode. Default is false.
 * This default is only used if the contructor argument is null.
 */
Editor.prototype.viewMode = false;

/**
 * Contains the name which was used for the last save. Default value is null.
 */
Editor.prototype.filename = null;

/**
 * Contains the current modified state of the diagram. This is false for
 * new diagrams and after the diagram was saved.
 */
Editor.prototype.modified = false;

/**
 * Specifies if the diagram should be saved automatically if possible. Default
 * is true.
 */
Editor.prototype.autosave = false;

/**
 * Specifies the top spacing for the initial page view. Default is 0.
 */
Editor.prototype.initialTopSpacing = 0;

/**
 * Specifies the app name. Default is document.title.
 */
Editor.prototype.appName = document.title;

/**
 * Default value for the graph container overflow style.
 */
Editor.prototype.defaultGraphOverflow = 'hidden';

/**
 * Initializes the environment.
 */
Editor.prototype.init = function() { };

/**
 * Sets the XML node for the current diagram.
 */
Editor.prototype.isViewMode = function()
{
    return this.viewMode;
};

/**
 * Sets the XML node for the current diagram.
 */
Editor.prototype.setAutosave = function(value)
{
    this.autosave = value;
    this.fireEvent(new mxEventObject('autosaveChanged'));
};

/**
 * Updates the document title.
 */
Editor.prototype.updateDocumentTitle = function ()
{
    var title = this.getFilename();
    if (isNullOrEmpty(title))
        title = this.appName;
    if (!this.isViewMode() && this.modified)
        title += ' *';
    document.title = title;
};

/**
 * Sets the XML node for the current diagram.
 */
Editor.prototype.createGraph = function(themes, model)
{
    var graph = new Graph(null, model, null, null, themes);
    graph.transparentBackground = false;
    graph.setHtmlLabels(true);
    // Highlight cell in view mode
    if (!this.isViewMode())
    {
        // Opens all links in a new window while editing
        graph.isBlankLink = function (href)
        {
            return !this.isExternalProtocol(href);
        };
    }
    return graph;
};

/**
 * Sets the XML node for the current diagram.
 */
Editor.prototype.resetGraph = function()
{
    this.graph.gridEnabled = !this.isViewMode();
    this.graph.graphHandler.guidesEnabled = true;
    this.graph.setTooltips(true);
    this.graph.setConnectable(true);
    this.graph.foldingEnabled = true;
    this.graph.scrollbars = this.graph.defaultScrollbars;
    this.graph.pageVisible = this.graph.defaultPageVisible;
    this.graph.pageBreaksVisible = this.graph.pageVisible; 
    this.graph.preferPageSize = this.graph.pageBreaksVisible;
    this.graph.background = null;
    this.graph.pageScale = mxGraph.prototype.pageScale;
    this.graph.pageFormat = mxGraph.prototype.pageFormat;
    this.graph.currentScale = 1;
    this.graph.currentTranslate.x = 0;
    this.graph.currentTranslate.y = 0;
    this.updateGraphComponents();
    this.graph.view.setScale(1);
};

/**
 * Sets the XML node for the current diagram.
 */
Editor.prototype.readGraphState = function(node)
{
    this.graph.gridEnabled = node.getAttribute('grid') != '0' && !this.isViewMode();
    this.graph.gridSize = parseFloat(node.getAttribute('gridSize')) || mxGraph.prototype.gridSize;
    this.graph.graphHandler.guidesEnabled = node.getAttribute('guides') != '0';
    this.graph.setTooltips(node.getAttribute('tooltips') != '0');
    this.graph.setConnectable(node.getAttribute('connect') != '0');
    this.graph.connectionArrowsEnabled = node.getAttribute('arrows') != '0';
    this.graph.foldingEnabled = node.getAttribute('fold') != '0';

    if (this.isViewMode() && this.graph.foldingEnabled)
    {
        this.graph.foldingEnabled = true;
        this.graph.cellRenderer.forceControlClickHandler = this.graph.foldingEnabled;
    }
    
    var ps = parseFloat(node.getAttribute('pageScale'));
    if (!isNaN(ps) && ps > 0)
    {
        this.graph.pageScale = ps;
    }
    else
    {
        this.graph.pageScale = mxGraph.prototype.pageScale;
    }

    var pv = node.getAttribute('page');
    if (pv != null)
        this.graph.pageVisible = (pv != '0');
    else
        this.graph.pageVisible = this.graph.defaultPageVisible;
    
    this.graph.pageBreaksVisible = this.graph.pageVisible; 
    this.graph.preferPageSize = this.graph.pageBreaksVisible;
    
    var pw = parseFloat(node.getAttribute('pageWidth'));
    var ph = parseFloat(node.getAttribute('pageHeight'));
    
    if (!isNaN(pw) && !isNaN(ph))
    {
        this.graph.pageFormat = new mxRectangle(0, 0, pw, ph);
    }

    // Loads the persistent state settings
    var bg = node.getAttribute('background');
    if (bg != null && bg.length > 0)
        this.graph.background = bg;
    else
        this.graph.background = null;
};

/**
 * Sets the XML node for the current diagram.
 */
Editor.prototype.setGraphXml = function(node)
{
    if (node != null)
    {
        var dec = new mxCodec(node.ownerDocument);
    
        if (node.nodeName == 'mxGraphModel')
        {
            this.graph.model.beginUpdate();
            
            try
            {
                this.graph.model.clear();
                this.graph.view.scale = 1;
                this.readGraphState(node);
                this.updateGraphComponents();
                dec.decode(node, this.graph.getModel());
            }
            finally
            {
                this.graph.model.endUpdate();
            }
    
            this.fireEvent(new mxEventObject('resetGraphView'));
        }
        else if (node.nodeName == 'root')
        {
            this.resetGraph();
            
            // Workaround for invalid XML output in Firefox 20 due to bug in mxUtils.getXml
            var wrapper = dec.document.createElement('mxGraphModel');
            wrapper.appendChild(node);
            
            dec.decode(wrapper, this.graph.getModel());
            this.updateGraphComponents();
            this.fireEvent(new mxEventObject('resetGraphView'));
        }
        else
        {
            throw { 
                message: mxResources.get('cannotOpenFile'), 
                node: node,
                toString: function() { return this.message; }
            };
        }
    }
    else
    {
        this.resetGraph();
        this.graph.model.clear();
        this.fireEvent(new mxEventObject('resetGraphView'));
    }
};

/**
 * Returns the XML node that represents the current diagram.
 */
Editor.prototype.getGraphXml = function(ignoreSelection)
{
    ignoreSelection = (ignoreSelection != null) ? ignoreSelection : true;
    var node = null;
    
    if (ignoreSelection)
    {
        var enc = new mxCodec(mxUtils.createXmlDocument());
        node = enc.encode(this.graph.getModel());
    }
    else
    {
        node = this.graph.encodeCells(mxUtils.sortCells(this.graph.model.getTopmostCells(
            this.graph.getSelectionCells())));
    }

    if (this.graph.view.translate.x != 0 || this.graph.view.translate.y != 0)
    {
        node.setAttribute('dx', Math.round(this.graph.view.translate.x * 100) / 100);
        node.setAttribute('dy', Math.round(this.graph.view.translate.y * 100) / 100);
    }
    
    node.setAttribute('grid', (this.graph.isGridEnabled()) ? '1' : '0');
    node.setAttribute('gridSize', this.graph.gridSize);
    node.setAttribute('guides', (this.graph.graphHandler.guidesEnabled) ? '1' : '0');
    node.setAttribute('tooltips', (this.graph.tooltipHandler.isEnabled()) ? '1' : '0');
    node.setAttribute('connect', (this.graph.connectionHandler.isEnabled()) ? '1' : '0');
    node.setAttribute('arrows', (this.graph.connectionArrowsEnabled) ? '1' : '0');
    node.setAttribute('fold', (this.graph.foldingEnabled) ? '1' : '0');
    node.setAttribute('page', (this.graph.pageVisible) ? '1' : '0');
    node.setAttribute('pageScale', this.graph.pageScale);
    node.setAttribute('pageWidth', this.graph.pageFormat.width);
    node.setAttribute('pageHeight', this.graph.pageFormat.height);

    if (this.graph.background != null)
    {
        node.setAttribute('background', this.graph.background);
    }
   
    return node;
};

/**
 * Keeps the graph container in sync with the persistent graph state
 */
Editor.prototype.updateGraphComponents = function()
{
    var graph = this.graph;
    if (graph.container != null)
    {
        graph.view.validateBackground();
        graph.container.style.overflow = (graph.scrollbars) ? 'auto' : this.defaultGraphOverflow;
        
        this.fireEvent(new mxEventObject('updateGraphComponents'));
    }
};

/**
 * Sets the modified flag.
 */
Editor.prototype.setModified = function(value)
{
    this.modified = value;
    this.updateDocumentTitle();
};

/**
 * Sets the filename.
 */
Editor.prototype.setFilename = function(value)
{
    this.filename = value;
};

/**
 * Creates and returns a new undo manager.
 */
Editor.prototype.createUndoManager = function()
{
    var graph = this.graph;
    var undoMgr = new mxUndoManager();

    this.undoListener = function(sender, evt)
    {
        undoMgr.undoableEditHappened(evt.getProperty('edit'));
    };
    
    // Installs the command history
    var listener = mxUtils.bind(this, function(sender, evt)
    {
        this.undoListener.apply(this, arguments);
    });
    
    graph.getModel().addListener(mxEvent.UNDO, listener);
    graph.getView().addListener(mxEvent.UNDO, listener);

    // Keeps the selection in sync with the history
    var undoHandler = function(sender, evt)
    {
        var cand = graph.getSelectionCellsForChanges(evt.getProperty('edit').changes);
        var model = graph.getModel();
        var cells = [];
        
        for (var i = 0; i < cand.length; i++)
        {
            if (graph.view.getState(cand[i]) != null)
            {
                cells.push(cand[i]);
            }
        }
        
        graph.setSelectionCells(cells);
    };
    
    undoMgr.addListener(mxEvent.UNDO, undoHandler);
    undoMgr.addListener(mxEvent.REDO, undoHandler);

    return undoMgr;
};

/**
 * Creates and returns a new undo manager.
 */
Editor.prototype.destroy = function()
{
    if (this.graph != null)
    {
        this.graph.destroy();
        this.graph = null;
    }
};

/**
 * Class for asynchronously opening a new window and loading a file at the same
 * time. This acts as a bridge between the open dialog and the new editor.
 */
function OpenFile(done)
{
    this.producer = null;
    this.consumer = null;
    this.done = done;
    this.args = null;
};

/**
 * Registers the editor from the new window.
 */
OpenFile.prototype.setConsumer = function(value)
{
    this.consumer = value;
    this.execute();
};

/**
 * Sets the data from the loaded file.
 */
OpenFile.prototype.setData = function()
{
    this.args = arguments;
    this.execute();
};

/**
 * Displays an error message.
 */
OpenFile.prototype.error = function(msg)
{
    this.cancel(true);
    //---fix---//
    console.log(msg);
    //---fix---//
};

/**
 * Consumes the data.
 */
OpenFile.prototype.execute = function()
{
    if (this.consumer != null && this.args != null)
    {
        this.cancel(false);
        this.consumer.apply(this, this.args);
    }
};

/**
 * Cancels the operation.
 */
OpenFile.prototype.cancel = function(cancel)
{
    if (this.done != null)
    {
        this.done((cancel != null) ? cancel : true);
    }
};

/**
 * Basic dialogs that are available in the viewer (print dialog).
 */
function Dialog(editorUi, elt, w, h, modal, closable, onClose, noScroll, transparent, onResize, ignoreBgClick)
    {    
    var w0 = w;
    var h0 = h;
    
    var ds = mxUtils.getDocumentSize();
    var dh = ds.height;
    var left = Math.max(1, Math.round((ds.width - w - 32) / 2));
    var top = Math.max(1, Math.round((dh - h - editorUi.footerHeight) / 3));
    
    // Keeps window size inside available space
    //elt.style.maxHeight = '100%';
    
    w = (document.body != null) ? Math.min(w, document.body.scrollWidth - 32) : w;
    h = Math.min(h, dh - 32);
    
    // Increments zIndex to put subdialogs and background over existing dialogs and background
    if (editorUi.dialogs.length > 0)
    {
        this.zIndex += editorUi.dialogs.length * 2;
    }

    if (this.bg == null)
    {
        this.bg = editorUi.createDiv('background');
        this.bg.style.position = 'absolute';
        this.bg.style.background = Dialog.backdropColor;
        this.bg.style.height = dh + 'px';
        this.bg.style.right = '0px';
        this.bg.style.zIndex = this.zIndex - 2;
        
        mxUtils.setOpacity(this.bg, this.bgOpacity);
    }
    
    var origin = mxUtils.getDocumentScrollOrigin(document);
    this.bg.style.left = origin.x + 'px';
    this.bg.style.top = origin.y + 'px';
    left += origin.x;
    top += origin.y;

    if (modal)
        document.body.appendChild(this.bg);
    
    var div = editorUi.createDiv(transparent? 'geTransDialog' : 'geDialog');
    var pos = this.getPosition(left, top, w, h);
    left = pos.x;
    top = pos.y;
    
    div.style.width = w + 'px';
    div.style.height = h + 'px';
    div.style.left = left + 'px';
    div.style.top = top + 'px';
    div.style.zIndex = this.zIndex;
    
    div.appendChild(elt);
    document.body.appendChild(div);
    
    // Adds vertical scrollbars if needed
    if (!noScroll && elt.clientHeight > div.clientHeight - 32)
    {
        elt.style.overflowY = 'auto';
    }
    
    if (closable)
    {
        var img = document.createElement('img');

        img.setAttribute('src', Dialog.prototype.closeImage);
        img.setAttribute('title', mxResources.get('close'));
        img.className = 'geDialogClose';
        img.style.top = (top + 5) + 'px';
        img.style.left = (left + w + 25) + 'px';
        img.style.zIndex = this.zIndex;
        
        mxEvent.addListener(img, 'click', mxUtils.bind(this, function()
        {
            editorUi.hideDialog(true);
        }));
        
        document.body.appendChild(img);
        this.dialogImg = img;
        
        if (!ignoreBgClick)
        {
            mxEvent.addGestureListeners(this.bg, null, null, mxUtils.bind(this, function(evt)
            {
                editorUi.hideDialog(true);
            }));
        }
    }
    
    this.resizeListener = mxUtils.bind(this, function()
    {
        if (onResize != null)
        {
            var newWH = onResize();
            
            if (newWH != null)
            {
                w0 = w = newWH.w;
                h0 = h = newWH.h;
            }
        }
        
        var ds = mxUtils.getDocumentSize();
        dh = ds.height;
        this.bg.style.height = dh + 'px';
        
        left = Math.max(1, Math.round((ds.width - w - 32) / 2));
        top = Math.max(1, Math.round((dh - h - editorUi.footerHeight) / 3));
        w = (document.body != null) ? Math.min(w0, document.body.scrollWidth - 32) : w0;
        h = Math.min(h0, dh - 32);
        
        var pos = this.getPosition(left, top, w, h);
        left = pos.x;
        top = pos.y;
        
        div.style.left = left + 'px';
        div.style.top = top + 'px';
        div.style.width = w + 'px';
        div.style.height = h + 'px';
        
        // Adds vertical scrollbars if needed
        if (!noScroll && elt.clientHeight > div.clientHeight - 32)
            elt.style.overflowY = 'auto';
        
        if (this.dialogImg != null)
        {
            this.dialogImg.style.top = (top + 5) + 'px';
            this.dialogImg.style.left = (left + w + 25) + 'px';
        }
    });
    
    mxEvent.addListener(window, 'resize', this.resizeListener);

    this.onDialogClose = onClose;
    this.container = div;
    
    editorUi.editor.fireEvent(new mxEventObject('showDialog'));
}


Dialog.backdropColor       = 'white';
Dialog.prototype.zIndex    = mxPopupMenu.prototype.zIndex - 1;
Dialog.prototype.bgOpacity = 80;

Dialog.prototype.noColorImage  = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyBpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBXaW5kb3dzIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkEzRDlBMUUwODYxMTExRTFCMzA4RDdDMjJBMEMxRDM3IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkEzRDlBMUUxODYxMTExRTFCMzA4RDdDMjJBMEMxRDM3Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6QTNEOUExREU4NjExMTFFMUIzMDhEN0MyMkEwQzFEMzciIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6QTNEOUExREY4NjExMTFFMUIzMDhEN0MyMkEwQzFEMzciLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5xh3fmAAAABlBMVEX////MzMw46qqDAAAAGElEQVR42mJggAJGKGAYIIGBth8KAAIMAEUQAIElnLuQAAAAAElFTkSuQmCC';
Dialog.prototype.clearImage    = 'data:image/gif;base64,R0lGODlhDQAKAIABAMDAwP///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUIzOEM1NzI4NjEyMTFFMUEzMkNDMUE3NjZERDE2QjIiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUIzOEM1NzM4NjEyMTFFMUEzMkNDMUE3NjZERDE2QjIiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QjM4QzU3MDg2MTIxMUUxQTMyQ0MxQTc2NkREMTZCMiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QjM4QzU3MTg2MTIxMUUxQTMyQ0MxQTc2NkREMTZCMiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PgH//v38+/r5+Pf29fTz8vHw7+7t7Ovq6ejn5uXk4+Lh4N/e3dzb2tnY19bV1NPS0dDPzs3My8rJyMfGxcTDwsHAv769vLu6ubi3trW0s7KxsK+urayrqqmop6alpKOioaCfnp2cm5qZmJeWlZSTkpGQj46NjIuKiYiHhoWEg4KBgH9+fXx7enl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmFgX15dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQzMjEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGhkYFxYVFBMSERAPDg0MCwoJCAcGBQQDAgEAACH5BAEAAAEALAAAAAANAAoAAAIXTGCJebD9jEOTqRlttXdrB32PJ2ncyRQAOw==';
Dialog.prototype.lockedImage   = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAMAAABhq6zVAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzdDMDZCODExNzIxMTFFNUI0RTk5NTg4OTcyMUUyODEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzdDMDZCODIxNzIxMTFFNUI0RTk5NTg4OTcyMUUyODEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozN0MwNkI3RjE3MjExMUU1QjRFOTk1ODg5NzIxRTI4MSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozN0MwNkI4MDE3MjExMUU1QjRFOTk1ODg5NzIxRTI4MSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PvqMCFYAAAAVUExURZmZmb+/v7KysqysrMzMzLGxsf///4g8N1cAAAAHdFJOU////////wAaSwNGAAAAPElEQVR42lTMQQ4AIQgEwUa0//9kTQirOweYOgDqAMbZUr10AGlAwx4/BJ2QJ4U0L5brYjovvpv32xZgAHZaATFtMbu4AAAAAElFTkSuQmCC';
Dialog.prototype.unlockedImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAMAAABhq6zVAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzdDMDZCN0QxNzIxMTFFNUI0RTk5NTg4OTcyMUUyODEiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzdDMDZCN0UxNzIxMTFFNUI0RTk5NTg4OTcyMUUyODEiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDozN0MwNkI3QjE3MjExMUU1QjRFOTk1ODg5NzIxRTI4MSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozN0MwNkI3QzE3MjExMUU1QjRFOTk1ODg5NzIxRTI4MSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PkKMpVwAAAAYUExURZmZmbKysr+/v6ysrOXl5czMzLGxsf///zHN5lwAAAAIdFJOU/////////8A3oO9WQAAADxJREFUeNpUzFESACAEBNBVsfe/cZJU+8Mzs8CIABCidtfGOndnYsT40HDSiCcbPdoJo10o9aI677cpwACRoAF3dFNlswAAAABJRU5ErkJggg==';
Dialog.prototype.closeImage    = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAJAQMAAADaX5RTAAAABlBMVEV7mr3///+wksspAAAAAnRSTlP/AOW3MEoAAAAdSURBVAgdY9jXwCDDwNDRwHCwgeExmASygSL7GgB12QiqNHZZIwAAAABJRU5ErkJggg==';

Dialog.prototype.getPosition = function(left, top)
{
    return new mxPoint(left, top);
};
Dialog.prototype.close = function(cancel, isEsc)
{
    if (this.onDialogClose != null)
    {
        if (this.onDialogClose(cancel, isEsc) == false)
        {
            return false;
        }
        
        this.onDialogClose = null;
    }
    
    if (this.dialogImg != null)
    {
        this.dialogImg.parentNode.removeChild(this.dialogImg);
        this.dialogImg = null;
    }
    
    if (this.bg != null && this.bg.parentNode != null)
    {
        this.bg.parentNode.removeChild(this.bg);
    }
    
    mxEvent.removeListener(window, 'resize', this.resizeListener);
    this.container.parentNode.removeChild(this.container);
};

var ErrorDialog = function(editorUi, title, message, buttonText, fn, retry, buttonText2, fn2, hide, buttonText3, fn3)
{
    hide = (hide != null) ? hide : true;
    
    var div = document.createElement('div');
    div.style.textAlign = 'center';

    if (title != null)
    {
        var hd = document.createElement('div');
        hd.style.padding = '0px';
        hd.style.margin = '0px';
        hd.style.fontSize = '18px';
        hd.style.paddingBottom = '16px';
        hd.style.marginBottom = '10px';
        hd.style.borderBottom = '1px solid #c0c0c0';
        hd.style.color = 'gray';
        hd.style.whiteSpace = 'nowrap';
        hd.style.textOverflow = 'ellipsis';
        hd.style.overflow = 'hidden';
        mxUtils.write(hd, title);
        hd.setAttribute('title', title);
        div.appendChild(hd);
    }

    var p2 = document.createElement('div');
    p2.style.lineHeight = '1.2em';
    p2.style.padding = '6px';
    p2.innerHTML = message;
    div.appendChild(p2);
    
    var btns = document.createElement('div');
    btns.style.marginTop = '12px';
    btns.style.textAlign = 'center';
    
    if (retry != null)
    {
        var retryBtn = mxUtils.button(mxResources.get('tryAgain'), function()
        {
            editorUi.hideDialog();
            retry();
        });
        retryBtn.className = 'geBtn';
        btns.appendChild(retryBtn);
        
        btns.style.textAlign = 'center';
    }
    
    if (buttonText3 != null)
    {
        var btn3 = mxUtils.button(buttonText3, function()
        {
            if (fn3 != null)
            {
                fn3();
            }
        });
        
        btn3.className = 'geBtn';
        btns.appendChild(btn3);
    }
    
    var btn = mxUtils.button(buttonText, function()
    {
        if (hide)
            editorUi.hideDialog();
        if (fn != null)
            fn();
    });
    
    btn.className = 'geBtn';
    btns.appendChild(btn);

    if (buttonText2 != null)
    {
        var mainBtn = mxUtils.button(buttonText2, function()
        {
            if (hide)
                editorUi.hideDialog();            
            if (fn2 != null)
                fn2();            
        });
        
        mainBtn.className = 'geBtn gePrimaryBtn';
        btns.appendChild(mainBtn);
    }

    this.init = function()
    {
        btn.focus();
    };
    
    div.appendChild(btns);

    this.container = div;
};

/**
 * Constructs a new print dialog.
 */
var PrintDialog = function(editorUi, title)
{
    this.create(editorUi, title);
};
PrintDialog.previewEnabled = true;
PrintDialog.prototype.create = function(editorUi)
{
    var graph = editorUi.editor.graph;
    var row, td;
    
    var table = document.createElement('table');
    table.style.width = '100%';
    table.style.height = '100%';
    var tbody = document.createElement('tbody');
    
    row = document.createElement('tr');
    
    var onePageCheckBox = document.createElement('input');
    onePageCheckBox.setAttribute('type', 'checkbox');
    td = document.createElement('td');
    td.setAttribute('colspan', '2');
    //td.style.fontSize = '10pt';
    td.appendChild(onePageCheckBox);
    
    var span = document.createElement('span');
    mxUtils.write(span, ' ' + mxResources.get('fitPage'));
    td.appendChild(span);
    
    //mxEvent.addListener(span, 'click', function(evt)
    //{
    //    pageCountCheckBox.checked = false;
    //    onePageCheckBox.checked = !onePageCheckBox.checked;
    //    //pageCountCheckBox.checked = !onePageCheckBox.checked;
    //    mxEvent.consume(evt);
    //});
    mxEvent.addListener(onePageCheckBox, 'change', function()
    {
        //pageCountCheckBox.checked = !onePageCheckBox.checked;
        if (pageCountCheckBox.checked)
            pageCountCheckBox.click();
    });
    
    row.appendChild(td);
    tbody.appendChild(row);

    row = row.cloneNode(false);
    
    var pageCountCheckBox = document.createElement('input');
    pageCountCheckBox.setAttribute('type', 'checkbox');
    td = document.createElement('td');
    //td.style.fontSize = '10pt';
    td.appendChild(pageCountCheckBox);
    
    var span = document.createElement('span');
    mxUtils.write(span, ' ' + mxResources.get('posterPrint') + ':');
    td.appendChild(span);
    
    //mxEvent.addListener(span, 'click', function(evt)
    //{
    //    onePageCheckBox.checked   = false;
    //    pageCountCheckBox.checked = !pageCountCheckBox.checked;
    //    //onePageCheckBox.checked = !pageCountCheckBox.checked;
    //    mxEvent.consume(evt);
    //});
    
    row.appendChild(td);
    
    var pageCountInput = document.createElement('input');
    pageCountInput.setAttribute('value', '1');
    pageCountInput.setAttribute('type', 'number');
    pageCountInput.setAttribute('min', '1');
    pageCountInput.setAttribute('size', '4');
    pageCountInput.setAttribute('disabled', 'disabled');
    pageCountInput.style.width = '50px';

    td = document.createElement('td');
    //td.style.fontSize = '10pt';
    td.appendChild(pageCountInput);
    mxUtils.write(td, ' ' + mxResources.get('pages'));
    row.appendChild(td);
    tbody.appendChild(row);

    mxEvent.addListener(pageCountCheckBox, 'change', function()
    {
        if (pageCountCheckBox.checked)
        {
            pageCountInput.removeAttribute('disabled');
        }
        else
        {
            pageCountInput.setAttribute('disabled', 'disabled');
        }

        //onePageCheckBox.checked = !pageCountCheckBox.checked;
        if (onePageCheckBox.checked)
            onePageCheckBox.click();
    });

    row = row.cloneNode(false);
    
    td = document.createElement('td');
    mxUtils.write(td, mxResources.get('pageScale') + ':');
    row.appendChild(td);
    
    td = document.createElement('td');
    var pageScaleInput = document.createElement('input');
    pageScaleInput.setAttribute('value', '100 %');
    pageScaleInput.setAttribute('size', '5');
    pageScaleInput.style.width = '50px';
    
    td.appendChild(pageScaleInput);
    row.appendChild(td);
    tbody.appendChild(row);
    
    row = document.createElement('tr');
    td = document.createElement('td');
    td.colSpan = 2;
    td.style.paddingTop = '20px';
    td.setAttribute('align', 'right');
    
    // Overall scale for print-out to account for print borders in dialogs etc
    function preview(print)
    {
        var autoOrigin = onePageCheckBox.checked || pageCountCheckBox.checked;
        var printScale = parseInt(pageScaleInput.value) / 100;
        
        if (isNaN(printScale))
        {
            printScale = 1;
            pageScaleInput.value = '100%';
        }
        
        // Workaround to match available paper size in actual print output
        printScale *= 0.75;

        var pf = graph.pageFormat || mxConstants.PAGE_FORMAT_A4_PORTRAIT;
        var scale = 1 / graph.pageScale;
        
        if (autoOrigin)
        {
            var pageCount = (onePageCheckBox.checked) ? 1 : parseInt(pageCountInput.value);
            
            if (!isNaN(pageCount))
            {
                scale = mxUtils.getScaleForPageCount(pageCount, graph, pf);
            }
        }

        // Negative coordinates are cropped or shifted if page visible
        var gb = graph.getGraphBounds();
        var border = 0;
        var x0 = 0;
        var y0 = 0;

        // Applies print scale
        pf = mxRectangle.fromRectangle(pf);
        pf.width = Math.ceil(pf.width * printScale);
        pf.height = Math.ceil(pf.height * printScale);
        scale *= printScale;
        
        // Starts at first visible page
        if (!autoOrigin && graph.pageVisible)
        {
            var layout = graph.getPageLayout();
            x0 -= layout.x * pf.width;
            y0 -= layout.y * pf.height;
        }
        else
        {
            autoOrigin = true;
        }
        
        var preview = PrintDialog.createPrintPreview(graph, scale, pf, border, x0, y0, autoOrigin);
        preview.open();
    
        if (print)
            PrintDialog.printPreview(preview);
    };
    
    var cancelBtn = mxUtils.button(mxResources.get('cancel'), function()
    {
        editorUi.hideDialog();
    });
    cancelBtn.className = 'geBtn';
    td.appendChild(cancelBtn);

    if (PrintDialog.previewEnabled)
    {
        var previewBtn = mxUtils.button(mxResources.get('preview'), function()
        {
            //editorUi.hideDialog();
            preview(false);
        });
        previewBtn.className = 'geBtn';
        td.appendChild(previewBtn);
    }
    
    var printBtn = mxUtils.button(mxResources.get((!PrintDialog.previewEnabled) ? 'ok' : 'print'), function()
    {
        editorUi.hideDialog();
        preview(true);
    });
    printBtn.className = 'geBtn gePrimaryBtn';
    td.appendChild(printBtn);
    row.appendChild(td);

    tbody.appendChild(row);
    table.appendChild(tbody);

    this.container = table;
};
PrintDialog.printPreview = function(preview)
{
    try
    {
        if (preview.wnd != null)
        {
            var printFn = function()
            {
                preview.wnd.focus();
                preview.wnd.print();
                preview.wnd.close();
            };
            
            // Workaround for Google Chrome which needs a bit of a delay in order to render the SVG contents
            if (mxClient.IS_GC)
                window.setTimeout(printFn, 500);
            else
                printFn();
        }
    }
    catch (e)
    {
        // ignores possible Access Denied
    }
};
PrintDialog.createPrintPreview = function(graph, scale, pf, border, x0, y0, autoOrigin)
{
    var preview = new mxPrintPreview(graph, scale, pf, border, x0, y0);
    preview.title = mxResources.get('preview');
    preview.printBackgroundImage = true;
    preview.printControls = true;
    preview.printOverlays = true;
    preview.autoOrigin = autoOrigin;
    var bg = graph.background;
    
    if (bg == null || bg == '' || bg == mxConstants.NONE)
    {
        bg = '#ffffff';
    }
    
    preview.backgroundColor = bg;
    
    var writeHead = preview.writeHead;
    // Adds a border in the preview
    preview.writeHead = function(doc, css)
    {
        //writeHead.apply(this, arguments);

        if (this.title != null)
            doc.writeln('<title>' + this.title + '</title>');

        // Adds required namespaces
        if (mxClient.IS_VML)
            doc.writeln('<style type="text/css">v\\:*{behavior:url(#default#VML)}o\\:*{behavior:url(#default#VML)}</style>');

        // Adds all required stylesheets
        //mxClient.link('stylesheet', mxClient.basePath + '/css/common.css', doc);

        // Removes horizontal rules and page selector from print output
        doc.writeln('<style type="text/css">');
        doc.writeln('@media print {');
        doc.writeln('  * { -webkit-print-color-adjust: exact; }');
        doc.writeln('  table.mxPageSelector { display: none; }');
        doc.writeln('  hr.mxPageBreak { display: none; }');
        doc.writeln('  div.geNoPrint { display: none !important; }');
        doc.writeln('  svg { z-index: 2; }');
        doc.writeln('}');
        doc.writeln('@media screen {');

        // NOTE: position: fixed is not supported in IE, so the page selector
        // position (absolute) needs to be updated in IE (see below)
        doc.writeln('  table.mxPageSelector { position: fixed; right: 10px; top: 10px;' +
            'font-family: Arial; font-size:10pt; border: solid 1px darkgray;' +
            'background: white; border-collapse:collapse; }');
        doc.writeln('  table.mxPageSelector td { border: solid 1px gray; padding:4px; }');
        doc.writeln('  body.mxPage { background: gray; }');
        doc.writeln('  svg { z-index: 2; }');
        doc.writeln('}');

        if (css != null)
            doc.writeln(css);
        doc.writeln('</style>');
        
        doc.writeln('<style type="text/css">');
        doc.writeln('@media screen {');
        doc.writeln('  body > div { padding:30px;box-sizing:content-box; }');
        doc.writeln('}');
        doc.writeln('</style>');

        doc.writeln('<link rel="stylesheet" type="text/css" href="/scheme/scheme.css" />');
    };
    
    return preview;
};

/**
 * Constructs a new page setup dialog.
 */
var PageSetupDialog = function(editorUi)
{
    var graph = editorUi.editor.graph;
    var row, td;

    var table = document.createElement('table');
    table.style.width = '100%';
    table.style.height = '100%';
    var tbody = document.createElement('tbody');
    
    row = document.createElement('tr');
    
    td = document.createElement('td');
    td.style.verticalAlign = 'top';
    //td.style.fontSize = '10pt';
    mxUtils.write(td, mxResources.get('paperSize') + ':');
    
    row.appendChild(td);
    
    td = document.createElement('td');
    td.style.verticalAlign = 'top';
    //td.style.fontSize = '10pt';
    
    var accessor = PageSetupDialog.addPageFormatPanel(td, 'pagesetupdialog', graph.pageFormat);

    row.appendChild(td);
    tbody.appendChild(row);
    
    row = document.createElement('tr');
    
    td = document.createElement('td');
    mxUtils.write(td, mxResources.get('background') + ':');
    
    row.appendChild(td);
    
    td = document.createElement('td');
    td.style.whiteSpace = 'nowrap';
    
    var backgroundInput = document.createElement('input');
    backgroundInput.setAttribute('type', 'text');
    var backgroundButton = document.createElement('button');
    
    backgroundButton.style.width = '18px';
    backgroundButton.style.height = '18px';
    backgroundButton.style.marginRight = '20px';
    backgroundButton.style.backgroundPosition = 'center center';
    backgroundButton.style.backgroundRepeat = 'no-repeat';
    
    var newBackgroundColor = graph.background;
    
    function updateBackgroundColor()
    {
        if (newBackgroundColor == null || newBackgroundColor == mxConstants.NONE)
        {
            backgroundButton.style.backgroundColor = '';
            backgroundButton.style.backgroundImage = 'url(\'' + Dialog.prototype.noColorImage + '\')';
        }
        else
        {
            backgroundButton.style.backgroundColor = newBackgroundColor;
            backgroundButton.style.backgroundImage = '';
        }
    };
    
    updateBackgroundColor();

    mxEvent.addListener(backgroundButton, 'click', function(evt)
    {
        editorUi.pickColor(newBackgroundColor || 'none', function(color)
        {
            newBackgroundColor = color;
            updateBackgroundColor();
        });
        mxEvent.consume(evt);
    });
    
    td.appendChild(backgroundButton);
    
    mxUtils.write(td, mxResources.get('gridSize') + ':');
    
    var gridSizeInput = document.createElement('input');
    gridSizeInput.setAttribute('type', 'number');
    gridSizeInput.setAttribute('min', '0');
    gridSizeInput.style.width = '40px';
    gridSizeInput.style.marginLeft = '6px';
    
    gridSizeInput.value = graph.getGridSize();
    td.appendChild(gridSizeInput);
    
    mxEvent.addListener(gridSizeInput, 'change', function()
    {
        var value = parseInt(gridSizeInput.value);
        gridSizeInput.value = Math.max(1, (isNaN(value)) ? graph.getGridSize() : value);
    });
    
    row.appendChild(td);
    tbody.appendChild(row);

    var newBackgroundImage = graph.backgroundImage;

    /*
    row = document.createElement('tr');
    td = document.createElement('td');
    
    mxUtils.write(td, mxResources.get('image') + ':');
    
    row.appendChild(td);
    td = document.createElement('td');
    
    var changeImageLink = document.createElement('a');
    changeImageLink.style.textDecoration = 'underline';
    changeImageLink.style.cursor = 'pointer';
    changeImageLink.style.color = '#a0a0a0';
    
    function updateBackgroundImage()
    {
        if (newBackgroundImage == null)
        {
            changeImageLink.removeAttribute('title');
            changeImageLink.style.fontSize = '';
            changeImageLink.innerHTML = mxResources.get('change') + '...';
        }
        else
        {
            changeImageLink.setAttribute('title', newBackgroundImage.src);
            changeImageLink.style.fontSize = '11px';
            changeImageLink.innerHTML = newBackgroundImage.src.substring(0, 42) + '...';
        }
    };
    
    mxEvent.addListener(changeImageLink, 'click', function(evt)
    {
        editorUi.showBackgroundImageDialog(function(image)
        {
            newBackgroundImage = image;
            updateBackgroundImage();
        });
        
        mxEvent.consume(evt);
    });
    
    updateBackgroundImage();

    td.appendChild(changeImageLink);
    
    row.appendChild(td);
    tbody.appendChild(row);
    */

    row = document.createElement('tr');
    td = document.createElement('td');
    td.colSpan = 2;
    td.style.paddingTop = '16px';
    td.setAttribute('align', 'right');

    var cancelBtn = mxUtils.button(mxResources.get('cancel'), function()
    {
        editorUi.hideDialog();
    });
    cancelBtn.className = 'geBtn';
    td.appendChild(cancelBtn);
    
    var applyBtn = mxUtils.button(mxResources.get('apply'), function()
    {
        editorUi.hideDialog();
        
        if (graph.gridSize !== gridSizeInput.value)
        {
            graph.setGridSize(parseInt(gridSizeInput.value));
        }

        var change = new ChangePageSetup(editorUi, newBackgroundColor,
            newBackgroundImage, accessor.get());
        change.ignoreColor = graph.background == newBackgroundColor;
        
        var oldSrc = (graph.backgroundImage != null) ? graph.backgroundImage.src : null;
        var newSrc = (newBackgroundImage != null) ? newBackgroundImage.src : null;
        
        change.ignoreImage = oldSrc === newSrc;

        if (graph.pageFormat.width != change.previousFormat.width ||
            graph.pageFormat.height != change.previousFormat.height ||
            !change.ignoreColor || !change.ignoreImage)
        {
            graph.model.execute(change);
        }
    });
    applyBtn.className = 'geBtn gePrimaryBtn';
    td.appendChild(applyBtn);
    
    row.appendChild(td);
    tbody.appendChild(row);
    
    table.appendChild(tbody);
    this.container = table;
};
PageSetupDialog.addPageFormatPanel = function(div, namePostfix, pageFormat, pageFormatListener)
{
    var formatName = 'format-' + namePostfix;
    
    var portraitCheckBox = document.createElement('input');
    portraitCheckBox.setAttribute('name', formatName);
    portraitCheckBox.setAttribute('type', 'radio');
    portraitCheckBox.setAttribute('value', 'portrait');
    
    var landscapeCheckBox = document.createElement('input');
    landscapeCheckBox.setAttribute('name', formatName);
    landscapeCheckBox.setAttribute('type', 'radio');
    landscapeCheckBox.setAttribute('value', 'landscape');
    
    var paperSizeSelect = document.createElement('select');
    paperSizeSelect.style.marginBottom = '8px';
    paperSizeSelect.style.width = '202px';

    var formatDiv = document.createElement('div');
    //formatDiv.style.marginLeft = '4px';
    formatDiv.style.width = '210px';
    formatDiv.style.height = '24px';

    portraitCheckBox.style.marginRight = '6px';
    formatDiv.appendChild(portraitCheckBox);
    
    var portraitSpan = document.createElement('span');
    portraitSpan.style.maxWidth = '100px';
    mxUtils.write(portraitSpan, mxResources.get('portrait'));
    formatDiv.appendChild(portraitSpan);

    //landscapeCheckBox.style.marginLeft = '10px';
    //landscapeCheckBox.style.marginRight = '6px';
    formatDiv.appendChild(landscapeCheckBox);
    
    var landscapeSpan = document.createElement('span');
    landscapeSpan.style.width = '100px';
    mxUtils.write(landscapeSpan, mxResources.get('landscape'));
    formatDiv.appendChild(landscapeSpan)

    var customDiv = document.createElement('div');
    //customDiv.style.marginLeft = '4px';
    customDiv.style.width = '210px';
    customDiv.style.height = '24px';
    
    var widthInput = document.createElement('input');
    widthInput.setAttribute('size', '7');
    widthInput.style.textAlign = 'right';
    customDiv.appendChild(widthInput);

    mxUtils.write(customDiv, ' x ');
    
    var heightInput = document.createElement('input');
    heightInput.setAttribute('size', '7');
    heightInput.style.textAlign = 'right';
    customDiv.appendChild(heightInput);

    mxUtils.write(customDiv, ' px ');

    formatDiv.style.display = 'none';
    customDiv.style.display = 'none';
    
    var pf = new Object();
    var formats = PageSetupDialog.getFormats();
    
    for (var i = 0; i < formats.length; i++)
    {
        var f = formats[i];
        pf[f.key] = f;

        var paperSizeOption = document.createElement('option');
        paperSizeOption.setAttribute('value', f.key);
        mxUtils.write(paperSizeOption, f.title);
        paperSizeSelect.appendChild(paperSizeOption);
    }
    
    var customSize = false;
    
    function listener(sender, evt, force)
    {
        if (force || (widthInput != document.activeElement && heightInput != document.activeElement))
        {
            var detected = false;
            
            for (var i = 0; i < formats.length; i++)
            {
                var f = formats[i];
    
                // Special case where custom was chosen
                if (customSize)
                {
                    if (f.key == 'custom')
                    {
                        paperSizeSelect.value = f.key;
                        customSize = false;
                    }
                }
                else if (f.format != null)
                {
                    // Fixes wrong values for previous A4 and A5 page sizes
                    if (f.key == 'a4')
                    {
                        if (pageFormat.width == 826)
                        {
                            pageFormat = mxRectangle.fromRectangle(pageFormat);
                            pageFormat.width = 827;
                        }
                        else if (pageFormat.height == 826)
                        {
                            pageFormat = mxRectangle.fromRectangle(pageFormat);
                            pageFormat.height = 827;
                        }
                    }
                    else if (f.key == 'a5')
                    {
                        if (pageFormat.width == 584)
                        {
                            pageFormat = mxRectangle.fromRectangle(pageFormat);
                            pageFormat.width = 583;
                        }
                        else if (pageFormat.height == 584)
                        {
                            pageFormat = mxRectangle.fromRectangle(pageFormat);
                            pageFormat.height = 583;
                        }
                    }
                    
                    if (pageFormat.width == f.format.width && pageFormat.height == f.format.height)
                    {
                        paperSizeSelect.value = f.key;
                        portraitCheckBox.setAttribute('checked', 'checked');
                        portraitCheckBox.defaultChecked = true;
                        portraitCheckBox.checked = true;
                        landscapeCheckBox.removeAttribute('checked');
                        landscapeCheckBox.defaultChecked = false;
                        landscapeCheckBox.checked = false;
                        detected = true;
                    }
                    else if (pageFormat.width == f.format.height && pageFormat.height == f.format.width)
                    {
                        paperSizeSelect.value = f.key;
                        portraitCheckBox.removeAttribute('checked');
                        portraitCheckBox.defaultChecked = false;
                        portraitCheckBox.checked = false;
                        landscapeCheckBox.setAttribute('checked', 'checked');
                        landscapeCheckBox.defaultChecked = true;
                        landscapeCheckBox.checked = true;
                        detected = true;
                    }
                }
            }
            
            // Selects custom format which is last in list
            if (!detected)
            {
                widthInput.value  = pageFormat.width;
                heightInput.value = pageFormat.height;
                portraitCheckBox.setAttribute('checked', 'checked');
                paperSizeSelect.value = 'custom';
                formatDiv.style.display = 'none';
                customDiv.style.display = '';
            }
            else
            {
                formatDiv.style.display = '';
                customDiv.style.display = 'none';
            }
        }
    }
    
    listener();

    div.appendChild(paperSizeSelect);
    mxUtils.br(div);

    div.appendChild(formatDiv);
    div.appendChild(customDiv);
    
    var currentPageFormat = pageFormat;
    
    var update = function(evt, selectChanged)
    {
        var f = pf[paperSizeSelect.value];
        
        if (f.format != null)
        {
            widthInput.value  = f.format.width;
            heightInput.value = f.format.height;
            customDiv.style.display = 'none';
            formatDiv.style.display = '';
        }
        else
        {
            formatDiv.style.display = 'none';
            customDiv.style.display = '';
        }
        
        var wi = parseFloat(widthInput.value);
        
        if (isNaN(wi) || wi <= 0)
            widthInput.value = pageFormat.width;
        
        var hi = parseFloat(heightInput.value);
        
        if (isNaN(hi) || hi <= 0)
            heightInput.value = pageFormat.height;
        
        var newPageFormat = new mxRectangle(0, 0,
            Math.floor(parseFloat(widthInput.value)),
            Math.floor(parseFloat(heightInput.value)));
        
        if (paperSizeSelect.value != 'custom' && landscapeCheckBox.checked)
            newPageFormat = new mxRectangle(0, 0, newPageFormat.height, newPageFormat.width);
        
        // Initial select of custom should not update page format to avoid update of combo
        if ((!selectChanged || !customSize) && (newPageFormat.width != currentPageFormat.width ||
            newPageFormat.height != currentPageFormat.height))
        {
            currentPageFormat = newPageFormat;
            
            // Updates page format and reloads format panel
            if (pageFormatListener != null)
            {
                pageFormatListener(currentPageFormat);
            }
        }
    };

    mxEvent.addListener(portraitSpan, 'click', function(evt)
    {
        portraitCheckBox.checked = true;
        update(evt);
        mxEvent.consume(evt);
    });
    mxEvent.addListener(landscapeSpan, 'click', function(evt)
    {
        landscapeCheckBox.checked = true;
        update(evt);
        mxEvent.consume(evt);
    });
    
    mxEvent.addListener(widthInput, 'blur', update);
    mxEvent.addListener(widthInput, 'click', update);
    mxEvent.addListener(heightInput, 'blur', update);
    mxEvent.addListener(heightInput, 'click', update);
    mxEvent.addListener(landscapeCheckBox, 'change', update);
    mxEvent.addListener(portraitCheckBox, 'change', update);
    mxEvent.addListener(paperSizeSelect, 'change', function(evt)
    {
        // Handles special case where custom was chosen
        customSize = paperSizeSelect.value == 'custom';
        update(evt, true);
    });
    
    update();
    
    return {
        set: function (value)
        {
            pageFormat = value;
            listener(null, null, true);
        },
        get: function ()
        {
            return currentPageFormat;
        },
        widthInput: widthInput,
        heightInput: heightInput
    };
};
PageSetupDialog.getFormats = function()
{
    return [
        //{ key: 'letter', title: 'US-Letter (8,5" x 11")', format: mxConstants.PAGE_FORMAT_LETTER_PORTRAIT },
        //{ key: 'legal', title: 'US-Legal (8,5" x 14")', format: new mxRectangle(0, 0, 850, 1400) },
        //{ key: 'tabloid', title: 'US-Tabloid (279 mm x 432 mm)', format: new mxRectangle(0, 0, 1100, 1700) },
        { key: 'a0', title: 'A0 (841 mm x 1189 mm)', format: new mxRectangle(0, 0, 3300, 4681) },
        { key: 'a1', title: 'A1 (594 mm x 841 mm)', format: new mxRectangle(0, 0, 2339, 3300) },
        { key: 'a2', title: 'A2 (420 mm x 594 mm)', format: new mxRectangle(0, 0, 1654, 2336) },
        { key: 'a3', title: 'A3 (297 mm x 420 mm)', format: new mxRectangle(0, 0, 1169, 1654) },
        { key: 'a4', title: 'A4 (210 mm x 297 mm)', format: mxConstants.PAGE_FORMAT_A4_PORTRAIT },
        { key: 'a5', title: 'A5 (148 mm x 210 mm)', format: new mxRectangle(0, 0, 583, 827) },
        { key: 'a6', title: 'A6 (105 mm x 148 mm)', format: new mxRectangle(0, 0, 413, 583) },
        { key: 'a7', title: 'A7 (74 mm x 105 mm)', format: new mxRectangle(0, 0, 291, 413) },
        { key: 'b4', title: 'B4 (250 mm x 353 mm)', format: new mxRectangle(0, 0, 980, 1390) },
        { key: 'b5', title: 'B5 (176 mm x 250 mm)', format: new mxRectangle(0, 0, 690, 980) },
        { key: '16-9', title: '16:9 (1600 x 900)', format: new mxRectangle(0, 0, 1600, 900) },
        { key: '16-10', title: '16:10 (1920 x 1200)', format: new mxRectangle(0, 0, 1920, 1200) },
        { key: '4-3', title: '4:3 (1600 x 1200)', format: new mxRectangle(0, 0, 1600, 1200) },
        { key: 'custom', title: mxResources.get('custom'), format: null }
    ];
};

/**
 * Static overrides
 */
(function()
{
    // Uses HTML for background pages (to support grid background image)
    mxGraphView.prototype.validateBackgroundPage = function()
    {
        var graph = this.graph;
        
        if (graph.container != null && !graph.transparentBackground)
        {
            if (graph.pageVisible)
            {
                var bounds = this.getBackgroundPageBounds();
                
                if (this.backgroundPageShape == null)
                {
                    // Finds first element in graph container
                    var firstChild = graph.container.firstChild;
                    
                    while (firstChild != null && firstChild.nodeType != mxConstants.NODETYPE_ELEMENT)
                    {
                        firstChild = firstChild.nextSibling;
                    }
                    
                    if (firstChild != null)
                    {
                        this.backgroundPageShape = this.createBackgroundPageShape(bounds);
                        this.backgroundPageShape.scale = 1;
                        
                        this.backgroundPageShape.isShadow = true;
                        this.backgroundPageShape.dialect = mxConstants.DIALECT_STRICTHTML;
                        this.backgroundPageShape.init(graph.container);
    
                        // Required for the browser to render the background page in correct order
                        firstChild.style.position = 'absolute';
                        graph.container.insertBefore(this.backgroundPageShape.node, firstChild);
                        this.backgroundPageShape.redraw();
                        
                        this.backgroundPageShape.node.className = 'geBackgroundPage';
                        
                        // Adds listener for double click handling on background
                        mxEvent.addListener(this.backgroundPageShape.node, 'dblclick',
                            mxUtils.bind(this, function(evt)
                            {
                                graph.dblClick(evt);
                            })
                        );
                        
                        // Adds basic listeners for graph event dispatching outside of the
                        // container and finishing the handling of a single gesture
                        mxEvent.addGestureListeners(this.backgroundPageShape.node,
                            mxUtils.bind(this, function(evt)
                            {
                                graph.fireMouseEvent(mxEvent.MOUSE_DOWN, new mxMouseEvent(evt));
                            }),
                            mxUtils.bind(this, function(evt)
                            {
                                // Hides the tooltip if mouse is outside container
                                if (graph.tooltipHandler != null && graph.tooltipHandler.isHideOnHover())
                                {
                                    graph.tooltipHandler.hide();
                                }
                                
                                if (graph.isMouseDown && !mxEvent.isConsumed(evt))
                                {
                                    graph.fireMouseEvent(mxEvent.MOUSE_MOVE, new mxMouseEvent(evt));
                                }
                            }),
                            mxUtils.bind(this, function(evt)
                            {
                                graph.fireMouseEvent(mxEvent.MOUSE_UP, new mxMouseEvent(evt));
                            })
                        );
                    }
                }
                else
                {
                    this.backgroundPageShape.scale = 1;
                    this.backgroundPageShape.bounds = bounds;
                    this.backgroundPageShape.redraw();
                }
            }
            else if (this.backgroundPageShape != null)
            {
                this.backgroundPageShape.destroy();
                this.backgroundPageShape = null;
            }
            
            this.validateBackgroundStyles();
        }
    };

    // Updates the CSS of the background to draw the grid
    mxGraphView.prototype.validateBackgroundStyles = function()
    {
        var graph = this.graph;
        var color = (graph.background == null || graph.background == mxConstants.NONE) ? graph.defaultPageBackgroundColor : graph.background;
        var gridColor = (color != null && this.gridColor != color.toLowerCase()) ? this.gridColor : '#ffffff';
        var image = 'none';
        var position = '';
        
        if (graph.isGridEnabled())
        {
            var phase = 10;
            
            // Generates the SVG required for drawing the dynamic grid
            image = unescape(encodeURIComponent(this.createSvgGrid(gridColor)));
            image = (window.btoa) ? btoa(image) : Base64.encode(image, true);
            image = 'url(' + 'data:image/svg+xml;base64,' + image + ')'
            phase = graph.gridSize * this.scale * this.gridSteps;
            
            var x0 = 0;
            var y0 = 0;
            
            if (graph.view.backgroundPageShape != null)
            {
                var bds = this.getBackgroundPageBounds();
                
                x0 = 1 + bds.x;
                y0 = 1 + bds.y;
            }
            
            // Computes the offset to maintain origin for grid
            position = -Math.round(phase - mxUtils.mod(this.translate.x * this.scale - x0, phase)) + 'px ' +
                -Math.round(phase - mxUtils.mod(this.translate.y * this.scale - y0, phase)) + 'px';
        }
        
        var canvas = graph.view.canvas;
        
        if (canvas.ownerSVGElement != null)
        {
            canvas = canvas.ownerSVGElement;
        }
        
        if (graph.view.backgroundPageShape != null)
        {
            graph.view.backgroundPageShape.node.style.backgroundPosition = position;
            graph.view.backgroundPageShape.node.style.backgroundImage = image;
            graph.view.backgroundPageShape.node.style.backgroundColor = color;
            graph.container.className = 'geDiagramContainer geDiagramBackdrop';
            canvas.style.backgroundImage = 'none';
            canvas.style.backgroundColor = '';
        }
        else
        {
            graph.container.className = 'geDiagramContainer';
            canvas.style.backgroundPosition = position;
            canvas.style.backgroundColor = color;
            canvas.style.backgroundImage = image;
        }
    };
    
    // Returns the SVG required for painting the background grid.
    mxGraphView.prototype.createSvgGrid = function(color)
    {
        var tmp = this.graph.gridSize * this.scale;
        
        while (tmp < this.minGridSize)
        {
            tmp *= 2;
        }
        
        var tmp2 = this.gridSteps * tmp;
        
        // Small grid lines
        var d = [];
        
        for (var i = 1; i < this.gridSteps; i++)
        {
            var tmp3 = i * tmp;
            d.push('M 0 ' + tmp3 + ' L ' + tmp2 + ' ' + tmp3 + ' M ' + tmp3 + ' 0 L ' + tmp3 + ' ' + tmp2);
        }
        
        // KNOWN: Rounding errors for certain scales (eg. 144%, 121% in Chrome, FF and Safari). Workaround
        // in Chrome is to use 100% for the svg size, but this results in blurred grid for large diagrams.
        var size = tmp2;
        var svg =  '<svg width="' + size + '" height="' + size + '" xmlns="' + mxConstants.NS_SVG + '">' +
            '<defs><pattern id="grid" width="' + tmp2 + '" height="' + tmp2 + '" patternUnits="userSpaceOnUse">' +
            '<path d="' + d.join(' ') + '" fill="none" stroke="' + color + '" opacity="0.2" stroke-width="1"/>' +
            '<path d="M ' + tmp2 + ' 0 L 0 0 0 ' + tmp2 + '" fill="none" stroke="' + color + '" stroke-width="1"/>' +
            '</pattern></defs><rect width="100%" height="100%" fill="url(#grid)"/></svg>';

        return svg;
    };

    // Adds panning for the grid with no page view and disabled scrollbars
    var mxGraphPanGraph = mxGraph.prototype.panGraph;
    mxGraph.prototype.panGraph = function(dx, dy)
    {
        mxGraphPanGraph.apply(this, arguments);
        
        if (this.shiftPreview1 != null)
        {
            var canvas = this.view.canvas;
            if (canvas.ownerSVGElement != null)
                canvas = canvas.ownerSVGElement;
            
            var phase = this.gridSize * this.view.scale * this.view.gridSteps;
            var position = -Math.round(phase - mxUtils.mod(this.view.translate.x * this.view.scale + dx, phase)) + 'px ' +
                -Math.round(phase - mxUtils.mod(this.view.translate.y * this.view.scale + dy, phase)) + 'px';
            canvas.style.backgroundPosition = position;
        }
    };
    
    // Draws page breaks only within the page
    mxGraph.prototype.updatePageBreaks = function(visible, width, height)
    {
        var scale = this.view.scale;
        var tr = this.view.translate;
        var fmt = this.pageFormat;
        var ps = scale * this.pageScale;

        var bounds2 = this.view.getBackgroundPageBounds();

        width = bounds2.width;
        height = bounds2.height;
        var bounds = new mxRectangle(scale * tr.x, scale * tr.y, fmt.width * ps, fmt.height * ps);

        // Does not show page breaks if the scale is too small
        visible = visible && Math.min(bounds.width, bounds.height) > this.minPageBreakDist;

        var horizontalCount = (visible) ? Math.ceil(height / bounds.height) - 1 : 0;
        var verticalCount = (visible) ? Math.ceil(width / bounds.width) - 1 : 0;
        var right = bounds2.x + width;
        var bottom = bounds2.y + height;

        if (this.horizontalPageBreaks == null && horizontalCount > 0)
            this.horizontalPageBreaks = [];
        
        if (this.verticalPageBreaks == null && verticalCount > 0)
            this.verticalPageBreaks = [];
            
        var drawPageBreaks = mxUtils.bind(this, function(breaks)
        {
            if (breaks != null)
            {
                var count = (breaks == this.horizontalPageBreaks) ? horizontalCount : verticalCount; 
                
                for (var i = 0; i <= count; i++)
                {
                    var pts = (breaks == this.horizontalPageBreaks) ?
                        [new mxPoint(Math.round(bounds2.x), Math.round(bounds2.y + (i + 1) * bounds.height)),
                         new mxPoint(Math.round(right), Math.round(bounds2.y + (i + 1) * bounds.height))] :
                        [new mxPoint(Math.round(bounds2.x + (i + 1) * bounds.width), Math.round(bounds2.y)),
                         new mxPoint(Math.round(bounds2.x + (i + 1) * bounds.width), Math.round(bottom))];
                    
                    if (breaks[i] != null)
                    {
                        breaks[i].points = pts;
                        breaks[i].redraw();
                    }
                    else
                    {
                        var pageBreak = new mxPolyline(pts, this.pageBreakColor);
                        pageBreak.dialect = this.dialect;
                        pageBreak.isDashed = this.pageBreakDashed;
                        pageBreak.pointerEvents = false;
                        pageBreak.init(this.view.backgroundPane);
                        pageBreak.redraw();
                        
                        breaks[i] = pageBreak;
                    }
                }
                
                for (var i = count; i < breaks.length; i++)
                {
                    breaks[i].destroy();
                }
                
                breaks.splice(count, breaks.length - count);
            }
        });
            
        drawPageBreaks(this.horizontalPageBreaks);
        drawPageBreaks(this.verticalPageBreaks);
    };
    
    // Disables removing relative children from parents
    var mxGraphHandlerShouldRemoveCellsFromParent = mxGraphHandler.prototype.shouldRemoveCellsFromParent;
    mxGraphHandler.prototype.shouldRemoveCellsFromParent = function(parent, cells, evt)
    {
        for (var i = 0; i < cells.length; i++)
        {
            if (this.graph.getModel().isVertex(cells[i]))
            {
                var geo = this.graph.getCellGeometry(cells[i]);
                
                if (geo != null && geo.relative)
                {
                    return false;
                }
            }
        }
        
        return mxGraphHandlerShouldRemoveCellsFromParent.apply(this, arguments);
    };

    // Overrides to ignore hotspot only for target terminal
    var mxConnectionHandlerCreateMarker = mxConnectionHandler.prototype.createMarker;
    mxConnectionHandler.prototype.createMarker = function()
    {
        var marker = mxConnectionHandlerCreateMarker.apply(this, arguments);
        
        marker.intersects = mxUtils.bind(this, function(state, evt)
        {
            if (this.isConnecting())
            {
                return true;
            }
            
            return mxCellMarker.prototype.intersects.apply(marker, arguments);
        });
        
        return marker;
    };

    // Creates background page shape
    mxGraphView.prototype.createBackgroundPageShape = function(bounds)
    {
        return new mxRectangleShape(bounds, '#ffffff', this.graph.defaultPageBorderColor);
    };

    // Fits the number of background pages to the graph
    mxGraphView.prototype.getBackgroundPageBounds = function()
    {
        var gb = this.getGraphBounds();
        
        // Computes unscaled, untranslated graph bounds
        var x = (gb.width > 0) ? gb.x / this.scale - this.translate.x : 0;
        var y = (gb.height > 0) ? gb.y / this.scale - this.translate.y : 0;
        var w = gb.width / this.scale;
        var h = gb.height / this.scale;
        
        var fmt = this.graph.pageFormat;
        var ps = this.graph.pageScale;

        var pw = fmt.width * ps;
        var ph = fmt.height * ps;

        var x0 = Math.floor(Math.min(0, x) / pw);
        var y0 = Math.floor(Math.min(0, y) / ph);
        var xe = Math.ceil(Math.max(1, x + w) / pw);
        var ye = Math.ceil(Math.max(1, y + h) / ph);
        
        var rows = xe - x0;
        var cols = ye - y0;

        var bounds = new mxRectangle(this.scale * (this.translate.x + x0 * pw), this.scale *
                (this.translate.y + y0 * ph), this.scale * rows * pw, this.scale * cols * ph);
        
        return bounds;
    };
    
    /**
     * Consumes click events for disabled menu items.
     */
    var mxPopupMenuAddItem = mxPopupMenu.prototype.addItem;
    mxPopupMenu.prototype.addItem = function(title, image, funct, parent, iconCls, enabled)
    {
        var result = mxPopupMenuAddItem.apply(this, arguments);
        
        if (enabled != null && !enabled)
        {
            mxEvent.addListener(result, 'mousedown', function(evt)
            {
                mxEvent.consume(evt);
            });
        }
        
        return result;
    };

    // Selects ancestors before descendants
    var graphHandlerGetInitialCellForEvent = mxGraphHandler.prototype.getInitialCellForEvent;
    mxGraphHandler.prototype.getInitialCellForEvent = function(me)
    {
        var model = this.graph.getModel();
        var psel = model.getParent(this.graph.getSelectionCell());
        var cell = graphHandlerGetInitialCellForEvent.apply(this, arguments);
        var parent = model.getParent(cell);
        
        if (psel == null || (psel != cell && psel != parent))
        {
            while (!this.graph.isCellSelected(cell) && !this.graph.isCellSelected(parent) &&
                model.isVertex(parent) && !this.graph.isContainer(parent))
            {
                cell = parent;
                parent = this.graph.getModel().getParent(cell);
            }
        }
        
        return cell;
    };
    
    // Selection is delayed to mouseup if ancestor is selected
    var graphHandlerIsDelayedSelection = mxGraphHandler.prototype.isDelayedSelection;
    mxGraphHandler.prototype.isDelayedSelection = function(cell, me)
    {
        var result = graphHandlerIsDelayedSelection.apply(this, arguments);
        
        if (!result)
        {
            var model = this.graph.getModel();
            var parent = model.getParent(cell);
            
            while (parent != null)
            {
                // Inconsistency for unselected parent swimlane is intended for easier moving
                // of stack layouts where the container title section is too far away
                if (this.graph.isCellSelected(parent) && model.isVertex(parent))
                {
                    result = true;
                    break;
                }
                
                parent = model.getParent(parent);
            }
        }
        
        return result;
    };
    
    // Delayed selection of parent group
    mxGraphHandler.prototype.selectDelayed = function(me)
    {
        if (!this.graph.popupMenuHandler.isPopupTrigger(me))
        {
            var cell = me.getCell();
            
            if (cell == null)
            {
                cell = this.cell;
            }

            // Selects folded cell for hit on folding icon
            var state = this.graph.view.getState(cell)
            
            if (state != null && me.isSource(state.control))
            {
                this.graph.selectCellForEvent(cell, me.getEvent());
            }
            else
            {
                var model = this.graph.getModel();
                var parent = model.getParent(cell);
                
                while (!this.graph.isCellSelected(parent) && model.isVertex(parent))
                {
                    cell = parent;
                    parent = model.getParent(cell);
                }
                
                this.graph.selectCellForEvent(cell, me.getEvent());
            }
        }
    };

    // Returns last selected ancestor
    mxPopupMenuHandler.prototype.getCellForPopupEvent = function(me)
    {
        var cell = me.getCell();
        var model = this.graph.getModel();
        var parent = model.getParent(cell);
        
        while (model.isVertex(parent) && !this.graph.isContainer(parent))
        {
            if (this.graph.isCellSelected(parent))
            {
                cell = parent;
            }
            
            parent = model.getParent(parent);
        }
        
        return cell;
    };

})();

// export { Dialog, PrintDialog, PageSetupDialog, ErrorDialog, OpenFile};

//Graph.js

// import * as mxgraph from 'mxgraph';
// import { Base64 } from 'js-base64';
// import pako from 'pako';
// import html_sanitize from 'html_sanitize'
// import { HELP } from './client'
// import Editor, { Dialog } from './Editor'
// import Sidebar from './Sidebar';


// let { 
//     mxGraph, 
//     mxGraphModel, 
//     mxGraphView, 
//     mxSvgCanvas2D, 
//     mxVmlCanvas2D,
//     mxClient, 
//     mxUtils, 
//     mxResources, 
//     mxRectangle,
//     mxConstants,
//     mxImage,
//     mxEvent,
//     mxPoint,
//     mxEdgeStyle,
//     mxVertexHandler,
//     mxGraphHandler,
//     mxEdgeHandler,
//     mxCellRenderer,
//     mxDragSource,
//     mxPopupMenu,
//     mxGuide,
//     mxConnectionHandler,
//     mxRubberband,
//     mxCellHighlight,
//     mxLayoutManager,
//     mxStackLayout,
//     mxCompactTreeLayout,
//     mxHierarchicalLayout,
//     mxCircleLayout,
//     mxFastOrganicLayout,
//     mxEventObject,
//     mxConnector,
//     mxStencil,
//     mxConstraintHandler,
//     mxShape,
//     mxEllipse,
//     mxCellState,
//     mxStyleRegistry,
//     mxCodec,
//     mxObjectIdentity,
//     mxConnectionConstraint,
//     mxValueChange,
//     mxDictionary,
//     mxCell,
//     mxGeometry,
//     mxImageExport,
//     mxPopupMenuHandler,
//     mxCellEditor,
//     mxPolyline,
//     mxCellEditorGetCurrentValue,
//     mxOutline,
//     mxPanningHandler,
//     mxElbowEdgeHandler,
//     mxImageShape,
//     mxRectangleShape,
//     mxCellEditorGetInitialValue,
// } = mxgraph();



mxGraph.prototype.pageScale = 1;
mxGraph.prototype.pageBreakColor             = '#c0c0c0';
mxGraph.prototype.pageFormat                 = new mxRectangle(0, 0, 1200, 700);
mxGraph.prototype.centerZoom                 = true;
mxGraph.prototype.autoScroll                 = true;
mxGraph.prototype.dialect                    = mxConstants.DIALECT_SVG;
mxGraph.prototype.keepSelectionVisibleOnZoom = false;
mxGraph.prototype.gridSize                   = 5;

mxGraph.prototype.collapsedImage = new mxImage('data:image/gif;base64,R0lGODlhCQAJAPcAAAAAABAICHuUrXuctYSMlISUnISUpYSUrYScrYyUnIyUpYycpZScnJScpaXG3q3G1q3G3rW1vbW9xrW9zsbGzsbO3sbW3s7Oztbe3tbe597e3t7e597n7+fn7+/v7+/3/+////f39/f//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////ywAAAAACQAJAAAIUgAdCDBQoAADAgseCADBUIRDEAYMgPggAkCIDx8QKMA4AsCIEBwKEKgIIAAAABgMMNjgwYNFDRYMEOCAQQOACxQqFFBQQUIEnz8NPIhINOKDgAAAOw==', 9, 9);
mxGraph.prototype.expandedImage  = new mxImage('data:image/gif;base64,R0lGODlhCQAJAPcAAAAAAHuUrXuctYSMlISUnISUpYSUrYScpYScrYSctYyUnIyUpZScnJScpaXG3q21va29xq3G1q3G3rW9xr3GzsbGxsbOzsbO1sbO3sbW1s7W1tbe597e3t7n597v9+fn3ufv9+fv/+f3/+/v7+/v9+/39+////f37/f39/f/////9////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////ywAAAAACQAJAAAIUwAdBChAoMGAAQQiJBBhwkSKhyYKIBCRAgSKFSk8EASRYsUJFCM0KkgBoGTJDQUYkBjB8kOHCwUGbOCgoQKHCjAXYIAwYcKDCRAKRChAlCDRCAEBADs=', 9, 9);
mxGraph.prototype.warningImage   = new mxImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAE7SURBVHjaYvz//z8DJQAggBjwGXDuHMP/tWuD/uPTCxBAOA0AaQRK/f/+XeJ/cbHlf1wGAAQQTgPu3QNLgfHSpZo4DQAIIKwGwGyH4e/fFbG6AiQJEEAs2Ew2NFzH8OOHBMO6dT/A/KCg7wxGRh+wuhQggDBcALMdFIAcHBxgDGJjcwVIIUAAYbhAUXEdVos4OO4DXcGBIQ4QQCguQPY7sgtgAYruCpAgQACx4LJdU1OCwctLEcyWlLwPJF+AXQE0EMUBAAEEdwF6yMOiD4RRY0QT7gqQAEAAseDzu6XldYYPH9DD4joQa8L5AAEENgWb7SBcXa0JDQMBrK4AcQACiAlfyOMCEFdAnAYQQEz4FLa0XGf4/v0H0IIPONUABBAjyBmMjIwMS5cK/L927QORbtBkaG29DtYLEGAAH6f7oq3Zc+kAAAAASUVORK5CYII=', 16, 16);

// Keeps edges between relative child cells inside parent
mxGraphModel.prototype.ignoreRelativeEdgeParent = false;

// Defines grid properties
mxGraphView.prototype.gridImage   = 'data:image/gif;base64,R0lGODlhCgAKAJEAAAAAAP///8zMzP///yH5BAEAAAMALAAAAAAKAAoAAAIJ1I6py+0Po2wFADs=';
mxGraphView.prototype.gridSteps   = 5;
mxGraphView.prototype.minGridSize = 1;
mxGraphView.prototype.gridColor   = '#808080';
// Alternative text for unsupported foreignObjects
mxSvgCanvas2D.prototype.foAltText = '[Not supported by viewer]';
mxVmlCanvas2D.prototype.createTransparentFill = function ()
{
    var fill = this.createVmlElement('fill');
    fill.src = mxUtils.transparentImage;
    fill.type = 'tile';
    return fill;
};


/**
 * Constructs a new graph instance. Note that the constructor does not take a
 * container because the graph instance is needed for creating the UI, which
 * in turn will create the container for the graph. Hence, the container is
 * assigned later in EditorUi.
 */
/**
 * Defines graph class.
 */
  //export default function Graph (container, model, renderHint, stylesheet, themes)
function Graph (container, model, renderHint, stylesheet, themes)
{
    mxGraph.call(this, container, model, renderHint, stylesheet);
    
    this.themes             = themes || this.defaultThemes;
    this.currentEdgeStyle   = mxUtils.clone(this.defaultEdgeStyle);
    this.currentVertexStyle = mxUtils.clone(this.defaultVertexStyle);

    // Sets the base domain URL and domain path URL for relative links.
    var b = this.baseUrl;
    var p = b.indexOf('//');
    this.domainUrl = '';
    this.domainPathUrl = '';
    
    if (p > 0)
    {
        var d = b.indexOf('/', p + 2);

        if (d > 0)
        {
            this.domainUrl = b.substring(0, d);
        }
        
        d = b.lastIndexOf('/');
        
        if (d > 0)
        {
            this.domainPathUrl = b.substring(0, d + 1);
        }
    }
    
    // Adds support for HTML labels via style. Note: Currently, only the Java
    // backend supports HTML labels but CSS support is limited to the following:
    // http://docs.oracle.com/javase/6/docs/api/index.html?javax/swing/text/html/CSS.html
    // TODO: Wrap should not affect isHtmlLabel output (should be handled later)
    this.isHtmlLabel = function(cell)
    {
        var state = this.view.getState(cell);
        var style = (state != null) ? state.style : this.getCellStyle(cell);
        
        return (style != null) ? (style['html'] == '1' || style[mxConstants.STYLE_WHITE_SPACE] == 'wrap') : false;
    };
    
    // Implements a listener for hover and click handling on edges
    if (this.edgeMode)
    {
        var start = {
            point: null,
            event: null,
            state: null,
            handle: null,
            selected: false
        };
        
        // Uses this event to process mouseDown to check the selection state before it is changed
        this.addListener(mxEvent.FIRE_MOUSE_EVENT, mxUtils.bind(this, function(sender, evt)
        {
            if (evt.getProperty('eventName') == 'mouseDown' && this.isEnabled())
            {
                var me = evt.getProperty('event');
                if (!mxEvent.isControlDown(me.getEvent()) && !mxEvent.isShiftDown(me.getEvent()))
                {
                    var state = me.getState();
        
                    if (state != null)
                    {
                        // Checks if state was removed in call to stopEditing above
                        if (this.model.isEdge(state.cell))
                        {
                            start.point = new mxPoint(me.getGraphX(), me.getGraphY());
                            start.selected = this.isCellSelected(state.cell);
                            start.state = state;
                            start.event = me;
                            
                            if (state.text != null && state.text.boundingBox != null &&
                                mxUtils.contains(state.text.boundingBox, me.getGraphX(), me.getGraphY()))
                            {
                                start.handle = mxEvent.LABEL_HANDLE;
                            }
                            else
                            {
                                var handler = this.selectionCellsHandler.getHandler(state.cell);
    
                                if (handler != null && handler.bends != null && handler.bends.length > 0)
                                {
                                    start.handle = handler.getHandleForEvent(me);
                                }
                            }
                        }
                    }
                }
            }
        }));
        
        //var mouseDown = null;
        this.addMouseListener(
        {
            mouseDown: function(sender, me) {},
            mouseMove: mxUtils.bind(this, function(sender, me)
            {
                // Checks if any other handler is active
                var handlerMap = this.selectionCellsHandler.handlers.map;
                for (var key in handlerMap)
                {
                    if (handlerMap[key].index != null)
                        return;
                }
                
                if (this.isEnabled() && !this.panningHandler.isActive() && !mxEvent.isControlDown(me.getEvent()) &&
                    !mxEvent.isShiftDown(me.getEvent()) && !mxEvent.isAltDown(me.getEvent()))
                {
                    var tol = this.tolerance;
    
                    if (start.point != null && start.state != null && start.event != null)
                    {
                        var state = start.state;
                        
                        if (Math.abs(start.point.x - me.getGraphX()) > tol || Math.abs(start.point.y - me.getGraphY()) > tol)
                        {
                            // Lazy selection for edges inside groups
                            if (!this.isCellSelected(state.cell))
                                this.setSelectionCell(state.cell);
                            
                            var handler = this.selectionCellsHandler.getHandler(state.cell);
                            if (handler != null && handler.bends != null && handler.bends.length > 0)
                            {
                                var handle = handler.getHandleForEvent(start.event);
                                var edgeStyle = this.view.getEdgeStyle(state);
                                var entity = edgeStyle == mxEdgeStyle.EntityRelation;
                                
                                // Handles special case where label was clicked on unselected edge in which
                                // case the label will be moved regardless of the handle that is returned
                                if (!start.selected && start.handle == mxEvent.LABEL_HANDLE)
                                    handle = start.handle;
                                
                                if (!entity || handle == 0 || handle == handler.bends.length - 1 || handle == mxEvent.LABEL_HANDLE)
                                {
                                    // Source or target handle or connected for direct handle access or orthogonal line
                                    // with just two points where the central handle is moved regardless of mouse position
                                    if (handle == mxEvent.LABEL_HANDLE || handle == 0 || state.visibleSourceState != null ||
                                        handle == handler.bends.length - 1 || state.visibleTargetState != null)
                                    {
                                        if (!entity && handle != mxEvent.LABEL_HANDLE)
                                        {
                                            var pts = state.absolutePoints;
                                            
                                            // Default case where handles are at corner points handles
                                            // drag of corner as drag of existing point
                                            if (pts != null && ((edgeStyle == null && handle == null) ||
                                                edgeStyle == mxEdgeStyle.OrthConnector))
                                            {
                                                // Does not use handles if they were not initially visible
                                                handle = start.handle;

                                                if (handle == null)
                                                {
                                                    var box = new mxRectangle(start.point.x, start.point.y);
                                                    box.grow(mxEdgeHandler.prototype.handleImage.width / 2);
                                                    
                                                    if (mxUtils.contains(box, pts[0].x, pts[0].y))
                                                    {
                                                        // Moves source terminal handle
                                                        handle = 0;
                                                    }
                                                    else if (mxUtils.contains(box, pts[pts.length - 1].x, pts[pts.length - 1].y))
                                                    {
                                                        // Moves target terminal handle
                                                        handle = handler.bends.length - 1;
                                                    }
                                                    else
                                                    {
                                                        // Checks if edge has no bends
                                                        var nobends = edgeStyle != null && (pts.length == 2 || (pts.length == 3 &&
                                                            ((Math.round(pts[0].x - pts[1].x) == 0 && Math.round(pts[1].x - pts[2].x) == 0) ||
                                                            (Math.round(pts[0].y - pts[1].y) == 0 && Math.round(pts[1].y - pts[2].y) == 0))));
                                                        
                                                        if (nobends)
                                                        {
                                                            // Moves central handle for straight orthogonal edges
                                                            handle = 2;
                                                        }
                                                        else
                                                        {
                                                            // Finds and moves vertical or horizontal segment
                                                            handle = mxUtils.findNearestSegment(state, start.point.x, start.point.y);
                                                            
                                                            // Converts segment to virtual handle index
                                                            if (edgeStyle == null)
                                                            {
                                                                handle = mxEvent.VIRTUAL_HANDLE - handle;
                                                            }
                                                            // Maps segment to handle
                                                            else
                                                            {
                                                                handle += 1;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            
                                            // Creates a new waypoint and starts moving it
                                            if (handle == null)
                                            {
                                                handle = mxEvent.VIRTUAL_HANDLE;
                                            }
                                        }
                                        
                                        handler.start(me.getGraphX(), me.getGraphX(), handle);
                                        start.state = null;
                                        start.event = null;
                                        start.point = null;
                                        start.handle = null;
                                        start.selected = false;
                                        me.consume();
    
                                        // Removes preview rectangle in graph handler
                                        this.graphHandler.reset();
                                    }
                                }
                                else if (entity && (state.visibleSourceState != null || state.visibleTargetState != null))
                                {
                                    // Disables moves on entity to make it consistent
                                    this.graphHandler.reset();
                                    me.consume();
                                }
                            }
                        }
                    }
                    else
                    {
                        // Updates cursor for unselected edges under the mouse
                        var state = me.getState();
                        
                        if (state != null)
                        {
                            // Checks if state was removed in call to stopEditing above
                            if (this.model.isEdge(state.cell))
                            {
                                var cursor = null;
                                var pts = state.absolutePoints;
                                
                                if (pts != null)
                                {
                                    var box = new mxRectangle(me.getGraphX(), me.getGraphY());
                                    box.grow(mxEdgeHandler.prototype.handleImage.width / 2);
                                    
                                    if (state.text != null && state.text.boundingBox != null &&
                                        mxUtils.contains(state.text.boundingBox, me.getGraphX(), me.getGraphY()))
                                    {
                                        cursor = 'move';
                                    }
                                    else if (mxUtils.contains(box, pts[0].x, pts[0].y) ||
                                        mxUtils.contains(box, pts[pts.length - 1].x, pts[pts.length - 1].y))
                                    {
                                        cursor = 'pointer';
                                    }
                                    else if (state.visibleSourceState != null || state.visibleTargetState != null)
                                    {
                                        // Moving is not allowed for entity relation but still indicate hover state
                                        var tmp = this.view.getEdgeStyle(state);
                                        cursor = 'crosshair';
                                        
                                        if (tmp != mxEdgeStyle.EntityRelation && this.isOrthogonal(state))
                                        {
                                            var idx = mxUtils.findNearestSegment(state, me.getGraphX(), me.getGraphY());
                                            
                                            if (idx < pts.length - 1 && idx >= 0)
                                            {
                                                cursor = (Math.round(pts[idx].x - pts[idx + 1].x) == 0) ?
                                                    'col-resize' : 'row-resize';
                                            }
                                        }
                                    }
                                }
                                
                                if (cursor != null)
                                {
                                    state.setCursor(cursor);
                                }
                            }
                        }
                    }
                }
            }),
            mouseUp: mxUtils.bind(this, function(sender, me)
            {
                start.state = null;
                start.event = null;
                start.point = null;
                start.handle = null;
            })
        });
    }
    
    // HTML entities are displayed as plain text in wrapped plain text labels
    this.cellRenderer.getLabelValue = function(state)
    {
        var result = mxCellRenderer.prototype.getLabelValue.apply(this, arguments);
        if (state.view.graph.isHtmlLabel(state.cell) && typeof result != "object")
        {
            if (state.style['html'] != 1)
            {
                result = mxUtils.htmlEntities(result, false);
            }
            else
            {
                result = state.view.graph.sanitizeHtml(result);
            }
        }
        
        return result;
    };

    // All code below not available and not needed in embed mode
    if (typeof mxVertexHandler !== 'undefined')
    {
        this.setConnectable(true);
        this.setDropEnabled(true);
        this.setPanning(true);
        this.setTooltips(true);
        this.setMultigraph(true);
        this.setAllowLoops(false);

        this.allowAutoPanning          = true;
        this.resetEdgesOnConnect       = false;
        this.constrainChildren         = false;
        this.constrainRelativeChildren = true;

        this.setPortsEnabled(true);
        //this.setEdgeLabelsMovable(false);
        //this.setVertexLabelsMovable(false);
        //this.setConnectableEdges(false);
        //this.setDisconnectOnMove(false);
        this.setSplitEnabled(true);
        
        // Do not scroll after moving cells
        this.graphHandler.scrollOnMove = true;
        this.graphHandler.scaleGrid    = true;

        // Disables cloning of connection sources by default
        this.connectionHandler.setCreateTarget(false);
        this.connectionHandler.insertBeforeSource = false;
        
        // Disables built-in connection starts
        this.connectionHandler.isValidSource = function(cell, me)
        {
            return false;
        };

        // Sets the style to be used when an elbow edge is double clicked
        this.alternateEdgeStyle = 'vertical';

        if (stylesheet == null)
            this.loadStylesheet();

        // Adds page centers to the guides for moving cells
        var graphHandlerGetGuideStates = this.graphHandler.getGuideStates;
        this.graphHandler.getGuideStates = function()
        {
            var result = graphHandlerGetGuideStates.apply(this, arguments);
            
            // Create virtual cell state for page centers
            if (this.graph.pageVisible)
            {
                var guides = [];
                
                var pf = this.graph.pageFormat;
                var ps = this.graph.pageScale;
                var pw = pf.width * ps;
                var ph = pf.height * ps;
                var t = this.graph.view.translate;
                var s = this.graph.view.scale;

                var layout = this.graph.getPageLayout();
                
                for (var i = 0; i < layout.width; i++)
                {
                    guides.push(new mxRectangle(((layout.x + i) * pw + t.x) * s,
                        (layout.y * ph + t.y) * s, pw * s, ph * s));
                }
                
                for (var j = 0; j < layout.height; j++)
                {
                    guides.push(new mxRectangle((layout.x * pw + t.x) * s,
                        ((layout.y + j) * ph + t.y) * s, pw * s, ph * s));
                }
                
                // Page center guides have predence over normal guides
                result = guides.concat(result);
            }
            
            return result;
        };

        // Overrides zIndex for dragElement
        mxDragSource.prototype.dragElementZIndex = mxPopupMenu.prototype.zIndex;
        
        // Overrides color for virtual guides for page centers
        mxGuide.prototype.getGuideColor = function(state, horizontal)
        {
            return (state.cell == null) ? '#ffa500' /* orange */ : mxConstants.GUIDE_COLOR;
        };

        // Changes color of move preview for black backgrounds
        this.graphHandler.createPreviewShape = function(bounds)
        {
            this.previewColor = (this.graph.background == '#000000') ? '#ffffff' : mxGraphHandler.prototype.previewColor;
            
            return mxGraphHandler.prototype.createPreviewShape.apply(this, arguments);
        };
        
        // Handles parts of cells by checking if part=1 is in the style and returning the parent
        // if the parent is not already in the list of cells. container style is used to disable
        // step into swimlanes and dropTarget style is used to disable acting as a drop target.
        // LATER: Handle recursive parts
        this.graphHandler.getCells = function(initialCell)
        {
            var cells = mxGraphHandler.prototype.getCells.apply(this, arguments);
            var newCells = [];

            for (var i = 0; i < cells.length; i++)
            {
                var state = this.graph.view.getState(cells[i]);
                var style = (state != null) ? state.style : this.graph.getCellStyle(cells[i]);
                
                if (mxUtils.getValue(style, 'part', '0') == '1')
                {
                    var parent = this.graph.model.getParent(cells[i]);
        
                    if (this.graph.model.isVertex(parent) && mxUtils.indexOf(cells, parent) < 0)
                    {
                        newCells.push(parent);
                    }
                }
                else
                {
                    newCells.push(cells[i]);
                }
            }

            return newCells;
        };

        // Handles parts of cells when cloning the source for new connections
        this.connectionHandler.createTargetVertex = function(evt, source)
        {
            var state = this.graph.view.getState(source);
            var style = (state != null) ? state.style : this.graph.getCellStyle(source);
            
            if (mxUtils.getValue(style, 'part', false))
            {
                var parent = this.graph.model.getParent(source);

                if (this.graph.model.isVertex(parent))
                {
                    source = parent;
                }
            }
            
            return mxConnectionHandler.prototype.createTargetVertex.apply(this, arguments);
        };
        
        var rubberband = new mxRubberband(this);
        this.getRubberband = function()
        {
            return rubberband;
        };
        
        // Timer-based activation of outline connect in connection handler
        var startTime = new Date().getTime();
        var timeOnTarget = 0;
        
        var connectionHandlerMouseMove = this.connectionHandler.mouseMove;
        this.connectionHandler.mouseMove = function()
        {
            var prev = this.currentState;
            connectionHandlerMouseMove.apply(this, arguments);
                
            if (prev != this.currentState)
            {
                startTime = new Date().getTime();
                timeOnTarget = 0;
            }
            else
            {
                timeOnTarget = new Date().getTime() - startTime;
            }
        };

        // Activates outline connect after 1500ms with touch event or if alt is pressed inside the shape
        // outlineConnect=0 is a custom style that means do not connect to strokes inside the shape,
        // or in other words, connect to the shape's perimeter if the highlight is under the mouse
        // (the name is because the highlight, including all strokes, is called outline in the code)
        var connectionHandleIsOutlineConnectEvent = this.connectionHandler.isOutlineConnectEvent;
        this.connectionHandler.isOutlineConnectEvent = function(me)
        {
            return (this.currentState != null && me.getState() == this.currentState && timeOnTarget > 2000) ||
                ((this.currentState == null || mxUtils.getValue(this.currentState.style, 'outlineConnect', '1') != '0') &&
                connectionHandleIsOutlineConnectEvent.apply(this, arguments));
        };
        
        // Adds shift+click to toggle selection state
        var isToggleEvent = this.isToggleEvent;
        this.isToggleEvent = function(evt)
        {
            return isToggleEvent.apply(this, arguments) || (!mxClient.IS_CHROMEOS && mxEvent.isShiftDown(evt));
        };
        
        // Workaround for Firefox where first mouse down is received
        // after tap and hold if scrollbars are visible, which means
        // start rubberband immediately if no cell is under mouse.
        var isForceRubberBandEvent = rubberband.isForceRubberbandEvent;
        rubberband.isForceRubberbandEvent = function(me)
        {
            return isForceRubberBandEvent.apply(this, arguments) ||
                (mxClient.IS_CHROMEOS && mxEvent.isShiftDown(me.getEvent())) ||
                (mxUtils.hasScrollbars(this.graph.container) && mxClient.IS_FF &&
                mxClient.IS_WIN && me.getState() == null && mxEvent.isTouchEvent(me.getEvent()));
        };
        
        // Shows hand cursor while panning
        var prevCursor = null;
        this.panningHandler.addListener(mxEvent.PAN_START, mxUtils.bind(this, function()
        {
            if (this.isEnabled())
            {
                prevCursor = this.container.style.cursor;
                this.container.style.cursor = 'move';
            }
        }));
        this.panningHandler.addListener(mxEvent.PAN_END, mxUtils.bind(this, function()
        {
            if (this.isEnabled())
            {
                this.container.style.cursor = prevCursor;
            }
        }));

        this.popupMenuHandler.autoExpand = true;
        this.popupMenuHandler.isSelectOnPopup = function(me)
        {
            return mxEvent.isMouseEvent(me.getEvent());
        };
    
        // Handles links if graph is read-only or cell is locked
        var click = this.click;
        this.click = function(me)
        {
            var locked = me.state == null && me.sourceState != null && this.isCellLocked(me.sourceState.cell);
            
            if ((!this.isEnabled() || locked) && !me.isConsumed())
            {
                var cell = (locked) ? me.sourceState.cell : me.getCell();
                
                if (cell != null)
                {
                    var link = this.getLinkForCell(cell);
                    
                    if (link != null)
                    {
                        if (this.isCustomLink(link))
                        {
                            this.customLinkClicked(link);
                        }
                        else
                        {
                            this.openLink(link);
                        }
                    }
                }
                
                if (this.isEnabled() && locked)
                {
                    this.clearSelection();
                }
            }
            else
            {
                return click.apply(this, arguments);
            }
        };

        // Redirects tooltips for locked cells
        this.tooltipHandler.getStateForEvent = function(me)
        {
            return me.sourceState;
        };
        
        // Redirects cursor for locked cells
        var getCursorForMouseEvent = this.getCursorForMouseEvent; 
        this.getCursorForMouseEvent = function(me)
        {
            var locked = me.state == null && me.sourceState != null && this.isCellLocked(me.sourceState.cell);
            return this.getCursorForCell((locked) ? me.sourceState.cell : me.getCell());
        };
        
        // Shows pointer cursor for clickable cells with links
        // ie. if the graph is disabled and cells cannot be selected
        var getCursorForCell = this.getCursorForCell;
        this.getCursorForCell = function(cell)
        {
            if (!this.isEnabled() || this.isCellLocked(cell))
            {
                var link = this.getLinkForCell(cell);
                
                if (link != null)
                {
                    return 'pointer';
                }
                else if (this.isCellLocked(cell))
                {
                    return 'default';
                }
            }

            return getCursorForCell.apply(this, arguments);
        };
        
        // Changes rubberband selection to be recursive
        this.selectRegion = function(rect, evt)
        {
            var cells = this.getAllCells(rect.x, rect.y, rect.width, rect.height);
            this.selectCellsForEvent(cells, evt);
            
            return cells;
        };
        
        // Recursive implementation for rubberband selection
        this.getAllCells = function(x, y, width, height, parent, result)
        {
            result = (result != null) ? result : [];
            
            if (width > 0 || height > 0)
            {
                var model = this.getModel();
                var right = x + width;
                var bottom = y + height;
    
                if (parent == null)
                {
                    parent = this.getCurrentRoot();
                    
                    if (parent == null)
                    {
                        parent = model.getRoot();
                    }
                }
                
                if (parent != null)
                {
                    var childCount = model.getChildCount(parent);
                    
                    for (var i = 0; i < childCount; i++)
                    {
                        var cell = model.getChildAt(parent, i);
                        var state = this.view.getState(cell);
                        
                        if (state != null && this.isCellVisible(cell) && mxUtils.getValue(state.style, 'locked', '0') != '1')
                        {
                            var deg = mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION) || 0;
                            var box = state;
                            
                            if (deg != 0)
                            {
                                box = mxUtils.getBoundingBox(box, deg);
                            }
                            
                            if ((model.isEdge(cell) || model.isVertex(cell)) &&
                                box.x >= x && box.y + box.height <= bottom &&
                                box.y >= y && box.x + box.width <= right)
                            {
                                result.push(cell);
                            }
    
                            this.getAllCells(x, y, width, height, cell, result);
                        }
                    }
                }
            }
            
            return result;
        };

        // Never removes cells from parents that are being moved
        var graphHandlerShouldRemoveCellsFromParent = this.graphHandler.shouldRemoveCellsFromParent;
        this.graphHandler.shouldRemoveCellsFromParent = function(parent, cells, evt)
        {
            if (this.graph.isCellSelected(parent))
            {
                return false;
            }
            
            return graphHandlerShouldRemoveCellsFromParent.apply(this, arguments);
        };

        // Unlocks all cells
        this.isCellLocked = function(cell)
        {
            var pState = this.view.getState(cell);
            while (pState != null)
            {
                if (mxUtils.getValue(pState.style, 'locked', '0') == '1')
                    return true;
                pState = this.view.getState(this.model.getParent(pState.cell));
            }
            return false;
        };
        
        var tapAndHoldSelection = null;
        
        // Uses this event to process mouseDown to check the selection state before it is changed
        this.addListener(mxEvent.FIRE_MOUSE_EVENT, mxUtils.bind(this, function(sender, evt)
        {
            if (evt.getProperty('eventName') == 'mouseDown')
            {
                var me = evt.getProperty('event');
                var state = me.getState();
                
                if (state != null && !this.isSelectionEmpty() && !this.isCellSelected(state.cell))
                {
                    tapAndHoldSelection = this.getSelectionCells();
                }
                else
                {
                    tapAndHoldSelection = null;
                }
            }
        }));
        
        // Tap and hold on background starts rubberband for multiple selected
        // cells the cell associated with the event is deselected
        this.addListener(mxEvent.TAP_AND_HOLD, mxUtils.bind(this, function(sender, evt)
        {
            if (!mxEvent.isMultiTouchEvent(evt))
            {
                var me = evt.getProperty('event');
                var cell = evt.getProperty('cell');
                
                if (cell == null)
                {
                    var pt = mxUtils.convertPoint(this.container,
                            mxEvent.getClientX(me), mxEvent.getClientY(me));
                    rubberband.start(pt.x, pt.y);
                }
                else if (tapAndHoldSelection != null)
                {
                    this.addSelectionCells(tapAndHoldSelection);
                }
                else if (this.getSelectionCount() > 1 && this.isCellSelected(cell))
                {
                    this.removeSelectionCell(cell);
                }
                
                // Blocks further processing of the event
                tapAndHoldSelection = null;
                evt.consume();
            }
        }));
    
        // On connect the target is selected and we clone the cell of the preview edge for insert
        this.connectionHandler.selectCells = function(edge, target)
        {
            this.graph.setSelectionCell(target || edge);
        };
        
        // Shows connection points only if cell not selected
        this.connectionHandler.constraintHandler.isStateIgnored = function(state, source)
        {
            return source && state.view.graph.isCellSelected(state.cell);
        };
        
        // Updates constraint handler if the selection changes
        this.selectionModel.addListener(mxEvent.CHANGE, mxUtils.bind(this, function()
        {
            var ch = this.connectionHandler.constraintHandler;
            
            if (ch.currentFocus != null && ch.isStateIgnored(ch.currentFocus, true))
            {
                ch.currentFocus = null;
                ch.constraints = null;
                ch.destroyIcons();
            }
            
            ch.destroyFocusHighlight();
        }));
        
        // Initializes touch interface
        if (Graph.touchStyle)
            this.initTouch();
        
        /**
         * Adds locking
         */
        var graphUpdateMouseEvent = this.updateMouseEvent;
        this.updateMouseEvent = function(me)
        {
            me = graphUpdateMouseEvent.apply(this, arguments);
            if (me.state != null && this.isCellLocked(me.getCell()))
                me.state = null;
            return me;
        };
    }
    
    // Create a unique offset object for each graph instance.
    this.currentTranslate = new mxPoint(0, 0);
};
/**
 * Specifies if the touch UI should be used (cannot detect touch in FF so always on for Windows/Linux)
 */
Graph.touchStyle = mxClient.IS_TOUCH || (mxClient.IS_FF && mxClient.IS_WIN) || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;

/**
 * Shortcut for capability check.
 */
Graph.fileSupport = window.File != null && window.FileReader != null && window.FileList != null;

/**
 * Default size for line jumps.
 */
Graph.lineJumpsEnabled = true;

/**
 * Default size for line jumps.
 */
Graph.defaultJumpSize = 8;

/**
 * Helper function for creating SVG data URI.
 */
Graph.createSvgImage = function(w, h, data)
{
    var tmp = unescape(encodeURIComponent(
        '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">' +
        '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + w + 'px" height="' + h + 'px" ' +
        'version="1.1">' + data + '</svg>'));

    return new mxImage('data:image/svg+xml;base64,' + ((window.btoa) ? btoa(tmp) : Base64.encode(tmp, true)), w, h);
};

/**
 * Removes all illegal control characters with ASCII code <32 except TAB, LF and CR.
 */
Graph.zapGremlins = function(text)
{
    var checked = [];
    for (var i = 0; i < text.length; i++)
    {
        var code = text.charCodeAt(i);
        // Removes all control chars except TAB, LF and CR
        if ((code >= 32 || code == 9 || code == 10 || code == 13) && code != 0xFFFF && code != 0xFFFE)
            checked.push(text.charAt(i));
    }
    return checked.join('');
};

/**
 * Turns the given string into an array.
 */
Graph.stringToBytes = function(str)
{
    var arr = new Array(str.length);

    for (var i = 0; i < str.length; i++)
    {
        arr[i] = str.charCodeAt(i);
    }
    
    return arr;
};

/**
 * Turns the given array into a string.
 */
Graph.bytesToString = function(arr)
{
    var result = new Array(arr.length);

    for (var i = 0; i < arr.length; i++)
    {
        result[i] = String.fromCharCode(arr[i]);
    }
    
    return result.join('');
};

/**
 * Returns a base64 encoded version of the compressed outer XML of the given node.
 */
Graph.compressNode = function(node)
{
    return Graph.compress(Graph.zapGremlins(mxUtils.getXml(node)));
};

/**
 * Returns a base64 encoded version of the compressed string.
 */
Graph.compress = function(data, deflate)
{
    if (data == null || data.length == 0 || typeof(pako) === 'undefined')
    {
        return data;
    }
    else
    {
        var tmp = (deflate) ? pako.deflate(encodeURIComponent(data), { to: 'string' }) :
            pako.deflateRaw(encodeURIComponent(data), { to: 'string' });
        return (window.btoa) ? btoa(tmp) : Base64.encode(tmp, true);
    }
};

/**
 * Returns a decompressed version of the base64 encoded string.
 */
Graph.decompress = function(data, inflate)
{
    if (data == null || data.length == 0 || typeof(pako) === 'undefined')
    {
        return data;
    }
    else
    {
        var tmp = (window.atob) ? atob(data) : Base64.decode(data, true);
        var inflated = (inflate) ? pako.inflate(tmp, { to: 'string' }) :
            pako.inflateRaw(tmp, { to: 'string' })
        return Graph.zapGremlins(decodeURIComponent(inflated));
    }
};

/**
 * Graph inherits from mxGraph.
 */
mxUtils.extend(Graph, mxGraph);

/**
 * Allows all values in fit.
 */
Graph.prototype.minFitScale = null;

/**
 * Allows all values in fit.
 */
Graph.prototype.maxFitScale = null;

/**
 * Sets the policy for links. Possible values are "self" to replace any framesets,
 * "blank" to load the URL in <linkTarget> and "auto" (default).
 */
Graph.prototype.linkPolicy = 'auto';

/**
 * Target for links that open in a new window. Default is _blank.
 */
Graph.prototype.linkTarget = '_blank';

/**
 * Value to the rel attribute of links. Default is 'nofollow noopener noreferrer'.
 * NOTE: There are security implications when this is changed and if noopener is removed,
 * then <openLink> must be overridden to allow for the opener to be set by default.
 */
Graph.prototype.linkRelation = 'nofollow noopener noreferrer';

/**
 * Scrollbars are enabled on non-touch devices (not including Firefox because touch events
 * cannot be detected in Firefox, see above).
 */
Graph.prototype.defaultScrollbars = !mxClient.IS_IOS;

/**
 * Specifies if the page should be visible for new files. Default is true.
 */
Graph.prototype.defaultPageVisible = true;

Graph.prototype.defaultPageBorderColor     = '#ffffff';
Graph.prototype.defaultPageBackgroundColor = '#ffffff';

/**
 * Specifies the size of the size for "tiles" to be used for a graph with
 * scrollbars but no visible background page. A good value is large
 * enough to reduce the number of repaints that is caused for auto-
 * translation, which depends on this value, and small enough to give
 * a small empty buffer around the graph. Default is 400x400.
 */
Graph.prototype.scrollTileSize = new mxRectangle(0, 0, 400, 400);

/**
 * Overrides the background color and paints a transparent background.
 */
Graph.prototype.transparentBackground = true;

/**
 * Sets global constants.
 */
Graph.prototype.selectParentAfterDelete = true;

/**
 * Sets the default target for all links in cells.
 */
Graph.prototype.defaultEdgeLength = 50;

/**
 * Disables move of bends/segments without selecting.
 */
Graph.prototype.edgeMode = false;

/**
 * Allows all values in fit.
 */
Graph.prototype.connectionArrowsEnabled = true;

/**
 * Specifies the regular expression for matching placeholders.
 */
Graph.prototype.placeholderPattern = new RegExp('%(date\{.*\}|[^%^\{^\}]+)%', 'g');

/**
 * Specifies the regular expression for matching placeholders.
 */
Graph.prototype.absoluteUrlPattern = new RegExp('^(?:[a-z]+:)?//', 'i');

/**
 * Specifies the default name for the theme. Default is 'default'.
 */
Graph.prototype.defaultThemeName = 'default';

/**
 * Specifies the default name for the theme. Default is 'default'.
 */
Graph.prototype.defaultThemes = {};

/**
 * Base URL for relative links.
 */
Graph.prototype.baseUrl = ((window != window.top) ? document.referrer : document.location.toString()).split('#')[0];

/**
 * Specifies if the label should be edited after an insert.
 */
Graph.prototype.editAfterInsert = false;

/**
 * Defines the built-in properties to be ignored in tooltips.
 */
Graph.prototype.builtInProperties = ['label', 'tooltip', 'placeholders', 'placeholder'];

/**
 * Installs child layout styles.
 */
Graph.prototype.init = function(container)
{
    mxGraph.prototype.init.apply(this, arguments);

    // Intercepts links with no target attribute and opens in new window
    this.cellRenderer.initializeLabel = function(state, shape)
    {
        mxCellRenderer.prototype.initializeLabel.apply(this, arguments);
        
        // Checks tolerance for clicks on links
        var tol = state.view.graph.tolerance;
        var handleClick = true;
        var first = null;
        
        var down = mxUtils.bind(this, function(evt)
        {
            handleClick = true;
            first = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt));
        });
        var move = mxUtils.bind(this, function(evt)
        {
            handleClick = handleClick && first != null &&
                Math.abs(first.x - mxEvent.getClientX(evt)) < tol &&
                Math.abs(first.y - mxEvent.getClientY(evt)) < tol;
        });
        var up = mxUtils.bind(this, function(evt)
        {
            if (handleClick)
            {
                var elt = mxEvent.getSource(evt);
                while (elt != null && elt != shape.node)
                {
                    if (elt.nodeName.toLowerCase() == 'a')
                    {
                        state.view.graph.labelLinkClicked(state, elt, evt);
                        break;
                    }
                    elt = elt.parentNode;
                }
            }
        });
        
        mxEvent.addGestureListeners(shape.node, down, move, up);
        mxEvent.addListener(shape.node, 'click', function(evt)
        {
            mxEvent.consume(evt);
        });
    };
    
    this.initLayoutManager();
};

/**
 * Implements zoom and offset via CSS transforms. This is currently only used
 * in read-only as there are fewer issues with the mxCellState not being scaled
 * and translated.
 * 
 * KNOWN ISSUES TO FIX:
 * - Apply CSS transforms to HTML labels in IE11
 */
(function()
{
    /**
     * Uses CSS transforms for scale and translate.
     */
    Graph.prototype.useCssTransforms = false;

    /**
     * Contains the scale.
     */
    Graph.prototype.currentScale = 1;

    /**
     * Contains the offset.
     */
    Graph.prototype.currentTranslate = new mxPoint(0, 0);

    /**
     * Only foreignObject supported for now (no IE11).
     */
    Graph.prototype.isCssTransformsSupported = function()
    {
        return this.dialect == mxConstants.DIALECT_SVG && !mxClient.NO_FO;
    };

    /**
     * Function: getCellAt
     * 
     * Needs to modify original method for recursive call.
     */
    Graph.prototype.getCellAt = function(x, y, parent, vertices, edges, ignoreFn)
    {
        if (this.useCssTransforms)
        {
            x = x / this.currentScale - this.currentTranslate.x;
            y = y / this.currentScale - this.currentTranslate.y;
        }
        
        return this.getScaledCellAt.apply(this, arguments);
    };

    /**
     * Function: getScaledCellAt
     * 
     * Overridden for recursion.
     */
    Graph.prototype.getScaledCellAt = function(x, y, parent, vertices, edges, ignoreFn)
    {
        vertices = (vertices != null) ? vertices : true;
        edges = (edges != null) ? edges : true;

        if (parent == null)
        {
            parent = this.getCurrentRoot();
            if (parent == null)
                parent = this.getModel().getRoot();
        }

        if (parent != null)
        {
            var childCount = this.model.getChildCount(parent);
            for (var i = childCount - 1; i >= 0; i--)
            {
                var cell = this.model.getChildAt(parent, i);
                var result = this.getScaledCellAt(x, y, cell, vertices, edges, ignoreFn);
                
                if (result != null)
                    return result;
                else if (this.isCellVisible(cell) && (edges && this.model.isEdge(cell) ||
                    vertices && this.model.isVertex(cell)))
                {
                    var state = this.view.getState(cell);

                    if (state != null && (ignoreFn == null || !ignoreFn(state, x, y)) &&
                        this.intersects(state, x, y))
                    {
                        return cell;
                    }
                }
            }
        }
        return null;
    };


    /**
     * Function: repaint
     * 
     * Updates the highlight after a change of the model or view.
     */
    mxCellHighlight.prototype.getStrokeWidth = function(state)
    {
        var s = this.strokeWidth;
        if (this.graph.useCssTransforms)
        {
            s /= this.graph.currentScale;
        }

        return s;
    };

    /**
     * Function: getGraphBounds
     * 
     * Overrides getGraphBounds to use bounding box from SVG.
     */
    mxGraphView.prototype.getGraphBounds = function()
    {
        var b = this.graphBounds;
        
        if (this.graph.useCssTransforms)
        {
            var t = this.graph.currentTranslate;
            var s = this.graph.currentScale;

            b = new mxRectangle(
                (b.x + t.x) * s, (b.y + t.y) * s,
                b.width * s, b.height * s);
        }

        return b;
    };
    
    /**
     * Function: viewStateChanged
     * 
     * Overrides to bypass full cell tree validation.
     * TODO: Check if this improves performance
     */
    mxGraphView.prototype.viewStateChanged = function()
    {
        if (this.graph.useCssTransforms)
        {
            this.validate();
            this.graph.sizeDidChange();
        }
        else
        {
            this.revalidate();
            this.graph.sizeDidChange();
        }
    };

    /**
     * Overrides validate to normalize validation view state and pass current state to CSS transform.
     */
    var graphViewValidate = mxGraphView.prototype.validate;
    mxGraphView.prototype.validate = function(cell)
    {
        if (this.graph.useCssTransforms)
        {
            this.graph.currentScale = this.scale;
            this.graph.currentTranslate.x = this.translate.x;
            this.graph.currentTranslate.y = this.translate.y;
            
            this.scale = 1;
            this.translate.x = 0;
            this.translate.y = 0;
        }
        
        graphViewValidate.apply(this, arguments);

        if (this.graph.useCssTransforms)
        {
            this.graph.updateCssTransform();
            
            this.scale = this.graph.currentScale;
            this.translate.x = this.graph.currentTranslate.x;
            this.translate.y = this.graph.currentTranslate.y;
        }
    };

    /**
     * Zooms out of the graph by <zoomFactor>.
     */
    Graph.prototype.updateCssTransform = function()
    {
        var temp = this.view.getDrawPane();
        
        if (temp != null)
        {
            var g = temp.parentNode;
            
            if (!this.useCssTransforms)
            {
                g.removeAttribute('transformOrigin');
                g.removeAttribute('transform');
            }
            else
            {
                var prev = g.getAttribute('transform');
                g.setAttribute('transformOrigin', '0 0');
                var s = Math.round(this.currentScale * 100) / 100;
                var dx = Math.round(this.currentTranslate.x * 100) / 100;
                var dy = Math.round(this.currentTranslate.y * 100) / 100;
                g.setAttribute('transform', 'scale(' + s + ',' + s + ')' + 'translate(' + dx + ',' + dy + ')');

                // Applies workarounds only if translate has changed
                if (prev != g.getAttribute('transform'))
                {
                    try
                    {
                        // Applies transform to labels outside of the SVG DOM
                        // Excluded via isCssTransformsSupported
    //					if (mxClient.NO_FO)
    //					{
    //						var transform = 'scale(' + this.currentScale + ')' + 'translate(' +
    //							this.currentTranslate.x + 'px,' + this.currentTranslate.y + 'px)';
    //							
    //						this.view.states.visit(mxUtils.bind(this, function(cell, state)
    //						{
    //							if (state.text != null && state.text.node != null)
    //							{
    //								// Stores initial CSS transform that is used for the label alignment
    //								if (state.text.originalTransform == null)
    //								{
    //									state.text.originalTransform = state.text.node.style.transform;
    //								}
    //								
    //								state.text.node.style.transform = transform + state.text.originalTransform;
    //							}
    //						}));
    //					}
                        // Workaround for https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/4320441/
                        if (mxClient.IS_EDGE)
                        {
                            // Recommended workaround is to do this on all foreignObjects, but this seems to be faster
                            var val = g.style.display;
                            g.style.display = 'none';
                            g.getBBox();
                            g.style.display = val;
                        }
                    }
                    catch (e)
                    {
                        // ignore
                    }
                }
            }
        }
    };
    
    var graphViewValidateBackgroundPage = mxGraphView.prototype.validateBackgroundPage;
    mxGraphView.prototype.validateBackgroundPage = function()
    {
        var useCssTranforms = this.graph.useCssTransforms, scale = this.scale, 
            translate = this.translate;
        
        if (useCssTranforms)
        {
            this.scale = this.graph.currentScale;
            this.translate = this.graph.currentTranslate;
        }
        
        graphViewValidateBackgroundPage.apply(this, arguments);
        
        if (useCssTranforms)
        {
            this.scale = scale;
            this.translate = translate;
        }
    };

    var graphUpdatePageBreaks = mxGraph.prototype.updatePageBreaks;
    mxGraph.prototype.updatePageBreaks = function(visible, width, height)
    {
        var useCssTranforms = this.useCssTransforms,
            scale = this.view.scale, 
            translate = this.view.translate;
    
        if (useCssTranforms)
        {
            this.view.scale = 1;
            this.view.translate = new mxPoint(0, 0);
            this.useCssTransforms = false;
        }
        
        graphUpdatePageBreaks.apply(this, arguments);
        
        if (useCssTranforms)
        {
            this.view.scale = scale;
            this.view.translate = translate;
            this.useCssTransforms = true;
        }
    };

    var graphIsSwimlane = mxGraph.prototype.isSwimlane;
    mxGraph.prototype.isSwimlane = function (cell)
    {
        if (cell != null)
        {
            var state = this.view.getState(cell);
            var style = (state != null) ? state.style : this.getCellStyle(cell);
            if (style != null && !this.model.isEdge(cell))
                return style[mxConstants.STYLE_SHAPE] == 'table' || graphIsSwimlane.apply(this, arguments);
        }
        return false;
    };

    mxGraph.prototype.isCellSelectable = function (cell)
    {
        var state = this.view.getState(cell);
        var style = (state != null) ? state.style : this.getCellStyle(cell);
        return this.isCellsSelectable() && !this.isCellLocked(cell) && style['selectable'] != 0;
    };

    //mxGraph.prototype.isPort = function (cell)
    //{
    //    var geo = this.getCellGeometry(cell);
    //    return (geo != null) ? geo.relative : false;
    //};
})();

Graph.prototype.labelLinkClicked = function(state, elt, evt)
{
    var href = elt.getAttribute('href');
    if (href != null && !this.isCustomLink(href) && (mxEvent.isLeftMouseButton(evt) && !mxEvent.isPopupTrigger(evt)) || mxEvent.isTouchEvent(evt))
    {
        if (!this.isEnabled() || this.isCellLocked(state.cell))
        {
            var target = this.isBlankLink(href) ? this.linkTarget : '_top';
            this.openLink(this.getAbsoluteUrl(href), target);
        }
        mxEvent.consume(evt);
    }
};
Graph.prototype.openLink = function(href, target, allowOpener)
{
    var result = window;
    
    try
    {
        // Workaround for blocking in same iframe
        if (target == '_self' && window != window.top)
        {
            window.location.href = href;
        }
        else
        {
            // Avoids page reload for anchors (workaround for IE but used everywhere)
            if (href.substring(0, this.baseUrl.length) == this.baseUrl && href.charAt(this.baseUrl.length) == '#' && target == '_top' && window == window.top)
            {
                var hash = href.split('#')[1];
    
                // Forces navigation if on same hash
                if (window.location.hash == '#' + hash)
                    window.location.hash = '';

                window.location.hash = hash;
            }
            else
            {
                result = window.open(href, target);
                if (result != null && !allowOpener)
                    result.opener = null;
            }
        }
    }
    catch (e)
    {
        // ignores permission denied
    }
    
    return result;
};
Graph.prototype.getLinkTitle = function(href)
{
    return href.substring(href.lastIndexOf('/') + 1);
};
Graph.prototype.isCustomLink = function(href)
{
    return href.substring(0, 5) == 'data:';
};
Graph.prototype.customLinkClicked = function(link)
{
    return false;
};

/**
 * Returns true if the fiven href references an external protocol that
 * should never open in a new window. Default returns true for mailto.
 */
Graph.prototype.isExternalProtocol = function(href)
{
    return href.substring(0, 7) === 'mailto:';
};

/**
 * Hook for links to open in same window. Default returns true for anchors,
 * links to same domain or if target == 'self' in the config.
 */
Graph.prototype.isBlankLink = function(href)
{
    return !this.isExternalProtocol(href) &&
        (this.linkPolicy === 'blank' ||
            (this.linkPolicy !== 'self' && !this.isRelativeUrl(href) && href.substring(0, this.domainUrl.length) !== this.domainUrl));
};
Graph.prototype.isRelativeUrl = function(url)
{
    return url != null && !this.absoluteUrlPattern.test(url) &&
        url.substring(0, 5) !== 'data:' &&
        !this.isExternalProtocol(url);
};
Graph.prototype.getAbsoluteUrl = function(url)
{
    if (url != null && this.isRelativeUrl(url))
    {
        if (url.charAt(0) == '#')
        {
            url = this.baseUrl + url;
        }
        else if (url.charAt(0) == '/')
        {
            url = this.domainUrl + url;
        }
        else
        {
            url = this.domainPathUrl + url;
        }
    }
    
    return url;
};

/**
 * Installs automatic layout via styles
 */
Graph.prototype.initLayoutManager = function()
{
    this.layoutManager = new mxLayoutManager(this);

    this.layoutManager.getLayout = function(cell)
    {
        // Workaround for possible invalid style after change and before view validation
        var style = this.graph.getCellStyle(cell);
        
        if (style != null)
        {
            if (style['childLayout'] == 'stackLayout')
            {
                var stackLayout = new mxStackLayout(this.graph, true);
                stackLayout.resizeParentMax = mxUtils.getValue(style, 'resizeParentMax', '1') == '1';
                stackLayout.horizontal = mxUtils.getValue(style, 'horizontalStack', '1') == '1';
                stackLayout.resizeParent = mxUtils.getValue(style, 'resizeParent', '1') == '1';
                stackLayout.resizeLast = mxUtils.getValue(style, 'resizeLast', '0') == '1';
                stackLayout.spacing = style['stackSpacing'] || stackLayout.spacing;
                stackLayout.border = style['stackBorder'] || stackLayout.border;
                stackLayout.marginLeft = style['marginLeft'] || 0;
                stackLayout.marginRight = style['marginRight'] || 0;
                stackLayout.marginTop = style['marginTop'] || 0;
                stackLayout.marginBottom = style['marginBottom'] || 0;
                stackLayout.fill = true;
                
                return stackLayout;
            }
            else if (style['childLayout'] == 'treeLayout')
            {
                var treeLayout = new mxCompactTreeLayout(this.graph);
                treeLayout.horizontal = mxUtils.getValue(style, 'horizontalTree', '1') == '1';
                treeLayout.resizeParent = mxUtils.getValue(style, 'resizeParent', '1') == '1';
                treeLayout.groupPadding = mxUtils.getValue(style, 'parentPadding', 20);
                treeLayout.levelDistance = mxUtils.getValue(style, 'treeLevelDistance', 30);
                treeLayout.maintainParentLocation = true;
                treeLayout.edgeRouting = false;
                treeLayout.resetEdges = false;
                
                return treeLayout;
            }
            else if (style['childLayout'] == 'flowLayout')
            {
                var flowLayout = new mxHierarchicalLayout(this.graph, mxUtils.getValue(style,
                        'flowOrientation', mxConstants.DIRECTION_EAST));
                flowLayout.resizeParent = mxUtils.getValue(style, 'resizeParent', '1') == '1';
                flowLayout.parentBorder = mxUtils.getValue(style, 'parentPadding', 20);
                flowLayout.maintainParentLocation = true;
                
                // Special undocumented styles for changing the hierarchical
                flowLayout.intraCellSpacing = mxUtils.getValue(style, 'intraCellSpacing', mxHierarchicalLayout.prototype.intraCellSpacing);
                flowLayout.interRankCellSpacing = mxUtils.getValue(style, 'interRankCellSpacing', mxHierarchicalLayout.prototype.interRankCellSpacing);
                flowLayout.interHierarchySpacing = mxUtils.getValue(style, 'interHierarchySpacing', mxHierarchicalLayout.prototype.interHierarchySpacing);
                flowLayout.parallelEdgeSpacing = mxUtils.getValue(style, 'parallelEdgeSpacing', mxHierarchicalLayout.prototype.parallelEdgeSpacing);
                
                return flowLayout;
            }
            else if (style['childLayout'] == 'circleLayout')
            {
                return new mxCircleLayout(this.graph);
            }
            else if (style['childLayout'] == 'organicLayout')
            {
                return new mxFastOrganicLayout(this.graph);
            }
        }
        
        return null;
    };
};

/**
 * Returns the size of the page format scaled with the page size.
 */
Graph.prototype.getPageSize = function()
{
    return (this.pageVisible) ? new mxRectangle(0, 0, this.pageFormat.width * this.pageScale,
            this.pageFormat.height * this.pageScale) : this.scrollTileSize;
};

/**
 * Returns a rectangle describing the position and count of the
 * background pages, where x and y are the position of the top,
 * left page and width and height are the vertical and horizontal
 * page count.
 */
Graph.prototype.getPageLayout = function()
{
    var size = this.getPageSize();
    var bounds = this.getGraphBounds();

    if (bounds.width == 0 || bounds.height == 0)
    {
        return new mxRectangle(0, 0, 1, 1);
    }
    else
    {
        // Computes untransformed graph bounds
        var x = Math.ceil(bounds.x / this.view.scale - this.view.translate.x);
        var y = Math.ceil(bounds.y / this.view.scale - this.view.translate.y);
        var w = Math.floor(bounds.width / this.view.scale);
        var h = Math.floor(bounds.height / this.view.scale);
        
        var x0 = Math.floor(x / size.width);
        var y0 = Math.floor(y / size.height);
        var w0 = Math.ceil((x + w) / size.width) - x0;
        var h0 = Math.ceil((y + h) / size.height) - y0;
        
        return new mxRectangle(x0, y0, w0, h0);
    }
};

/**
 * Sanitizes the given HTML markup.
 */
Graph.prototype.sanitizeHtml = function(value, editing)
{
    // Uses https://code.google.com/p/google-caja/wiki/JsHtmlSanitizer
    // NOTE: Original minimized sanitizer was modified to support
    // data URIs for images, mailto and special data:-links.
    // LATER: Add MathML to whitelisted tags
    function urlX(link)
    {
        if (link != null && link.toString().toLowerCase().substring(0, 11) !== 'javascript:')
        {
            return link;
        }
        
        return null;
    };
    function idX(id) { return id };
    console.log(html_sanitize)
    return html_sanitize(value, urlX, idX);
};

/**
 * Revalidates all cells with placeholders in the current graph model.
 */
Graph.prototype.updatePlaceholders = function()
{
    var model = this.model;
    var validate = false;
    
    for (var key in this.model.cells)
    {
        var cell = this.model.cells[key];
        
        if (this.isReplacePlaceholders(cell))
        {
            this.view.invalidate(cell, false, false);
            validate = true;
        }
    }
    
    if (validate)
    {
        this.view.validate();
    }
};

/**
 * Adds support for placeholders in labels.
 */
Graph.prototype.isReplacePlaceholders = function(cell)
{
    return cell.value != null && typeof(cell.value) == 'object' &&
        cell.value.getAttribute('placeholders') == '1';
};

/**
 * Returns true if the given mouse wheel event should be used for zooming. This
 * is invoked if no dialogs are showing and returns true with Alt or Control
 * (except macOS) is pressed.
 */
Graph.prototype.isZoomWheelEvent = function(evt)
{
    return mxEvent.isAltDown(evt) || (mxEvent.isMetaDown(evt) && mxClient.IS_MAC) ||
        (mxEvent.isControlDown(evt) && !mxClient.IS_MAC);
};

/**
 * Adds Alt+click to select cells behind cells (Shift+Click on Chrome OS).
 */
Graph.prototype.isTransparentClickEvent = function(evt)
{
    return mxEvent.isAltDown(evt) || (mxClient.IS_CHROMEOS && mxEvent.isShiftDown(evt));
};

/**
 * Adds ctrl+shift+connect to disable connections.
 */
Graph.prototype.isIgnoreTerminalEvent = function(evt)
{
    return mxEvent.isShiftDown(evt) && mxEvent.isControlDown(evt);
};

/**
 * Adds support for placeholders in labels.
 */
Graph.prototype.isSplitTarget = function(target, cells, evt)
{
    return !this.model.isEdge(cells[0]) &&
        !mxEvent.isAltDown(evt) && !mxEvent.isShiftDown(evt) &&
        mxGraph.prototype.isSplitTarget.apply(this, arguments);
};

/**
 * Adds support for placeholders in labels.
 */
Graph.prototype.getLabel = function(cell)
{
    var result = mxGraph.prototype.getLabel.apply(this, arguments);
    if (result != null && this.isReplacePlaceholders(cell) && cell.getAttribute('placeholder') == null)
        result = this.replacePlaceholders(cell, result);
    return result;
};

/**
 * Adds labelMovable style.
 */
Graph.prototype.isLabelMovable = function(cell)
{
    var state = this.view.getState(cell);
    var style = (state != null) ? state.style : this.getCellStyle(cell);
    
    return !this.isCellLocked(cell) &&
        ((this.model.isEdge(cell) && this.edgeLabelsMovable) ||
        (this.model.isVertex(cell) && (this.vertexLabelsMovable ||
        mxUtils.getValue(style, 'labelMovable', '0') == '1')));
};

/**
 * Adds event if grid size is changed.
 */
Graph.prototype.setGridSize = function(value)
{
    this.gridSize = value;
    this.fireEvent(new mxEventObject('gridSizeChanged'));
};

/**
 * Private helper method.
 */
Graph.prototype.getGlobalVariable = function(name)
{
    var val = null;
    
    if (name == 'date')
    {
        val = new Date().toLocaleDateString();
    }
    else if (name == 'time')
    {
        val = new Date().toLocaleTimeString();
    }
    else if (name == 'timestamp')
    {
        val = new Date().toLocaleString();
    }
    else if (name.substring(0, 5) == 'date{')
    {
        var fmt = name.substring(5, name.length - 1);
        val = this.formatDate(new Date(), fmt);
    }

    return val;
};

/**
 * Formats a date, see http://blog.stevenlevithan.com/archives/date-time-format
 */
Graph.prototype.formatDate = function(date, mask, utc)
{
    // LATER: Cache regexs
    if (this.dateFormatCache == null)
    {
        this.dateFormatCache = {
            i18n: {
                dayNames: [
                    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat",
                    "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
                ],
                monthNames: [
                    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
                    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
                ]
            },
            
            masks: {
                "default":      "ddd mmm dd yyyy HH:MM:ss",
                shortDate:      "m/d/yy",
                mediumDate:     "mmm d, yyyy",
                longDate:       "mmmm d, yyyy",
                fullDate:       "dddd, mmmm d, yyyy",
                shortTime:      "h:MM TT",
                mediumTime:     "h:MM:ss TT",
                longTime:       "h:MM:ss TT Z",
                isoDate:        "yyyy-mm-dd",
                isoTime:        "HH:MM:ss",
                isoDateTime:    "yyyy-mm-dd'T'HH:MM:ss",
                isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
            }
        };
    }
    
    var dF = this.dateFormatCache;
    var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
        timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        timezoneClip = /[^-+\dA-Z]/g,
        pad = function (val, len) {
            val = String(val);
            len = len || 2;
            while (val.length < len) val = "0" + val;
            return val;
        };

    // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
    if (arguments.length == 1 && Object.prototype.toString.call(date) == "[object String]" && !/\d/.test(date)) {
        mask = date;
        date = undefined;
    }

    // Passing date through Date applies Date.parse, if necessary
    date = date ? new Date(date) : new Date;
    if (isNaN(date)) throw SyntaxError("invalid date");

    mask = String(dF.masks[mask] || mask || dF.masks["default"]);

    // Allow setting the utc argument via the mask
    if (mask.slice(0, 4) == "UTC:") {
        mask = mask.slice(4);
        utc = true;
    }

    var _ = utc ? "getUTC" : "get",
        d = date[_ + "Date"](),
        D = date[_ + "Day"](),
        m = date[_ + "Month"](),
        y = date[_ + "FullYear"](),
        H = date[_ + "Hours"](),
        M = date[_ + "Minutes"](),
        s = date[_ + "Seconds"](),
        L = date[_ + "Milliseconds"](),
        o = utc ? 0 : date.getTimezoneOffset(),
        flags = {
            d:    d,
            dd:   pad(d),
            ddd:  dF.i18n.dayNames[D],
            dddd: dF.i18n.dayNames[D + 7],
            m:    m + 1,
            mm:   pad(m + 1),
            mmm:  dF.i18n.monthNames[m],
            mmmm: dF.i18n.monthNames[m + 12],
            yy:   String(y).slice(2),
            yyyy: y,
            h:    H % 12 || 12,
            hh:   pad(H % 12 || 12),
            H:    H,
            HH:   pad(H),
            M:    M,
            MM:   pad(M),
            s:    s,
            ss:   pad(s),
            l:    pad(L, 3),
            L:    pad(L > 99 ? Math.round(L / 10) : L),
            t:    H < 12 ? "a"  : "p",
            tt:   H < 12 ? "am" : "pm",
            T:    H < 12 ? "A"  : "P",
            TT:   H < 12 ? "AM" : "PM",
            Z:    utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, ""),
            o:    (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
            S:    ["th", "st", "nd", "rd"][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
        };

    return mask.replace(token, function ($0)
    {
        return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
    });
};

/**
 * 
 */
Graph.prototype.createLayersDialog = function()
{
    var div = document.createElement('div');
    div.style.position = 'absolute';
    
    var model = this.getModel();
    var childCount = model.getChildCount(model.root);
    
    for (var i = 0; i < childCount; i++)
    {
        (mxUtils.bind(this, function(layer)
        {
            var span = document.createElement('div');
            span.style.overflow = 'hidden';
            span.style.textOverflow = 'ellipsis';
            span.style.padding = '2px';
            span.style.whiteSpace = 'nowrap';

            var cb = document.createElement('input');
            cb.style.display = 'inline-block';
            cb.setAttribute('type', 'checkbox');
            
            if (model.isVisible(layer))
            {
                cb.setAttribute('checked', 'checked');
                cb.defaultChecked = true;
            }
            
            span.appendChild(cb);
            
            var title = this.convertValueToString(layer) || (mxResources.get('background') || 'Background');
            span.setAttribute('title', title);
            mxUtils.write(span, title);
            div.appendChild(span);
            
            mxEvent.addListener(cb, 'click', function()
            {
                if (cb.getAttribute('checked') != null)
                {
                    cb.removeAttribute('checked');
                }
                else
                {
                    cb.setAttribute('checked', 'checked');
                }
                
                model.setVisible(layer, cb.checked);
            });
        })(model.getChildAt(model.root, i)));
    }
    
    return div;
};

/**
 * Private helper method.
 */
Graph.prototype.replacePlaceholders = function(cell, str)
{
    //--->fix<---//
    // var result = [];
    
    // if (str != null)
    // {
    //     var last = 0;
        
    //     while (match = this.placeholderPattern.exec(str))
    //     {
    //         var val = match[0];
            
    //         if (val.length > 2 && val != '%label%' && val != '%tooltip%')
    //         {
    //             var tmp = null;
    
    //             if (match.index > last && str.charAt(match.index - 1) == '%')
    //             {
    //                 tmp = val.substring(1);
    //             }
    //             else
    //             {
    //                 var name = val.substring(1, val.length - 1);
                    
    //                 // Workaround for invalid char for getting attribute in older versions of IE
    //                 if (name.indexOf('{') < 0)
    //                 {
    //                     var current = cell;
                        
    //                     while (tmp == null && current != null)
    //                     {
    //                         if (current.value != null && typeof(current.value) == 'object')
    //                         {
    //                             tmp = (current.hasAttribute(name)) ? ((current.getAttribute(name) != null) ?
    //                                     current.getAttribute(name) : '') : null;
    //                         }
                            
    //                         current = this.model.getParent(current);
    //                     }
    //                 }
                    
    //                 if (tmp == null)
    //                 {
    //                     tmp = this.getGlobalVariable(name);
    //                 }
    //             }
    
    //             result.push(str.substring(last, match.index) + ((tmp != null) ? tmp : val));
    //             last = match.index + val.length;
    //         }
    //     }
        
    //     result.push(str.substring(last));
    // }

    // return result.join('');
    //--->fix<----//
};

/**
 * Resolves the given cells in the model and selects them.
 */
Graph.prototype.restoreSelection = function(cells)
{
    if (cells != null && cells.length > 0)
    {
        var temp = [];

        for (var i = 0; i < cells.length; i++)
        {
            var newCell = this.model.getCell(cells[i].id);

            if (newCell != null)
            {
                temp.push(newCell);
            }
        }

        this.setSelectionCells(temp);
    }
    else
    {
        this.clearSelection();
    }
};

/**
 * Selects cells for connect vertex return value.
 */
Graph.prototype.selectCellsForConnectVertex = function(cells, evt, hoverIcons)
{
    // Selects only target vertex if one exists
    if (cells.length == 2 && this.model.isVertex(cells[1]))
    {
        this.setSelectionCell(cells[1]);
        
        if (hoverIcons != null)
        {
            // Adds hover icons to new target vertex for touch devices
            if (mxEvent.isTouchEvent(evt))
            {
                hoverIcons.update(hoverIcons.getState(this.view.getState(cells[1])));
            }
            else
            {
                // Hides hover icons after click with mouse
                hoverIcons.reset();
            }
        }
        
        this.scrollCellToVisible(cells[1]);
    }
    else
    {
        this.setSelectionCells(cells);
    }
};

/**
 * Adds a connection to the given vertex.
 */
Graph.prototype.connectVertex = function(source, direction, length, evt, forceClone, ignoreCellAt)
{
    // Ignores relative edge labels
    if (source.geometry.relative && this.model.isEdge(source.parent))
        return [];
    
    ignoreCellAt = (ignoreCellAt) ? ignoreCellAt : false;
    
    var pt = (source.geometry.relative && source.parent.geometry != null) ?
            new mxPoint(source.parent.geometry.width * source.geometry.x, source.parent.geometry.height * source.geometry.y) :
            new mxPoint(source.geometry.x, source.geometry.y);
        
    if (direction == mxConstants.DIRECTION_NORTH)
    {
        pt.x += source.geometry.width / 2;
        pt.y -= length ;
    }
    else if (direction == mxConstants.DIRECTION_SOUTH)
    {
        pt.x += source.geometry.width / 2;
        pt.y += source.geometry.height + length;
    }
    else if (direction == mxConstants.DIRECTION_WEST)
    {
        pt.x -= length;
        pt.y += source.geometry.height / 2;
    }
    else
    {
        pt.x += source.geometry.width + length;
        pt.y += source.geometry.height / 2;
    }

    var parentState = this.view.getState(this.model.getParent(source));
    var s = this.view.scale;
    var t = this.view.translate;
    var dx = t.x * s;
    var dy = t.y * s;
    
    if (parentState != null && this.model.isVertex(parentState.cell))
    {
        dx = parentState.x;
        dy = parentState.y;
    }

    // Workaround for relative child cells
    if (this.model.isVertex(source.parent) && source.geometry.relative)
    {
        pt.x += source.parent.geometry.x;
        pt.y += source.parent.geometry.y;
    }
    
    // Checks actual end point of edge for target cell
    var target = (ignoreCellAt || (mxEvent.isControlDown(evt) && !forceClone)) ?
        null : this.getCellAt(dx + pt.x * s, dy + pt.y * s);
    
    if (this.model.isAncestor(target, source))
        target = null;
    
    // Checks if target or ancestor is locked
    var temp = target;
    
    while (temp != null)
    {
        if (this.isCellLocked(temp))
        {
            target = null;
            break;
        }
        
        temp = this.model.getParent(temp);
    }
    
    // Checks if source and target intersect
    if (target != null)
    {
        var sourceState = this.view.getState(source);
        var targetState = this.view.getState(target);
        
        if (sourceState != null && targetState != null && mxUtils.intersects(sourceState, targetState))
        {
            target = null;
        }
    }
    
    var duplicate = !mxEvent.isShiftDown(evt) || forceClone;
    
    if (duplicate)
    {
        if (direction == mxConstants.DIRECTION_NORTH)
        {
            pt.y -= source.geometry.height / 2;
        }
        else if (direction == mxConstants.DIRECTION_SOUTH)
        {
            pt.y += source.geometry.height / 2;
        }
        else if (direction == mxConstants.DIRECTION_WEST)
        {
            pt.x -= source.geometry.width / 2;
        }
        else
        {
            pt.x += source.geometry.width / 2;
        }
    }

    // Uses connectable parent vertex if one exists
    if (target != null && !this.isCellConnectable(target))
    {
        var parent = this.getModel().getParent(target);
        
        if (this.getModel().isVertex(parent) && this.isCellConnectable(parent))
        {
            target = parent;
        }
    }
    
    if (target == source || this.model.isEdge(target) || !this.isCellConnectable(target))
    {
        target = null;
    }
    
    var result = [];
    
    this.model.beginUpdate();

    try
    {
        var realTarget = target;
        if (realTarget == null && duplicate)
        {
            // Handles relative children
            var cellToClone = source;
            var geo = this.getCellGeometry(source);
            
            while (geo != null && geo.relative)
            {
                cellToClone = this.getModel().getParent(cellToClone);
                geo = this.getCellGeometry(cellToClone);
            }
            
            // Handle consistuents for cloning
            var state = this.view.getState(cellToClone);
            var style = (state != null) ? state.style : this.getCellStyle(cellToClone);
            
            if (mxUtils.getValue(style, 'part', false))
            {
                var tmpParent = this.model.getParent(cellToClone);
                if (this.model.isVertex(tmpParent))
                    cellToClone = tmpParent;
            }
            
            realTarget = this.duplicateCells([cellToClone], false)[0];
            var geo = this.getCellGeometry(realTarget);
            if (geo != null)
            {
                geo.x = pt.x - geo.width / 2;
                geo.y = pt.y - geo.height / 2;
            }
        }
        
        // Never connects children in stack layouts
        var layout = null;
        if (this.layoutManager != null)
            layout = this.layoutManager.getLayout(this.model.getParent(source));
        
        var edge = ((mxEvent.isControlDown(evt) && duplicate) || (target == null && layout != null && layout.constructor == mxStackLayout)) ? null :
            this.insertEdge(this.model.getParent(source), null, '', source, realTarget, this.createCurrentEdgeStyle());

        // Inserts edge before source
        if (edge != null && this.connectionHandler.insertBeforeSource)
        {
            var index = null;
            var tmp = source;
            
            while (tmp.parent != null && tmp.geometry != null &&
                tmp.geometry.relative && tmp.parent != edge.parent)
            {
                tmp = this.model.getParent(tmp);
            }
        
            if (tmp != null && tmp.parent != null && tmp.parent == edge.parent)
            {
                var index = tmp.parent.getIndex(tmp);
                this.model.add(tmp.parent, edge, index);
            }
        }
        
        // Special case: Click on west icon puts clone before cell
        if (target == null && realTarget != null && layout != null && source.parent != null &&
            layout.constructor == mxStackLayout && direction == mxConstants.DIRECTION_WEST)
        {
            var index = source.parent.getIndex(source);
            this.model.add(source.parent, realTarget, index);
        }
        
        if (edge != null)
            result.push(edge);
        
        if (target == null && realTarget != null)
            result.push(realTarget);
        
        if (realTarget == null && edge != null)
            edge.geometry.setTerminalPoint(pt, false);
        
        if (edge != null)
            this.fireEvent(new mxEventObject('cellsInserted', 'cells', [edge]));
    }
    finally
    {
        this.model.endUpdate();
    }
    
    return result;
};

/**
 * Returns all labels in the diagram as a string.
 */
Graph.prototype.getIndexableText = function()
{
    var tmp = document.createElement('div');
    var labels = [];
    var label = '';
    
    for (var key in this.model.cells)
    {
        var cell = this.model.cells[key];
        if (this.model.isVertex(cell) || this.model.isEdge(cell))
        {
            if (this.isHtmlLabel(cell))
            {
                tmp.innerHTML = this.getLabel(cell);
                label = mxUtils.extractTextWithWhitespace([tmp]);
            }
            else
            	label = this.getLabel(cell);

            label = mxUtils.trim(label.replace(/[\x00-\x1F\x7F-\x9F]|\s+/g, ' '));
            if (label.length > 0)
                labels.push(label);
        }
    }
    
    return labels.join(' ');
};

/**
 * Returns the label for the given cell.
 */
Graph.prototype.convertValueToString = function(cell)
{
    if (cell.value != null && typeof cell.value == 'object')
    {
        if (this.isReplacePlaceholders(cell) && cell.getAttribute('placeholder') != null)
        {
            var name = cell.getAttribute('placeholder');
            var current = cell;
            var result = null;
                    
            while (result == null && current != null)
            {
                if (current.value != null && typeof current.value == 'object')
                    result = (current.hasAttribute(name)) ? ((current.getAttribute(name) != null) ? current.getAttribute(name) : '') : null;
                current = this.model.getParent(current);
            }
            
            return result || '';
        }
        else
        {	
            return cell.value.getAttribute('label') || '';
        }
    }
    
    return mxGraph.prototype.convertValueToString.apply(this, arguments);
};

/**
 * Returns the link for the given cell.
 */
Graph.prototype.getLinksForState = function(state)
{
    if (state != null && state.text != null && state.text.node != null)
    {
        return state.text.node.getElementsByTagName('a');
    }
    
    return null;
};

/**
 * Returns the link for the given cell.
 */
Graph.prototype.getLinkForCell = function(cell)
{
    if (cell.value != null && typeof(cell.value) == 'object')
    {
        var link = cell.value.getAttribute('link');
        
        // Removes links with leading javascript: protocol
        // TODO: Check more possible attack vectors
        if (link != null && link.toLowerCase().substring(0, 11) === 'javascript:')
        {
            link = link.substring(11);
        }
        
        return link;
    }
    
    return null;
};

/**
 * Overrides label orientation for collapsed swimlanes inside stack.
 */
Graph.prototype.getCellStyle = function(cell)
{
    var style = mxGraph.prototype.getCellStyle.apply(this, arguments);
    
    if (cell != null && this.layoutManager != null)
    {
        var parent = this.model.getParent(cell);
        
        if (this.model.isVertex(parent) && this.isCellCollapsed(cell))
        {
            var layout = this.layoutManager.getLayout(parent);
            
            if (layout != null && layout.constructor == mxStackLayout)
            {
                style[mxConstants.STYLE_HORIZONTAL] = !layout.horizontal;
            }
        }
    }
    
    return style;
};

/**
 * Disables alternate width persistence for stack layout parents
 */
Graph.prototype.updateAlternateBounds = function(cell, geo, willCollapse)
{
    if (cell != null && geo != null && this.layoutManager != null && geo.alternateBounds != null)
    {
        var layout = this.layoutManager.getLayout(this.model.getParent(cell));
        
        if (layout != null && layout.constructor == mxStackLayout)
        {
            if (layout.horizontal)
            {
                geo.alternateBounds.height = 0;
            }
            else
            {
                geo.alternateBounds.width = 0;
            }
        }
    }
    
    mxGraph.prototype.updateAlternateBounds.apply(this, arguments);
};

/**
 * Adds Shift+collapse/expand and size management for folding inside stack
 */
Graph.prototype.isMoveCellsEvent = function (evt, state)
{
    return mxEvent.isShiftDown(evt) || mxUtils.getValue(state.style, 'moveCells', '0') == '1';
};

/**
 * Adds Shift+collapse/expand and size management for folding inside stack
 */
Graph.prototype.foldCells = function(collapse, recurse, cells, checkFoldable, evt)
{
    recurse = (recurse != null) ? recurse : false;
    
    if (cells == null)
    {
        cells = this.getFoldableCells(this.getSelectionCells(), collapse);
    }
    
    if (cells != null)
    {
        this.model.beginUpdate();
        
        try
        {
            mxGraph.prototype.foldCells.apply(this, arguments);
            
            // Resizes all parent stacks if alt is not pressed
            if (this.layoutManager != null)
            {
                for (var i = 0; i < cells.length; i++)
                {
                    var state = this.view.getState(cells[i]);
                    var geo = this.getCellGeometry(cells[i]);
                    
                    if (state != null && geo != null)
                    {
                        var dx = Math.round(geo.width - state.width / this.view.scale);
                        var dy = Math.round(geo.height - state.height / this.view.scale);
                        
                        if (dy != 0 || dx != 0)
                        {
                            var parent = this.model.getParent(cells[i]);
                            var layout = this.layoutManager.getLayout(parent);
                            
                            if (layout == null)
                            {
                                // Moves cells to the right and down after collapse/expand
                                if (evt != null && this.isMoveCellsEvent(evt, state))
                                {
                                    this.moveSiblings(state, parent, dx, dy);
                                } 
                            }
                            else if ((evt == null || !mxEvent.isAltDown(evt)) && layout.constructor == mxStackLayout && !layout.resizeLast)
                            {
                                this.resizeParentStacks(parent, layout, dx, dy);
                            }
                        }
                    }
                }
            }
        }
        finally
        {
            this.model.endUpdate();
        }
        
        // Selects cells after folding
        if (this.isEnabled())
        {
            this.setSelectionCells(cells);
        }
    }
};

/**
 * Overrides label orientation for collapsed swimlanes inside stack.
 */
Graph.prototype.moveSiblings = function(state, parent, dx, dy)
{
    this.model.beginUpdate();
    try
    {
        var cells = this.getCellsBeyond(state.x, state.y, parent, true, true);
        
        for (var i = 0; i < cells.length; i++)
        {
            if (cells[i] != state.cell)
            {
                var tmp = this.view.getState(cells[i]);
                var geo = this.getCellGeometry(cells[i]);
                
                if (tmp != null && geo != null)
                {
                    geo = geo.clone();
                    geo.translate(Math.round(dx * Math.max(0, Math.min(1, (tmp.x - state.x) / state.width))),
                        Math.round(dy * Math.max(0, Math.min(1, (tmp.y - state.y) / state.height))));
                    this.model.setGeometry(cells[i], geo);
                }
            }
        }
    }
    finally
    {
        this.model.endUpdate();
    }
};

/**
 * Overrides label orientation for collapsed swimlanes inside stack.
 */
Graph.prototype.resizeParentStacks = function(parent, layout, dx, dy)
{
    if (this.layoutManager != null && layout != null && layout.constructor == mxStackLayout && !layout.resizeLast)
    {
        this.model.beginUpdate();
        try
        {
            var dir = layout.horizontal;
            
            // Bubble resize up for all parent stack layouts with same orientation
            while (parent != null && layout != null && layout.constructor == mxStackLayout &&
                layout.horizontal == dir && !layout.resizeLast)
            {
                var pgeo = this.getCellGeometry(parent);
                var pstate = this.view.getState(parent);
                
                if (pstate != null && pgeo != null)
                {
                    pgeo = pgeo.clone();
                    
                    if (layout.horizontal)
                    {
                        pgeo.width += dx + Math.min(0, pstate.width / this.view.scale - pgeo.width);									
                    }
                    else
                    {
                        pgeo.height += dy + Math.min(0, pstate.height / this.view.scale - pgeo.height);
                    }
        
                    this.model.setGeometry(parent, pgeo);
                }
                
                parent = this.model.getParent(parent);
                layout = this.layoutManager.getLayout(parent);
            }
        }
        finally
        {
            this.model.endUpdate();
        }
    }
};

/**
 * Disables drill-down for non-swimlanes.
 */
Graph.prototype.isContainer = function(cell)
{
    var state = this.view.getState(cell);
    var style = (state != null) ? state.style : this.getCellStyle(cell);
    
    if (this.isSwimlane(cell))
    {
        return style['container'] != '0';
    }
    else
    {
        return style['container'] == '1';
    }
};

/**
 * Adds a connectable style.
 */
Graph.prototype.isCellConnectable = function(cell)
{
    var state = this.view.getState(cell);
    var style = (state != null) ? state.style : this.getCellStyle(cell);
    
    return (style != null && style[mxConstants.STYLE_CONNECTABLE] != null) ? style[mxConstants.STYLE_CONNECTABLE] != '0' :
        mxGraph.prototype.isCellConnectable.apply(this, arguments);
};

/**
 * Selects all children of the given parent cell or the children of the
 * default parent if no parent is specified. To select leaf vertices and/or
 * edges use <selectCells>.
 * 
 * Parameters:
 * 
 * parent - Optional <mxCell> whose children should be selected.
 * Default is <defaultParent>.
 */
Graph.prototype.selectAll = function(parent)
{
    parent = parent || this.getDefaultParent();

    if (!this.isCellLocked(parent))
    {
        mxGraph.prototype.selectAll.apply(this, arguments);
    }
};

/**
 * Selects all vertices and/or edges depending on the given boolean
 * arguments recursively, starting at the given parent or the default
 * parent if no parent is specified. Use <selectAll> to select all cells.
 * For vertices, only cells with no children are selected.
 * 
 * Parameters:
 * 
 * vertices - Boolean indicating if vertices should be selected.
 * edges - Boolean indicating if edges should be selected.
 * parent - Optional <mxCell> that acts as the root of the recursion.
 * Default is <defaultParent>.
 */
Graph.prototype.selectCells = function(vertices, edges, parent)
{
    parent = parent || this.getDefaultParent();

    if (!this.isCellLocked(parent))
    {
        mxGraph.prototype.selectCells.apply(this, arguments);
    }
};

/**
 * Function: getSwimlaneAt
 * 
 * Returns the bottom-most swimlane that intersects the given point (x, y)
 * in the cell hierarchy that starts at the given parent.
 * 
 * Parameters:
 * 
 * x - X-coordinate of the location to be checked.
 * y - Y-coordinate of the location to be checked.
 * parent - <mxCell> that should be used as the root of the recursion.
 * Default is <defaultParent>.
 */
Graph.prototype.getSwimlaneAt = function (x, y, parent)
{
    parent = parent || this.getDefaultParent();

    if (!this.isCellLocked(parent))
    {
        return mxGraph.prototype.getSwimlaneAt.apply(this, arguments);
    }
    
    return null;
};

/**
 * Disables folding for non-swimlanes.
 */
Graph.prototype.isCellFoldable = function(cell)
{
    var state = this.view.getState(cell);
    var style = (state != null) ? state.style : this.getCellStyle(cell);
    
    return this.foldingEnabled && (style['treeFolding'] == '1' ||
        (!this.isCellLocked(cell) &&
        ((this.isContainer(cell) && style['collapsible'] != '0') ||
        (!this.isContainer(cell) && style['collapsible'] == '1'))));
};

/**
 * Stops all interactions and clears the selection.
 */
Graph.prototype.reset = function()
{
    if (this.isEditing())
    {
        this.stopEditing(true);
    }
    
    this.escape();
                    
    if (!this.isSelectionEmpty())
    {
        this.clearSelection();
    }
};

/**
 * Overridden to limit zoom to 1% - 16.000%.
 */
Graph.prototype.zoom = function(factor, center)
{
    factor = Math.max(0.01, Math.min(this.view.scale * factor, 160)) / this.view.scale;
    
    mxGraph.prototype.zoom.apply(this, arguments);
};

/**
 * Function: zoomIn
 * 
 * Zooms into the graph by <zoomFactor>.
 */
Graph.prototype.zoomIn = function()
{
    // Switches to 1% zoom steps below 15%
    if (this.view.scale < 0.15)
    {
        this.zoom((this.view.scale + 0.01) / this.view.scale);
    }
    else
    {
        // Uses to 5% zoom steps for better grid rendering in webkit
        // and to avoid rounding errors for zoom steps
        this.zoom((Math.round(this.view.scale * this.zoomFactor * 20) / 20) / this.view.scale);
    }
};

/**
 * Function: zoomOut
 * 
 * Zooms out of the graph by <zoomFactor>.
 */
Graph.prototype.zoomOut = function()
{
    // Switches to 1% zoom steps below 15%
    if (this.view.scale <= 0.15)
    {
        this.zoom((this.view.scale - 0.01) / this.view.scale);
    }
    else
    {
        // Uses to 5% zoom steps for better grid rendering in webkit
        // and to avoid rounding errors for zoom steps
        this.zoom((Math.round(this.view.scale * (1 / this.zoomFactor) * 20) / 20) / this.view.scale);
    }
};

/**
 * Overrides tooltips to show custom tooltip or metadata.
 */
Graph.prototype.getTooltipForCell = function(cell)
{
    var tip = '';

    if (cell == null)
        return tip;

    if (cell.getTooltip != null)
    {
        tip = cell.getTooltip();
    }
    else
    {
        if (mxUtils.isNode(cell.value))
        {
            var tmp = cell.value.getAttribute('tooltip');

            if (tmp != null)
            {
                if (tmp != null && this.isReplacePlaceholders(cell))
                {
                    tmp = this.replacePlaceholders(cell, tmp);
                }

                tip = this.sanitizeHtml(tmp);
            }
            else
            {
                var ignored = this.builtInProperties;
                var attrs = cell.value.attributes;
                var temp = [];

                // Hides links in edit mode
                if (this.isEnabled())
                {
                    ignored.push('link');
                }

                for (var i = 0; i < attrs.length; i++)
                {
                    if (mxUtils.indexOf(ignored, attrs[i].nodeName) < 0 && attrs[i].nodeValue.length > 0)
                    {
                        temp.push({ name: attrs[i].nodeName, value: attrs[i].nodeValue });
                    }
                }

                // Sorts by name
                temp.sort(function (a, b)
                {
                    if (a.name < b.name)
                    {
                        return -1;
                    }
                    else if (a.name > b.name)
                    {
                        return 1;
                    }
                    else
                    {
                        return 0;
                    }
                });

                for (var i = 0; i < temp.length; i++)
                {
                    if (temp[i].name != 'link' || !this.isCustomLink(temp[i].value))
                    {
                        tip += ((temp[i].name != 'link') ? '<b>' + temp[i].name + ':</b> ' : '') +
                            mxUtils.htmlEntities(temp[i].value) + '\n';
                    }
                }

                if (tip.length > 0)
                {
                    tip = tip.substring(0, tip.length - 1);
                    tip = '<div style="max-width:360px;">' + tip + '</div>';
                }
            }
        }
    }
    return tip;
};

/**
 * Turns the given string into an array.
 */
Graph.prototype.stringToBytes = function(str)
{
    return Graph.stringToBytes(str);
};

/**
 * Turns the given array into a string.
 */
Graph.prototype.bytesToString = function(arr)
{
    return Graph.bytesToString(arr);
};

/**
 * Returns a base64 encoded version of the compressed outer XML of the given node.
 */
Graph.prototype.compressNode = function(node)
{
    return Graph.compressNode(node);
};

/**
 * Returns a base64 encoded version of the compressed string.
 */
Graph.prototype.compress = function(data, deflate)
{
    return Graph.compress(data, deflate);
};

/**
 * Returns a decompressed version of the base64 encoded string.
 */
Graph.prototype.decompress = function(data, inflate)
{
    return Graph.decompress(data, inflate);
};

/**
 * Redirects to Graph.zapGremlins.
 */
Graph.prototype.zapGremlins = function(text)
{
    return Graph.zapGremlins(text);
};

/**
 * Hover icons are used for hover, vertex handler and drag from sidebar.
 */
 function HoverIcons(graph)
{
    this.graph = graph;
    this.init();
};

/**
 * Up arrow.
 */
HoverIcons.prototype.arrowSpacing = 2;

/**
 * Delay to switch to another state for overlapping bbox. Default is 500ms.
 */
HoverIcons.prototype.updateDelay = 300;

/**
 * Delay to switch between states. Default is 140ms.
 */
HoverIcons.prototype.activationDelay = 140;

/**
 * Up arrow.
 */
HoverIcons.prototype.currentState = null;

/**
 * Up arrow.
 */
HoverIcons.prototype.activeArrow = null;

/**
 * Up arrow.
 */
HoverIcons.prototype.inactiveOpacity = 15;

/**
 * Up arrow.
 */
HoverIcons.prototype.cssCursor = 'copy';

/**
 * Whether to hide arrows that collide with vertices.
 * LATER: Add keyboard override, touch support.
 */
HoverIcons.prototype.checkCollisions = true;

/**
 * Up arrow.
 */
HoverIcons.prototype.arrowFill = '#29b6f2';

/**
 * Up arrow.
 */
HoverIcons.prototype.triangleUp = Graph.createSvgImage(18, 28, '<path d="m 6 26 L 12 26 L 12 12 L 18 12 L 9 1 L 1 12 L 6 12 z" ' +
    'stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>');

/**
 * Right arrow.
 */
HoverIcons.prototype.triangleRight = Graph.createSvgImage(26, 18, '<path d="m 1 6 L 14 6 L 14 1 L 26 9 L 14 18 L 14 12 L 1 12 z" ' +
    'stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>');

/**
 * Down arrow.
 */
HoverIcons.prototype.triangleDown = Graph.createSvgImage(18, 26, '<path d="m 6 1 L 6 14 L 1 14 L 9 26 L 18 14 L 12 14 L 12 1 z" ' +
    'stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>');

/**
 * Left arrow.
 */
HoverIcons.prototype.triangleLeft = Graph.createSvgImage(28, 18, '<path d="m 1 9 L 12 1 L 12 6 L 26 6 L 26 12 L 12 12 L 12 18 z" ' +
    'stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>');

/**
 * Round target.
 */
HoverIcons.prototype.roundDrop = Graph.createSvgImage(26, 26, '<circle cx="13" cy="13" r="12" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '"/>');

/**
 * Refresh target.
 */
HoverIcons.prototype.refreshTarget = new mxImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAAmCAYAAACoPemuAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NDQxNERDRTU1QjY1MTFFNDkzNTRFQTVEMTdGMTdBQjciIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NDQxNERDRTY1QjY1MTFFNDkzNTRFQTVEMTdGMTdBQjciPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0NDE0RENFMzVCNjUxMUU0OTM1NEVBNUQxN0YxN0FCNyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0NDE0RENFNDVCNjUxMUU0OTM1NEVBNUQxN0YxN0FCNyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsvuX50AAANaSURBVHja7FjRZ1tRGD9ZJ1NCyIQSwrivI4Q8hCpjlFDyFEoYfSp9Ko1QWnmo0If+BSXkIfo0QirTMUpeGo2EPfWllFYjZMLKLDJn53d3biU337m5J223bPbxk5t7v+/c3/2+73znO8fDOWezKM/YjMpz68Lj8ejY+QTeCCwLxOS9qPxtyN+6wAeBTwJ31CCO0cJDjXBGBN4LfIepSwykTUT1bgpuib0SONIgo8KRHOtRiCFcvUcgZeGrHPNBxLIyFPyRgTGz0xLbegJCdmzpElue5KlAIMDX19d5uVzm5+fnfDAYmMA17uEZdOx2Yvb/sHlu2S0xwymn5ufneTab5b1ej08S6EAXNrDd2dnhiUTim21MvMtwQ6yiIrWwsMDPzs64rsBmf3/fvM7n89TYlUnEllSkQqEQv7q64g+Vk5MTVXosORErU0Zer5f0FEIlw2N6MxwO82QyaXql2+2SxDqdjopYWUUsqEp45IldqtWq6UWVh/1+P7+8vCTJ4QMUJSRIEXuneoH96w8PDyeWAnhSJfCqwm6NIlaklFdXV0cGhRcQ2mlJQXK5nMq2YPEZbnteU1U2lUqN/D84OGD9fl+5fgnSrFarsUwmw0qlEru4uBjTicViTk3Cr27HSnxR+Doyz0ZE1CAWiUTusbu7y9rttlZv5fP5WDQavYfIMba4uEipfhF8XtqJoZXx/uH+sC/4vPg7OljZZQbsCmLtYzc3N6zRaJhotVrmfx0xDINtbm6athYUeXpHdbBNaqZUKpWxWXV7e2vex+xaWVnhc3NzjrPUXgexyCt0m67LBV7uJMITjqRE4o8tZeg8FPpFitgapYxiOC0poFgsji1jKNo6BZZckrAGUtJsNk1vqAihCBcKhTE7hNWhqw2qFnGy5UFOUYJVIJ1OjzSE+BCEilon0URavRmBqnbbQ00AXbm+vnZc9O1tj72OnQoc2+cwygRkb2+P1et17ZoEm3g87lRmjgWZ00kbXkNuse6/Bu2wlegIxfb2tuvWGroO4bO2c4bbzUh60mxDXm1sbJhhxkQYnhS4h2fUZoRAWnf7lv8N27f8P7Xhnekjgpk+VKGOoQbsiY+hhhtF3YO7twIJ+ULvUGv+GQ2fQEvWxI/THNx5/p/BaspPAQYAqStgiSQwCDoAAAAASUVORK5CYII=', 38, 38);

/**
 * Tolerance for hover icon clicks.
 */
HoverIcons.prototype.tolerance = (mxClient.IS_TOUCH) ? 6 : 0;

HoverIcons.prototype.init = function()
{
    this.arrowUp = this.createArrow(this.triangleUp, mxResources.get('plusTooltip'));
    this.arrowRight = this.createArrow(this.triangleRight, mxResources.get('plusTooltip'));
    this.arrowDown = this.createArrow(this.triangleDown, mxResources.get('plusTooltip'));
    this.arrowLeft = this.createArrow(this.triangleLeft, mxResources.get('plusTooltip'));

    this.elts = [this.arrowUp, this.arrowRight, this.arrowDown, this.arrowLeft];

    this.repaintHandler = mxUtils.bind(this, function()
    {
        this.repaint();
    });

    this.graph.selectionModel.addListener(mxEvent.CHANGE, this.repaintHandler);
    this.graph.model.addListener(mxEvent.CHANGE, this.repaintHandler);
    this.graph.view.addListener(mxEvent.SCALE_AND_TRANSLATE, this.repaintHandler);
    this.graph.view.addListener(mxEvent.TRANSLATE, this.repaintHandler);
    this.graph.view.addListener(mxEvent.SCALE, this.repaintHandler);
    this.graph.view.addListener(mxEvent.DOWN, this.repaintHandler);
    this.graph.view.addListener(mxEvent.UP, this.repaintHandler);
    this.graph.addListener(mxEvent.ROOT, this.repaintHandler);
    
    // Resets the mouse point on escape
    this.graph.addListener(mxEvent.ESCAPE, mxUtils.bind(this, function()
    {
        this.mouseDownPoint = null;
    }));

    // Removes hover icons if mouse leaves the container
    mxEvent.addListener(this.graph.container, 'mouseleave',  mxUtils.bind(this, function(evt)
    {
        // Workaround for IE11 firing mouseleave for touch in diagram
        if (evt.relatedTarget != null && mxEvent.getSource(evt) == this.graph.container)
        {
            this.setDisplay('none');
        }
    }));
    
    // Resets current state when in-place editor starts
    this.graph.addListener(mxEvent.START_EDITING, mxUtils.bind(this, function(evt)
    {
        this.reset();
    }));
    
    // Resets current state after update of selection state for touch events
    var graphClick = this.graph.click;
    this.graph.click = mxUtils.bind(this, function(me)
    {
        graphClick.apply(this.graph, arguments);
        
        if (this.currentState != null && !this.graph.isCellSelected(this.currentState.cell) &&
            mxEvent.isTouchEvent(me.getEvent()) && !this.graph.model.isVertex(me.getCell()))
        {
            this.reset();
        }
    });
    
    // Checks if connection handler was active in mouse move
    // as workaround for possible double connection inserted
    var connectionHandlerActive = false;
    
    // Implements a listener for hover and click handling
    this.graph.addMouseListener(
    {
        mouseDown: mxUtils.bind(this, function(sender, me)
        {
            connectionHandlerActive = false;
            var evt = me.getEvent();
            
            if (this.isResetEvent(evt))
            {
                this.reset();
            }
            else if (!this.isActive())
            {
                var state = this.getState(me.getState());
                
                if (state != null || !mxEvent.isTouchEvent(evt))
                {
                    this.update(state);
                }
            }
            
            this.setDisplay('none');
        }),
        mouseMove: mxUtils.bind(this, function(sender, me)
        {
            var evt = me.getEvent();
            
            if (this.isResetEvent(evt))
            {
                this.reset();
            }
            else if (!this.graph.isMouseDown && !mxEvent.isTouchEvent(evt))
            {
                this.update(this.getState(me.getState()),
                    me.getGraphX(), me.getGraphY());
            }
            
            if (this.graph.connectionHandler != null &&
                this.graph.connectionHandler.shape != null)
            {
                connectionHandlerActive = true;
            }
        }),
        mouseUp: mxUtils.bind(this, function(sender, me)
        {
            var evt = me.getEvent();
            var pt = mxUtils.convertPoint(this.graph.container,
                mxEvent.getClientX(evt), mxEvent.getClientY(evt))
            
            if (this.isResetEvent(evt))
            {
                this.reset();
            }
            else if (this.isActive() && !connectionHandlerActive &&
                this.mouseDownPoint != null)
            {
                this.click(this.currentState, this.getDirection(), me);
            }
            else if (this.isActive())
            {
                // Selects target vertex after drag and clone if not only new edge was inserted
                if (this.graph.getSelectionCount() != 1 || !this.graph.model.isEdge(
                    this.graph.getSelectionCell()))
                {
                    this.update(this.getState(this.graph.view.getState(
                        this.graph.getCellAt(me.getGraphX(), me.getGraphY()))));
                }
                else
                {
                    this.reset();
                }
            }
            else if (mxEvent.isTouchEvent(evt) || (this.bbox != null &&
                mxUtils.contains(this.bbox, me.getGraphX(), me.getGraphY())))
            {
                // Shows existing hover icons if inside bounding box
                this.setDisplay('');
                this.repaint();
            }
            else if (!mxEvent.isTouchEvent(evt))
            {
                this.reset();
            }
            
            connectionHandlerActive = false;
            this.resetActiveArrow();
        })
    });
};
HoverIcons.prototype.isResetEvent = function(evt, allowShift)
{
    return mxEvent.isAltDown(evt) || (this.activeArrow == null && mxEvent.isShiftDown(evt)) ||
        mxEvent.isMetaDown(evt) || (mxEvent.isPopupTrigger(evt) && !mxEvent.isControlDown(evt));
};
HoverIcons.prototype.createArrow = function(img, tooltip)
{
    var arrow = mxUtils.createImage(img.src);
    arrow.style.width = img.width + 'px';
    arrow.style.height = img.height + 'px';
    arrow.style.padding = this.tolerance + 'px';
    
    if (tooltip)
        arrow.setAttribute('title', tooltip);
    
    arrow.style.position = 'absolute';
    arrow.style.cursor = this.cssCursor;

    mxEvent.addGestureListeners(arrow, mxUtils.bind(this, function(evt)
    {
        if (this.currentState != null && !this.isResetEvent(evt))
        {
            this.mouseDownPoint = mxUtils.convertPoint(this.graph.container,
                    mxEvent.getClientX(evt), mxEvent.getClientY(evt));
            this.drag(evt, this.mouseDownPoint.x, this.mouseDownPoint.y);
            this.activeArrow = arrow;
            this.setDisplay('none');
            mxEvent.consume(evt);
        }
    }));
    
    // Captures mouse events as events on graph
    mxEvent.redirectMouseEvents(arrow, this.graph, this.currentState);
    
    mxEvent.addListener(arrow, 'mouseenter', mxUtils.bind(this, function(evt)
    {
        // Workaround for Firefox firing mouseenter on touchend
        if (mxEvent.isMouseEvent(evt))
        {
            if (this.activeArrow != null && this.activeArrow != arrow)
            {
                mxUtils.setOpacity(this.activeArrow, this.inactiveOpacity);
            }

            this.graph.connectionHandler.constraintHandler.reset();
            mxUtils.setOpacity(arrow, 100);
            this.activeArrow = arrow;
        }
    }));
    
    mxEvent.addListener(arrow, 'mouseleave', mxUtils.bind(this, function(evt)
    {
        // Workaround for IE11 firing this event on touch
        if (!this.graph.isMouseDown)
        {
            this.resetActiveArrow();
        }
    }));
    
    return arrow;
};
HoverIcons.prototype.resetActiveArrow = function()
{
    if (this.activeArrow != null)
    {
        mxUtils.setOpacity(this.activeArrow, this.inactiveOpacity);
        this.activeArrow = null;
    }
};
HoverIcons.prototype.getDirection = function()
{
    var dir = mxConstants.DIRECTION_EAST;

    if (this.activeArrow == this.arrowUp)
    {
        dir = mxConstants.DIRECTION_NORTH;
    }
    else if (this.activeArrow == this.arrowDown)
    {
        dir = mxConstants.DIRECTION_SOUTH;
    }
    else if (this.activeArrow == this.arrowLeft)
    {
        dir = mxConstants.DIRECTION_WEST;
    }
        
    return dir;
};
HoverIcons.prototype.visitNodes = function(visitor)
{
    for (var i = 0; i < this.elts.length; i++)
    {
        if (this.elts[i] != null)
        {
            visitor(this.elts[i]);
        }
    }
};
HoverIcons.prototype.removeNodes = function()
{
    this.visitNodes(function(elt)
    {
        if (elt.parentNode != null)
        {
            elt.parentNode.removeChild(elt);
        }
    });
};
HoverIcons.prototype.setDisplay = function(display)
{
    this.visitNodes(function(elt)
    {
        elt.style.display = display;
    });
};
HoverIcons.prototype.isActive = function()
{
    return this.activeArrow != null && this.currentState != null;
};
HoverIcons.prototype.drag = function(evt, x, y)
{
    this.graph.popupMenuHandler.hideMenu();
    this.graph.stopEditing(false);

    // Checks if state was removed in call to stopEditing above
    if (this.currentState != null)
    {
        this.graph.connectionHandler.start(this.currentState, x, y);
        this.graph.isMouseTrigger = mxEvent.isMouseEvent(evt);
        this.graph.isMouseDown = true;
        
        // Hides handles for selection cell
        var handler = this.graph.selectionCellsHandler.getHandler(this.currentState.cell);    
        if (handler != null)
        {
            handler.setHandlesVisible(false);
        }
        
        // Ctrl+shift drag sets source constraint
        var es = this.graph.connectionHandler.edgeState;
        if (evt != null && mxEvent.isShiftDown(evt) && mxEvent.isControlDown(evt) && es != null &&
            mxUtils.getValue(es.style, mxConstants.STYLE_EDGE, null) === mxConstants.EDGESTYLE_ORTHOGONAL)
        {
            var direction = this.getDirection();
            es.cell.style = mxUtils.setStyle(es.cell.style, 'sourcePortConstraint', direction);
            es.style['sourcePortConstraint'] = direction;
        }
    }
};
HoverIcons.prototype.getStateAt = function(state, x, y)
{
    return this.graph.view.getState(this.graph.getCellAt(x, y));
};
HoverIcons.prototype.click = function(state, dir, me)
{
    var evt = me.getEvent();
    var x = me.getGraphX();
    var y = me.getGraphY();
    
    var tmp = this.getStateAt(state, x, y);
    
    if (tmp != null && this.graph.model.isEdge(tmp.cell) && !mxEvent.isControlDown(evt) &&
        (tmp.getVisibleTerminalState(true) == state || tmp.getVisibleTerminalState(false) == state))
    {
        this.graph.setSelectionCell(tmp.cell);
        this.reset();
    }
    else if (state != null)
    {
        var cells = this.graph.connectVertex(state.cell, dir, this.graph.defaultEdgeLength, evt);
        this.graph.selectCellsForConnectVertex(cells, evt, this);
        
        // Selects only target vertex if one exists
        if (cells.length == 2 && this.graph.model.isVertex(cells[1]))
        {
            this.graph.setSelectionCell(cells[1]);
            
            // Adds hover icons to new target vertex for touch devices
            if (mxEvent.isTouchEvent(evt))
            {
                this.update(this.getState(this.graph.view.getState(cells[1])));
            }
            else
            {
                // Hides hover icons after click with mouse
                this.reset();
            }
            
            this.graph.scrollCellToVisible(cells[1]);
        }
        else
        {
            this.graph.setSelectionCells(cells);
        }
    }
    
    me.consume();
};
HoverIcons.prototype.reset = function(clearTimeout)
{
    clearTimeout = (clearTimeout == null) ? true : clearTimeout;
    
    if (clearTimeout && this.updateThread != null)
    {
        window.clearTimeout(this.updateThread);
    }

    this.mouseDownPoint = null;
    this.currentState = null;
    this.activeArrow = null;
    this.removeNodes();
    this.bbox = null;
};
HoverIcons.prototype.repaint = function()
{
    this.bbox = null;
    
    if (this.currentState != null)
    {
        // Checks if cell was deleted
        this.currentState = this.getState(this.currentState);
        
        // Cell was deleted	
        if (this.currentState != null &&
            this.graph.model.isVertex(this.currentState.cell) &&
            this.graph.isCellConnectable(this.currentState.cell))
        {
            var bds = mxRectangle.fromRectangle(this.currentState);
            
            // Uses outer bounding box to take rotation into account
            if (this.currentState.shape != null && this.currentState.shape.boundingBox != null)
            {
                bds = mxRectangle.fromRectangle(this.currentState.shape.boundingBox);
            }

            bds.grow(this.graph.tolerance);
            bds.grow(this.arrowSpacing);
            
            var handler = this.graph.selectionCellsHandler.getHandler(this.currentState.cell);
            
            if (handler != null)
            {
                bds.x -= handler.horizontalOffset / 2;
                bds.y -= handler.verticalOffset / 2;
                bds.width += handler.horizontalOffset;
                bds.height += handler.verticalOffset;
                
                // Adds bounding box of rotation handle to avoid overlap
                if (handler.rotationShape != null && handler.rotationShape.node != null &&
                    handler.rotationShape.node.style.visibility != 'hidden' &&
                    handler.rotationShape.node.style.display != 'none' &&
                    handler.rotationShape.boundingBox != null)
                {
                    bds.add(handler.rotationShape.boundingBox);
                }
            }
            
            this.arrowUp.style.left = Math.round(this.currentState.getCenterX() - this.triangleUp.width / 2 - this.tolerance) + 'px';
            this.arrowUp.style.top = Math.round(bds.y - this.triangleUp.height - this.tolerance) + 'px';
            mxUtils.setOpacity(this.arrowUp, this.inactiveOpacity);
            
            this.arrowRight.style.left = Math.round(bds.x + bds.width - this.tolerance) + 'px';
            this.arrowRight.style.top = Math.round(this.currentState.getCenterY() - this.triangleRight.height / 2 - this.tolerance) + 'px';
            mxUtils.setOpacity(this.arrowRight, this.inactiveOpacity);
            
            this.arrowDown.style.left = this.arrowUp.style.left;
            this.arrowDown.style.top = Math.round(bds.y + bds.height - this.tolerance) + 'px';
            mxUtils.setOpacity(this.arrowDown, this.inactiveOpacity);
            
            this.arrowLeft.style.left = Math.round(bds.x - this.triangleLeft.width - this.tolerance) + 'px';
            this.arrowLeft.style.top = this.arrowRight.style.top;
            mxUtils.setOpacity(this.arrowLeft, this.inactiveOpacity);
            
            if (this.checkCollisions)
            {
                var right = this.graph.getCellAt(bds.x + bds.width +
                        this.triangleRight.width / 2, this.currentState.getCenterY());
                var left = this.graph.getCellAt(bds.x - this.triangleLeft.width / 2, this.currentState.getCenterY()); 
                var top = this.graph.getCellAt(this.currentState.getCenterX(), bds.y - this.triangleUp.height / 2); 
                var bottom = this.graph.getCellAt(this.currentState.getCenterX(), bds.y + bds.height + this.triangleDown.height / 2); 

                // Shows hover icons large cell is behind all directions of current cell
                if (right != null && right == left && left == top && top == bottom)
                {
                    right = null;
                    left = null;
                    top = null;
                    bottom = null;
                }
                
                var currentGeo = this.graph.getCellGeometry(this.currentState.cell);
                
                var checkCollision = mxUtils.bind(this, function(cell, arrow)
                {
                    var geo = this.graph.model.isVertex(cell) && this.graph.getCellGeometry(cell);
                    
                    // Ignores collision if vertex is more than 3 times the size of this vertex
                    if (cell != null && !this.graph.model.isAncestor(cell, this.currentState.cell) &&
                        (geo == null || currentGeo == null || (geo.height < 6 * currentGeo.height &&
                        geo.width < 6 * currentGeo.width)))
                    {
                        arrow.style.visibility = 'hidden';
                    }
                    else
                    {
                        arrow.style.visibility = 'visible';
                    }
                });
                
                checkCollision(right, this.arrowRight);
                checkCollision(left, this.arrowLeft);
                checkCollision(top, this.arrowUp);
                checkCollision(bottom, this.arrowDown);
            }
            else
            {
                this.arrowLeft.style.visibility = 'visible';
                this.arrowRight.style.visibility = 'visible';
                this.arrowUp.style.visibility = 'visible';
                this.arrowDown.style.visibility = 'visible';
            }
            
            if (this.graph.tooltipHandler.isEnabled())
            {
                this.arrowLeft.setAttribute('title', mxResources.get('plusTooltip'));
                this.arrowRight.setAttribute('title', mxResources.get('plusTooltip'));
                this.arrowUp.setAttribute('title', mxResources.get('plusTooltip'));
                this.arrowDown.setAttribute('title', mxResources.get('plusTooltip'));
            }
            else
            {
                this.arrowLeft.removeAttribute('title');
                this.arrowRight.removeAttribute('title');
                this.arrowUp.removeAttribute('title');
                this.arrowDown.removeAttribute('title');
            }
        }
        else
        {
            this.reset();
        }
        
        // Updates bounding box
        if (this.currentState != null)
        {
            this.bbox = this.computeBoundingBox();
            
            // Adds tolerance for hover
            if (this.bbox != null)
            {
                this.bbox.grow(10);
            }
        }
    }
};
HoverIcons.prototype.computeBoundingBox = function()
{
    var bbox = (!this.graph.model.isEdge(this.currentState.cell)) ? mxRectangle.fromRectangle(this.currentState) : null;
    
    this.visitNodes(function(elt)
    {
        if (elt.parentNode != null)
        {
            var tmp = new mxRectangle(elt.offsetLeft, elt.offsetTop, elt.offsetWidth, elt.offsetHeight);
            
            if (bbox == null)
            {
                bbox = tmp;
            }
            else
            {
                bbox.add(tmp);
            }
        }
    });
    
    return bbox;
};
HoverIcons.prototype.getState = function(state)
{
    if (state != null)
    {
        var cell = state.cell;
        
        if (!this.graph.getModel().contains(cell))
        {
            state = null;
        }
        else
        {
            // Uses connectable parent vertex if child is not connectable
            if (this.graph.getModel().isVertex(cell) && !this.graph.isCellConnectable(cell))
            {
                var parent = this.graph.getModel().getParent(cell);
                
                if (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent))
                {
                    cell = parent;
                }
            }
            
            // Ignores locked cells and edges
            if (this.graph.isCellLocked(cell) || this.graph.model.isEdge(cell))
            {
                cell = null;
            }
            
            state = this.graph.view.getState(cell);
            
            if (state != null && state.style == null)
            {
                state = null;
            }
        }
    }
    
    return state;
};
HoverIcons.prototype.update = function(state, x, y)
{
    if (!this.graph.connectionArrowsEnabled || (state != null && mxUtils.getValue(state.style, 'allowArrows', '1') == '0'))
    {
        this.reset();
    }
    else
    {
        if (state != null && state.cell.geometry != null && state.cell.geometry.relative &&
            this.graph.model.isEdge(state.cell.parent))
        {
            state = null;
        }
        
        var timeOnTarget = null;
        
        // Time on target
        if (this.prev != state || this.isActive())
        {
            this.startTime = new Date().getTime();
            this.prev = state;
            timeOnTarget = 0;
    
            if (this.updateThread != null)
            {
                window.clearTimeout(this.updateThread);
            }
            
            if (state != null)
            {
                // Starts timer to update current state with no mouse events
                this.updateThread = window.setTimeout(mxUtils.bind(this, function()
                {
                    if (!this.isActive() && !this.graph.isMouseDown &&
                        !this.graph.panningHandler.isActive())
                    {
                        this.prev = state;
                        this.update(state, x, y);
                    }
                }), this.updateDelay + 10);
            }
        }
        else if (this.startTime != null)
        {
            timeOnTarget = new Date().getTime() - this.startTime;
        }
        
        this.setDisplay('');
        
        if (this.currentState != null && this.currentState != state && timeOnTarget < this.activationDelay &&
            this.bbox != null && !mxUtils.contains(this.bbox, x, y))
        {
            this.reset(false);
        }
        else if (this.currentState != null || timeOnTarget > this.activationDelay)
        {
            if (this.currentState != state && ((timeOnTarget > this.updateDelay && state != null) ||
                this.bbox == null || x == null || y == null || !mxUtils.contains(this.bbox, x, y)))
            {
                if (state != null && this.graph.isEnabled())
                {
                    this.removeNodes();
                    this.setCurrentState(state);
                    this.repaint();
                    
                    // Resets connection points on other focused cells
                    if (this.graph.connectionHandler.constraintHandler.currentFocus != state)
                    {
                        this.graph.connectionHandler.constraintHandler.reset();
                    }
                }
                else
                {
                    this.reset();
                }
            }
        }
    }
};
HoverIcons.prototype.setCurrentState = function(state)
{
    if (state.style['portConstraint'] != 'eastwest')
    {
        this.graph.container.appendChild(this.arrowUp);
        this.graph.container.appendChild(this.arrowDown);
    }
    this.graph.container.appendChild(this.arrowRight);
    this.graph.container.appendChild(this.arrowLeft);
    this.currentState = state;
};

(function()
{
    /**
     * Reset the list of processed edges.
     */
    var mxGraphViewResetValidationState = mxGraphView.prototype.resetValidationState;
    mxGraphView.prototype.resetValidationState = function()
    {
        mxGraphViewResetValidationState.apply(this, arguments);
        
        this.validEdges = [];
    };
    
    /**
     * Updates jumps for valid edges and repaints if needed.
     */
    var mxGraphViewValidateCellState = mxGraphView.prototype.validateCellState;
    mxGraphView.prototype.validateCellState = function(cell, recurse)
    {
        recurse = (recurse != null) ? recurse : true;
        var state = this.getState(cell);
        
        // Forces repaint if jumps change on a valid edge
        if (state != null && recurse && this.graph.model.isEdge(state.cell) &&
            state.style != null && state.style[mxConstants.STYLE_CURVED] != 1 &&
            !state.invalid && this.updateLineJumps(state))
        {
            this.graph.cellRenderer.redraw(state, false, this.isRendering());
        }
        
        state = mxGraphViewValidateCellState.apply(this, arguments);
        
        // Adds to the list of edges that may intersect with later edges
        if (state != null && recurse && this.graph.model.isEdge(state.cell) &&
            state.style != null && state.style[mxConstants.STYLE_CURVED] != 1)
        {
            // LATER: Reuse jumps for valid edges
            this.validEdges.push(state);
        }
        
        return state;
    };

    /**
     * Forces repaint if routed points have changed.
     */
    var mxCellRendererIsShapeInvalid = mxCellRenderer.prototype.isShapeInvalid;
    mxCellRenderer.prototype.isShapeInvalid = function(state, shape)
    {
        return mxCellRendererIsShapeInvalid.apply(this, arguments) ||
            (state.routedPoints != null && shape.routedPoints != null && !mxUtils.equalPoints(shape.routedPoints, state.routedPoints));
    };

    
    /**
     * Updates jumps for invalid edges.
     */
    var mxGraphViewUpdateCellState = mxGraphView.prototype.updateCellState;
    mxGraphView.prototype.updateCellState = function(state)
    {
        mxGraphViewUpdateCellState.apply(this, arguments);

        // Updates jumps on invalid edge before repaint
        if (this.graph.model.isEdge(state.cell) &&
            state.style[mxConstants.STYLE_CURVED] != 1)
        {
            this.updateLineJumps(state);
        }
    };
    
    /**
     * Updates the jumps between given state and processed edges.
     */
    mxGraphView.prototype.updateLineJumps = function(state)
    {
        var pts = state.absolutePoints;
        
        if (Graph.lineJumpsEnabled)
        {
            var changed = state.routedPoints != null;
            var actual = null;
            
            if (pts != null && this.validEdges != null &&
                mxUtils.getValue(state.style, 'jumpStyle', 'none') !== 'none')
            {
                var thresh = 0.5 * this.scale;
                changed = false;
                actual = [];
                
                // Type 0 means normal waypoint, 1 means jump
                function addPoint(type, x, y)
                {
                    var rpt = new mxPoint(x, y);
                    rpt.type = type;
                    
                    actual.push(rpt);
                    var curr = (state.routedPoints != null) ? state.routedPoints[actual.length - 1] : null;
                    
                    return curr == null || curr.type != type || curr.x != x || curr.y != y;
                }
                
                for (var i = 0; i < pts.length - 1; i++)
                {
                    var p1 = pts[i + 1];
                    var p0 = pts[i];
                    var list = [];
                    
                    // Ignores waypoints on straight segments
                    var pn = pts[i + 2];
                    
                    while (i < pts.length - 2 &&
                        mxUtils.ptSegDistSq(p0.x, p0.y, pn.x, pn.y,
                        p1.x, p1.y) < 1 * this.scale * this.scale)
                    {
                        p1 = pn;
                        i++;
                        pn = pts[i + 2];
                    }
                    
                    changed = addPoint(0, p0.x, p0.y) || changed;
                    
                    // Processes all previous edges
                    for (var e = 0; e < this.validEdges.length; e++)
                    {
                        var state2 = this.validEdges[e];
                        var pts2 = state2.absolutePoints;
                        
                        if (pts2 != null && mxUtils.intersects(state, state2) && state2.style['noJump'] != '1')
                        {
                            // Compares each segment of the edge with the current segment
                            for (var j = 0; j < pts2.length - 1; j++)
                            {
                                var p3 = pts2[j + 1];
                                var p2 = pts2[j];
                                
                                // Ignores waypoints on straight segments
                                pn = pts2[j + 2];
                                
                                while (j < pts2.length - 2 &&
                                    mxUtils.ptSegDistSq(p2.x, p2.y, pn.x, pn.y,
                                    p3.x, p3.y) < 1 * this.scale * this.scale)
                                {
                                    p3 = pn;
                                    j++;
                                    pn = pts2[j + 2];
                                }
                                
                                var pt = mxUtils.intersection(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
    
                                // Handles intersection between two segments
                                if (pt != null && (Math.abs(pt.x - p0.x) > thresh ||
                                    Math.abs(pt.y - p0.y) > thresh) &&
                                    (Math.abs(pt.x - p1.x) > thresh ||
                                    Math.abs(pt.y - p1.y) > thresh) &&
                                    (Math.abs(pt.x - p2.x) > thresh ||
                                    Math.abs(pt.y - p2.y) > thresh) &&
                                    (Math.abs(pt.x - p3.x) > thresh ||
                                    Math.abs(pt.y - p3.y) > thresh))
                                {
                                    var dx = pt.x - p0.x;
                                    var dy = pt.y - p0.y;
                                    var temp = {distSq: dx * dx + dy * dy, x: pt.x, y: pt.y};
                                
                                    // Intersections must be ordered by distance from start of segment
                                    for (var t = 0; t < list.length; t++)
                                    {
                                        if (list[t].distSq > temp.distSq)
                                        {
                                            list.splice(t, 0, temp);
                                            temp = null;
                                            
                                            break;
                                        }
                                    }
                                    
                                    // Ignores multiple intersections at segment joint
                                    if (temp != null && (list.length == 0 ||
                                        list[list.length - 1].x !== temp.x ||
                                        list[list.length - 1].y !== temp.y))
                                    {
                                        list.push(temp);
                                    }
                                }
                            }
                        }
                    }
                    
                    // Adds ordered intersections to routed points
                    for (var j = 0; j < list.length; j++)
                    {
                        changed = addPoint(1, list[j].x, list[j].y) || changed;
                    }
                }
    
                var pt = pts[pts.length - 1];
                changed = addPoint(0, pt.x, pt.y) || changed;
            }
            
            state.routedPoints = actual;
            
            return changed;
        }
        else
        {
            return false;
        }
    };
    
    /**
     * Overrides painting the actual shape for taking into account jump style.
     */
    var mxConnectorPaintLine = mxConnector.prototype.paintLine;
    mxConnector.prototype.paintLine = function (c, absPts, rounded)
    {
        // Required for checking dirty state
        this.routedPoints = (this.state != null) ? this.state.routedPoints : null;
        
        if (this.outline || this.state == null || this.style == null ||
            this.state.routedPoints == null || this.state.routedPoints.length == 0)
        {
            mxConnectorPaintLine.apply(this, arguments);
        }
        else
        {
            var arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
            var jumpSize = parseInt(mxUtils.getValue(this.style, 'jumpSize', Graph.defaultJumpSize));
            var size = (jumpSize - 2) / 2 + this.strokewidth;
            var style = mxUtils.getValue(this.style, 'jumpStyle', 'none');
            var moveTo = true;
            var last = null;
            var len = null;
            var pts = [];
            var n = null;
            c.begin();
            
            for (var i = 0; i < this.state.routedPoints.length; i++)
            {
                var rpt = this.state.routedPoints[i];
                var pt = new mxPoint(rpt.x / this.scale, rpt.y / this.scale);
                
                // Takes first and last point from passed-in array
                if (i == 0)
                {
                    pt = absPts[0];
                }
                else if (i == this.state.routedPoints.length - 1)
                {
                    pt = absPts[absPts.length - 1];
                }
                
                var done = false;

                // Type 1 is an intersection
                if (last != null && rpt.type == 1)
                {
                    // Checks if next/previous points are too close
                    var next = this.state.routedPoints[i + 1];
                    var dx = next.x / this.scale - pt.x;
                    var dy = next.y / this.scale - pt.y;
                    var dist = dx * dx + dy * dy;

                    if (n == null)
                    {
                        n = new mxPoint(pt.x - last.x, pt.y - last.y);
                        len = Math.sqrt(n.x * n.x + n.y * n.y);
                        
                        if (len > 0)
                        {
                            n.x = n.x * size / len;
                            n.y = n.y * size / len;
                        }
                        else
                        {
                            n = null;
                        }
                    }
                    
                    if (dist > size * size && len > 0)
                    {
                        var dx = last.x - pt.x;
                        var dy = last.y - pt.y;
                        var dist = dx * dx + dy * dy;
                        
                        if (dist > size * size)
                        {
                            var p0 = new mxPoint(pt.x - n.x, pt.y - n.y);
                            var p1 = new mxPoint(pt.x + n.x, pt.y + n.y);
                            pts.push(p0);
                            
                            this.addPoints(c, pts, rounded, arcSize, false, null, moveTo);
                            
                            var f = (Math.round(n.x) < 0 || (Math.round(n.x) == 0 && Math.round(n.y) <= 0)) ? 1 : -1;
                            moveTo = false;

                            if (style == 'sharp')
                            {
                                c.lineTo(p0.x - n.y * f, p0.y + n.x * f);
                                c.lineTo(p1.x - n.y * f, p1.y + n.x * f);
                                c.lineTo(p1.x, p1.y);
                            }
                            else if (style == 'arc')
                            {
                                f *= 1.3;
                                c.curveTo(p0.x - n.y * f, p0.y + n.x * f,
                                    p1.x - n.y * f, p1.y + n.x * f,
                                    p1.x, p1.y);
                            }
                            else if (style == 'point')
                            {
                                var ctx = new mxSvgCanvas2D(c.root);
                                ctx.state = mxUtils.clone(c.state);
                                ctx.begin();
                                ctx.setFillColor('#000000');
                                ctx.ellipse(pt.x - jumpSize / 2, pt.y - jumpSize / 2, jumpSize, jumpSize);
                                ctx.fill();
                                ctx.end();
                            }
                            else
                            {
                                c.moveTo(p1.x, p1.y);
                                moveTo = true;
                            }
    
                            pts = [p1];
                            done = true;
                        }
                    }
                }
                else
                {
                    n = null;
                }
                
                if (!done)
                {
                    pts.push(pt);
                    last = pt;
                }
            }
            
            this.addPoints(c, pts, rounded, arcSize, false, null, moveTo);
            c.stroke();
        }
    };
    
    /**
     * Adds support for snapToPoint style.
     */
    var mxGraphViewUpdateFloatingTerminalPoint = mxGraphView.prototype.updateFloatingTerminalPoint;
    mxGraphView.prototype.updateFloatingTerminalPoint = function(edge, start, end, source)
    {
        if (start != null && edge != null && (start.style['snapToPoint'] == '1' || edge.style['snapToPoint'] == '1'))
        {
            start = this.getTerminalPort(edge, start, source);
            var next = this.getNextPoint(edge, end, source);
            
            var orth = this.graph.isOrthogonal(edge);
            var alpha = mxUtils.toRadians(Number(start.style[mxConstants.STYLE_ROTATION] || '0'));
            var center = new mxPoint(start.getCenterX(), start.getCenterY());
            
            if (alpha != 0)
            {
                var cos = Math.cos(-alpha);
                var sin = Math.sin(-alpha);
                next = mxUtils.getRotatedPoint(next, cos, sin, center);
            }
            
            var border = parseFloat(edge.style[mxConstants.STYLE_PERIMETER_SPACING] || 0);
            border += parseFloat(edge.style[(source) ?
                mxConstants.STYLE_SOURCE_PERIMETER_SPACING :
                mxConstants.STYLE_TARGET_PERIMETER_SPACING] || 0);
            var pt = this.getPerimeterPoint(start, next, alpha == 0 && orth, border);
        
            if (alpha != 0)
            {
                var cos = Math.cos(alpha);
                var sin = Math.sin(alpha);
                pt = mxUtils.getRotatedPoint(pt, cos, sin, center);
            }
            
            edge.setAbsoluteTerminalPoint(this.snapToAnchorPoint(edge, start, end, source, pt), source);
        }
        else
        {
            mxGraphViewUpdateFloatingTerminalPoint.apply(this, arguments);
        }
    };

    mxGraphView.prototype.snapToAnchorPoint = function(edge, start, end, source, pt)
    {
        if (start != null && edge != null)
        {
            var constraints = this.graph.getAllConnectionConstraints(start);
            var nearest = null;
            var dist = null;
        
            if (constraints != null)
            {
                for (var i = 0; i < constraints.length; i++)
                {
                    var cp = this.graph.getConnectionPoint(start, constraints[i]);
                    if (cp != null)
                    {
                        var tmp = (cp.x - pt.x) * (cp.x - pt.x) + (cp.y - pt.y) * (cp.y - pt.y);
                        if (dist == null || tmp < dist)
                        {
                            nearest = cp;
                            dist = tmp;
                        }
                    }
                }
            }
            
            if (nearest != null)
                pt = nearest;
        }
        return pt;
    };
        
    /**
     * Adds support for placeholders in text elements of shapes.
     */
    var mxStencilEvaluateTextAttribute = mxStencil.prototype.evaluateTextAttribute;
    mxStencil.prototype.evaluateTextAttribute = function(node, attribute, shape)
    {
        var result = mxStencilEvaluateTextAttribute.apply(this, arguments);
        var placeholders = node.getAttribute('placeholders');
        if (placeholders == '1' && shape.state != null)
            result = shape.state.view.graph.replacePlaceholders(shape.state.cell, result);
        return result;
    };
        
    /**
     * Adds custom stencils defined via shape=stencil(value) style. The value is a base64 encoded, compressed and
     * URL encoded XML definition of the shape according to the stencil definition language of mxGraph.
     * 
     * Needs to be in this file to make sure its part of the embed client code. Also the check for ZLib is
     * different than for the Editor code.
     */
    var mxCellRendererCreateShape = mxCellRenderer.prototype.createShape;
    mxCellRenderer.prototype.createShape = function(state)
    {
        if (state.style != null && typeof(pako) !== 'undefined')
        {
            var shape = mxUtils.getValue(state.style, mxConstants.STYLE_SHAPE, null);
    
            // Extracts and decodes stencil XML if shape has the form shape=stencil(value)
            if (shape != null && typeof shape === 'string' && shape.substring(0, 8) == 'stencil(')
            {
                try
                {
                    var stencil = shape.substring(8, shape.length - 1);
                    var doc = mxUtils.parseXml(Graph.decompress(stencil));
                    
                    return new mxShape(new mxStencil(doc.documentElement));
                }
                catch (e)
                {
                    HELP.log('Error in shape: ' + e);
                }
            }
        }
        
        return mxCellRendererCreateShape.apply(this, arguments);
    };
})();

/**
 * These overrides are only added if mxVertexHandler is defined (ie. not in embedded graph)
 */
if (typeof mxVertexHandler != 'undefined')
{
    (function()
    {
        // Sets colors for handles
        mxConstants.HANDLE_FILLCOLOR = '#29b6f2';
        mxConstants.HANDLE_STROKECOLOR = '#0088cf';
        mxConstants.VERTEX_SELECTION_COLOR = '#00a8ff';

        mxConstants.OUTLINE_COLOR = '#00a8ff';
        mxConstants.OUTLINE_HANDLE_FILLCOLOR = '#99ccff';
        mxConstants.OUTLINE_HANDLE_STROKECOLOR = '#00a8ff';
        mxConstants.CONNECT_HANDLE_FILLCOLOR = '#cee7ff';
        mxConstants.EDGE_SELECTION_COLOR = '#00a8ff';
        mxConstants.DEFAULT_VALID_COLOR = '#00a8ff';
        mxConstants.LABEL_HANDLE_FILLCOLOR = '#cee7ff';
        mxConstants.GUIDE_COLOR = '#0088cf';
        mxConstants.HIGHLIGHT_OPACITY = 30;
        mxConstants.HIGHLIGHT_SIZE = 5;
        
        // Enables snapping to off-grid terminals for edge waypoints
        mxEdgeHandler.prototype.snapToTerminals = true;
    
        // Enables guides
        mxGraphHandler.prototype.guidesEnabled = true;
        
        // Removes parents where all child cells are moved out
        mxGraphHandler.prototype.removeEmptyParents = true;
    
        // Enables fading of rubberband
        mxRubberband.prototype.fadeOut = true;
        
        // Alt-move disables guides
        mxGuide.prototype.isEnabledForEvent = function(evt)
        {
            return !mxEvent.isAltDown(evt);
        };
        
        // Extends connection handler to enable ctrl+drag for cloning source cell
        // since copyOnConnect is now disabled by default
        var mxConnectionHandlerCreateTarget = mxConnectionHandler.prototype.isCreateTarget;
        mxConnectionHandler.prototype.isCreateTarget = function(evt)
        {
            return mxEvent.isControlDown(evt) || mxConnectionHandlerCreateTarget.apply(this, arguments);
        };

        // Overrides highlight shape for connection points
        mxConstraintHandler.prototype.createHighlightShape = function()
        {
            var hl = new mxEllipse(null, this.highlightColor, this.highlightColor, 0);
            hl.opacity = mxConstants.HIGHLIGHT_OPACITY;
            
            return hl;
        };
        
        // Overrides edge preview to use current edge shape and default style
        mxConnectionHandler.prototype.livePreview = true;
        mxConnectionHandler.prototype.cursor = 'crosshair';
        
        // Uses current edge style for connect preview
        mxConnectionHandler.prototype.createEdgeState = function(me)
        {
            var style = this.graph.createCurrentEdgeStyle();
            var edge = this.graph.createEdge(null, null, null, null, null, style);
            var state = new mxCellState(this.graph.view, edge, this.graph.getCellStyle(edge));
            
            for (var key in this.graph.currentEdgeStyle)
            {
                state.style[key] = this.graph.currentEdgeStyle[key];
            }
            
            return state;
        };

        // Overrides dashed state with current edge style
        var connectionHandlerCreateShape = mxConnectionHandler.prototype.createShape;
        mxConnectionHandler.prototype.createShape = function()
        {
            var shape = connectionHandlerCreateShape.apply(this, arguments);
            
            shape.isDashed = this.graph.currentEdgeStyle[mxConstants.STYLE_DASHED] == '1';
            
            return shape;
        }
        
        // Overrides live preview to keep current style
        mxConnectionHandler.prototype.updatePreview = function(valid)
        {
            // do not change color of preview
        };
        
        // Overrides connection handler to ignore edges instead of not allowing connections
        var mxConnectionHandlerCreateMarker = mxConnectionHandler.prototype.createMarker;
        mxConnectionHandler.prototype.createMarker = function()
        {
            var marker = mxConnectionHandlerCreateMarker.apply(this, arguments);
        
            var markerGetCell = marker.getCell;
            marker.getCell = mxUtils.bind(this, function(me)
            {
                var result = markerGetCell.apply(this, arguments);
            
                this.error = null;
                
                return result;
            });
            
            return marker;
        };

        /**
         * Function: isCellLocked
         * 
         * Returns true if the given cell does not allow new connections to be created.
         * This implementation returns false.
         */
        mxConnectionHandler.prototype.isCellEnabled = function(cell)
        {
            return !this.graph.isCellLocked(cell);
        };

        Graph.prototype.defaultVertexStyle = { };
        Graph.prototype.defaultEdgeStyle   = { 'edgeStyle': mxConstants.EDGESTYLE_ORTHOGONAL, 'rounded': '0', 'orthogonalLoop': '0' };

        /**
         * Returns the current edge style as a string.
         */
        Graph.prototype.createCurrentEdgeStyle = function()
        {
            var style = 'edgeStyle=' + (this.currentEdgeStyle['edgeStyle'] || 'none') + ';';
            
            if (this.currentEdgeStyle['shape'] != null)
            {
                style += 'shape=' + this.currentEdgeStyle['shape'] + ';';
            }
            
            if (this.currentEdgeStyle['curved'] != null)
            {
                style += 'curved=' + this.currentEdgeStyle['curved'] + ';';
            }
            
            if (this.currentEdgeStyle['rounded'] != null)
            {
                style += 'rounded=' + this.currentEdgeStyle['rounded'] + ';';
            }

            if (this.currentEdgeStyle['jumpStyle'] != null)
            {
                style += 'jumpStyle=' + this.currentEdgeStyle['jumpStyle'] + ';';
            }

            if (this.currentEdgeStyle['jumpSize'] != null)
            {
                style += 'jumpSize=' + this.currentEdgeStyle['jumpSize'] + ';';
            }

            // Overrides the global default to match the default edge style
            if (this.currentEdgeStyle['orthogonalLoop'] != null)
            {
                style += 'orthogonalLoop=' + this.currentEdgeStyle['orthogonalLoop'] + ';';
            }
            else if (Graph.prototype.defaultEdgeStyle['orthogonalLoop'] != null)
            {
                style += 'orthogonalLoop=' + Graph.prototype.defaultEdgeStyle['orthogonalLoop'] + ';';
            }

            // Overrides the global default to match the default edge style
            if (this.currentEdgeStyle['jettySize'] != null)
            {
                style += 'jettySize=' + this.currentEdgeStyle['jettySize'] + ';';
            }
            else if (Graph.prototype.defaultEdgeStyle['jettySize'] != null)
            {
                style += 'jettySize=' + Graph.prototype.defaultEdgeStyle['jettySize'] + ';';
            }
            
            // Special logic for custom property of elbowEdgeStyle
            if (this.currentEdgeStyle['edgeStyle'] == mxConstants.EDGESTYLE_ELBOW && this.currentEdgeStyle['elbow'] != null)
            {
                style += 'elbow=' + this.currentEdgeStyle['elbow'] + ';';
            }
            
            if (this.currentEdgeStyle['html'] != null)
            {
                style += 'html=' + this.currentEdgeStyle['html'] + ';';
            }
            else
            {
                style += 'html=1;';
            }
            
            return style;
        };
    
        /**
         * Hook for subclassers.
         */
        Graph.prototype.getPagePadding = function()
        {
            return new mxPoint(0, 0);
        };
        
        /**
         * Loads the stylesheet for this graph.
         */
        Graph.prototype.loadStylesheet = function()
        {
            var node = (this.themes != null) ? this.themes[this.defaultThemeName] :
                (!mxStyleRegistry.dynamicLoading) ? null : mxUtils.load('/thirdparty/mxgraph/editor/res/default.xml').getDocumentElement();
            
            if (node != null)
            {
                var dec = new mxCodec(node.ownerDocument);
                dec.decode(node, this.getStylesheet());
            }
        };

        /**
         * Creates lookup from object IDs to cell IDs.
         */
        Graph.prototype.createCellLookup = function (cells, lookup)
        {
            lookup = (lookup != null) ? lookup : new Object();
            for (var i = 0; i < cells.length; i++)
            {
                var cell = cells[i];
                lookup[mxObjectIdentity.get(cell)] = cell.getId();
                var childCount = this.model.getChildCount(cell);

                for (var j = 0; j < childCount; j++)
                {
                    this.createCellLookup([this.model.getChildAt(cell, j)], lookup);
                }
            }
            return lookup;
        };

		/**
		 * Creates lookup from original to cloned cell IDs where mapping is
		 * the mapping used in cloneCells and lookup is a mapping from
		 * object IDs to cell IDs.
		 */
        Graph.prototype.createCellMapping = function (mapping, lookup, cellMapping)
        {
            cellMapping = (cellMapping != null) ? cellMapping : new Object();
            for (var objectId in mapping)
            {
                var cellId = lookup[objectId];

                if (cellMapping[cellId] == null)
                {
                    // Uses empty string if clone ID was null which means
                    // the cell was cloned but not inserted into the model.
                    cellMapping[cellId] = mapping[objectId].getId() || '';
                }
            }
            return cellMapping;
        };

        /**
         * 
         */
        Graph.prototype.importGraphModel = function(node, dx, dy, crop)
        {
            dx = (dx != null) ? dx : 0;
            dy = (dy != null) ? dy : 0;

            var codec = new mxCodec(node.ownerDocument);
            var tempModel = new mxGraphModel();
            codec.decode(node, tempModel);
            var cells = []

            // Clones cells to remove invalid edges
            var cloneMap = new Object();
            var cellMapping = new Object();
            var layers = tempModel.getChildren(this.cloneCell(tempModel.root,
                this.isCloneInvalidEdges(), cloneMap));

            if (layers != null)
            {
                // Creates lookup from object IDs to cell IDs
                var lookup = this.createCellLookup([tempModel.root]);

                // Uses copy as layers are removed from array inside loop
                layers = layers.slice();

                this.model.beginUpdate();
                try
                {
                    // Merges into unlocked current layer if one layer is pasted
                    if (layers.length == 1 && !this.isCellLocked(this.getDefaultParent()))
                    {
                        cells = this.moveCells(tempModel.getChildren(layers[0]),
                            dx, dy, false, this.getDefaultParent());

                        // Imported default default parent maps to local default parent
                        cellMapping[tempModel.getChildAt(tempModel.root, 0).getId()] =
                            this.getDefaultParent().getId();
                    }
                    else
                    {
                        for (var i = 0; i < layers.length; i++)
                        {
                            cells = cells.concat(this.model.getChildren(this.moveCells(
                                [layers[i]], dx, dy, false, this.model.getRoot())[0]));
                        }
                    }

                    // Adds mapping for all cloned entries from imported to local cell ID
                    this.createCellMapping(cloneMap, lookup, cellMapping);
                    this.updateCustomLinks(cellMapping, cells);

                    if (crop)
                    {
                        if (this.isGridEnabled())
                        {
                            dx = this.snap(dx);
                            dy = this.snap(dy);
                        }

                        var bounds = this.getBoundingBoxFromGeometry(cells, true);

                        if (bounds != null)
                        {
                            this.moveCells(cells, dx - bounds.x, dy - bounds.y);
                        }
                    }
                }
                finally
                {
                    this.model.endUpdate();
                }
            }

            return cells;
        };
        
        /**
         * Overrides method to provide connection constraints for shapes.
         */
        Graph.prototype.getAllConnectionConstraints = function(terminal, source)
        {
            if (terminal != null)
            {
                var constraints = mxUtils.getValue(terminal.style, 'points', null);
                if (constraints != null)
                {
                    // Requires an array of arrays with x, y (0..1), an optional
                    // [perimeter (0 or 1), dx, and dy] eg. points=[[0,0,1,-10,10],[0,1,0],[1,1]]
                    var result = [];
                    
                    try
                    {
                        var c = JSON.parse(constraints);
                        
                        for (var i = 0; i < c.length; i++)
                        {
                            var tmp = c[i];
                            result.push(new mxConnectionConstraint(new mxPoint(tmp[0], tmp[1]), (tmp.length > 2) ? tmp[2] != '0' : true,
                                (tmp.length > 3) ? tmp[3] : null, (tmp.length > 4) ? tmp[4] : 0, (tmp.length > 5) ? tmp[5] : 0));
                        }
                    }
                    catch (e)
                    {
                        // ignore
                    }
                    
                    return result;
                }
                else if (terminal.shape != null && terminal.shape.bounds != null)
                {
                    var dir = terminal.shape.direction;
                    var bounds = terminal.shape.bounds;
                    var scale = terminal.shape.scale;
                    var w = bounds.width / scale;
                    var h = bounds.height / scale;
                    
                    if (dir == mxConstants.DIRECTION_NORTH || dir == mxConstants.DIRECTION_SOUTH)
                    {
                        var tmp = w;
                        w = h;
                        h = tmp;
                    }
                    
                    constraints = terminal.shape.getConstraints(terminal.style, w, h);
                    if (constraints != null)
                        return constraints;
                    else if (terminal.shape.stencil != null && terminal.shape.stencil.constraints != null)
                    {
                        return terminal.shape.stencil.constraints;
                    }
                    else if (terminal.shape.constraints != null)
                    {
                        return terminal.shape.constraints;
                    }
                }
            }
            return null;
        };
        
        /**
         * Inverts the elbow edge style without removing existing styles.
         */
        Graph.prototype.flipEdge = function(edge)
        {
            if (edge != null)
            {
                var state = this.view.getState(edge);
                var style = (state != null) ? state.style : this.getCellStyle(edge);
                
                if (style != null)
                {
                    var elbow = mxUtils.getValue(style, mxConstants.STYLE_ELBOW,
                        mxConstants.ELBOW_HORIZONTAL);
                    var value = (elbow == mxConstants.ELBOW_HORIZONTAL) ?
                        mxConstants.ELBOW_VERTICAL : mxConstants.ELBOW_HORIZONTAL;
                    this.setCellStyles(mxConstants.STYLE_ELBOW, value, [edge]);
                }
            }
        };

        /**
         * Disables drill-down for non-swimlanes.
         */
        Graph.prototype.isValidRoot = function(cell)
        {
            // Counts non-relative children
            var childCount = this.model.getChildCount(cell);
            var realChildCount = 0;
            
            for (var i = 0; i < childCount; i++)
            {
                var child = this.model.getChildAt(cell, i);
                
                if (this.model.isVertex(child))
                {
                    var geometry = this.getCellGeometry(child);
                    
                    if (geometry != null && !geometry.relative)
                    {
                        realChildCount++;
                    }
                }
            }
            
            return realChildCount > 0 || this.isContainer(cell);
        };
        
        /**
         * Disables drill-down for non-swimlanes.
         */
        Graph.prototype.isValidDropTarget = function(cell)
        {
            var state = this.view.getState(cell);
            var style = (state != null) ? state.style : this.getCellStyle(cell);
        
            return mxUtils.getValue(style, 'part', '0') != '1' && (this.isContainer(cell) ||
                (mxGraph.prototype.isValidDropTarget.apply(this, arguments) && mxUtils.getValue(style, 'dropTarget', '1') != '0'));
        };
    
        /**
         * Overrides createGroupCell to set the group style for new groups to 'group'.
         */
        Graph.prototype.createGroupCell = function()
        {
            var group = mxGraph.prototype.createGroupCell.apply(this, arguments);
            group.setStyle('group');
            return group;
        };
        
        /**
         * Disables extending parents with stack layouts on add
         */
        Graph.prototype.isExtendParentsOnAdd = function(cell)
        {
            var result = mxGraph.prototype.isExtendParentsOnAdd.apply(this, arguments);
            
            if (result && cell != null && this.layoutManager != null)
            {
                var parent = this.model.getParent(cell);
                
                if (parent != null)
                {
                    var layout = this.layoutManager.getLayout(parent);
                    
                    if (layout != null && layout.constructor == mxStackLayout)
                    {
                        result = false;
                    }
                }
            }
            
            return result;
        };

        /**
         * Overrides autosize to add a border.
         */
        Graph.prototype.getPreferredSizeForCell = function(cell)
        {
            var result = mxGraph.prototype.getPreferredSizeForCell.apply(this, arguments);
            
            // Adds buffer
            if (result != null)
            {
                result.width  += 10;
                result.height += 4;
                
                if (this.gridEnabled)
                {
                    result.width  = this.snap(result.width);
                    result.height = this.snap(result.height);
                }
            }
            
            return result;
        }

        /**
         * Turns the given cells and returns the changed cells.
         */
        Graph.prototype.turnShapes = function(cells)
        {
            var model = this.getModel();
            var select = [];
            
            model.beginUpdate();
            try
            {
                for (var i = 0; i < cells.length; i++)
                {
                    var cell = cells[i];
                    
                    if (model.isEdge(cell))
                    {
                        var src = model.getTerminal(cell, true);
                        var trg = model.getTerminal(cell, false);
                        
                        model.setTerminal(cell, trg, true);
                        model.setTerminal(cell, src, false);
                        
                        var geo = model.getGeometry(cell);
                        
                        if (geo != null)
                        {
                            geo = geo.clone();
                            
                            if (geo.points != null)
                            {
                                geo.points.reverse();
                            }
                            
                            var sp = geo.getTerminalPoint(true);
                            var tp = geo.getTerminalPoint(false);
                            
                            geo.setTerminalPoint(sp, false);
                            geo.setTerminalPoint(tp, true);
                            model.setGeometry(cell, geo);
                            
                            // Inverts constraints
                            var edgeState = this.view.getState(cell);
                            var sourceState = this.view.getState(src);
                            var targetState = this.view.getState(trg);
                            
                            if (edgeState != null)
                            {
                                var sc = (sourceState != null) ? this.getConnectionConstraint(edgeState, sourceState, true) : null;
                                var tc = (targetState != null) ? this.getConnectionConstraint(edgeState, targetState, false) : null;
                                
                                this.setConnectionConstraint(cell, src, true, tc);
                                this.setConnectionConstraint(cell, trg, false, sc);
                            }
        
                            select.push(cell);
                        }
                    }
                    else if (model.isVertex(cell))
                    {
                        var geo = this.getCellGeometry(cell);
            
                        if (geo != null)
                        {
                            // Rotates the size and position in the geometry
                            geo = geo.clone();
                            geo.x += geo.width / 2 - geo.height / 2;
                            geo.y += geo.height / 2 - geo.width / 2;
                            var tmp = geo.width;
                            geo.width = geo.height;
                            geo.height = tmp;
                            model.setGeometry(cell, geo);
                            
                            // Reads the current direction and advances by 90 degrees
                            var state = this.view.getState(cell);
                            
                            if (state != null)
                            {
                                var dir = state.style[mxConstants.STYLE_DIRECTION] || 'east'/*default*/;
                                
                                if (dir == 'east')
                                {
                                    dir = 'south';
                                }
                                else if (dir == 'south')
                                {
                                    dir = 'west';
                                }
                                else if (dir == 'west')
                                {
                                    dir = 'north';
                                }
                                else if (dir == 'north')
                                {
                                    dir = 'east';
                                }
                                
                                this.setCellStyles(mxConstants.STYLE_DIRECTION, dir, [cell]);
                            }
        
                            select.push(cell);
                        }
                    }
                }
            }
            finally
            {
                model.endUpdate();
            }
            
            return select;
        };
        
        /**
         * Returns true if the given stencil contains any placeholder text.
         */
        Graph.prototype.stencilHasPlaceholders = function(stencil)
        {
            if (stencil != null && stencil.fgNode != null)
            {
                var node = stencil.fgNode.firstChild;
                while (node != null)
                {
                    if (node.nodeName == 'text' && node.getAttribute('placeholders') == '1')
                        return true;
                    node = node.nextSibling;
                }
            }
            return false;
        };
        
        /**
         * Updates the child cells with placeholders if metadata of a cell has changed.
         */
        Graph.prototype.processChange = function(change)
        {
           
            mxGraph.prototype.processChange.apply(this, arguments);

            
            
            if (change instanceof mxValueChange && change.cell != null &&
                change.cell.value != null && typeof(change.cell.value) == 'object')
            {
                // Invalidates all descendants with placeholders
                var desc = this.model.getDescendants(change.cell);
                
                // LATER: Check if only label or tooltip have changed
                if (desc.length > 0)
                {
                    for (var i = 0; i < desc.length; i++)
                    {
                        var state = this.view.getState(desc[i]);
                        if (state != null && state.shape != null && state.shape.stencil != null && this.stencilHasPlaceholders(state.shape.stencil))
                            this.removeStateForCell(desc[i]);
                        else if (this.isReplacePlaceholders(desc[i]))
                            this.view.invalidate(desc[i], false, false);
                    }
                }
            }
        };
        
        /**
         * Replaces the given element with a span.
         */
        Graph.prototype.replaceElement = function(elt, tagName)
        {
            //--->fix<----//
            // var span = elt.ownerDocument.createElement((tagName != null) ? tagName : 'span');
            // var attributes = Array.prototype.slice.call(elt.attributes);
            
            // while (attr = attributes.pop())
            // {
            //     span.setAttribute(attr.nodeName, attr.nodeValue);
            // }
            
            // span.innerHTML = elt.innerHTML;
            // elt.parentNode.replaceChild(span, elt);
             //--->fix<----//
        };

        /**
         * 
         */
        Graph.prototype.processElements = function(elt, fn)
        {
            var elts = elt.getElementsByTagName('*');
            
            for (var i = 0; i < elts.length; i++)
            {
                fn(elts[i]);
            }
        };
        
        /**
         * Handles label changes for XML user objects.
         */
        Graph.prototype.updateLabelElements = function(cells, fn, tagName)
        {
            cells = (cells != null) ? cells : this.getSelectionCells();
            var div = document.createElement('div');
            
            for (var i = 0; i < cells.length; i++)
            {
                // Changes font tags inside HTML labels
                if (this.isHtmlLabel(cells[i]))
                {
                    var label = this.convertValueToString(cells[i]);
                    
                    if (label != null && label.length > 0)
                    {
                        div.innerHTML = label;
                        var elts = div.getElementsByTagName((tagName != null) ? tagName : '*');
                        
                        for (var j = 0; j < elts.length; j++)
                        {
                            fn(elts[j]);
                        }
                        
                        if (div.innerHTML != label)
                        {
                            this.cellLabelChanged(cells[i], div.innerHTML);
                        }
                    }
                }
            }
        };
        
        /**
         * Handles label changes for XML user objects.
         */
        Graph.prototype.cellLabelChanged = function(cell, value, autoSize)
        {
            // Removes all illegal control characters in user input
            //value = Graph.zapGremlins(value);

            this.model.beginUpdate();
            try
            {			
                if (cell.value != null && typeof cell.value == 'object')
                {
                    if (this.isReplacePlaceholders(cell) &&
                        cell.getAttribute('placeholder') != null)
                    {
                        // LATER: Handle delete, name change
                        var name = cell.getAttribute('placeholder');
                        var current = cell;
                                
                        while (current != null)
                        {
                            if (current == this.model.getRoot() ||
                                (current.value != null && typeof(current.value) == 'object' && current.hasAttribute(name)))
                            {
                                this.setAttributeForCell(current, name, value);
                                break;
                            }                            
                            current = this.model.getParent(current);
                        }
                    }
                    
                    var tmp = cell.value.cloneNode(true);
                    tmp.setAttribute('label', value);
                    value = tmp;
                }

                mxGraph.prototype.cellLabelChanged.apply(this, arguments);
            }
            finally
            {
                this.model.endUpdate();
            }
        };

        /**
         * Removes transparent empty groups if all children are removed.
         */
        Graph.prototype.cellsRemoved = function(cells)
        {
            if (cells != null)
            {
                var dict = new mxDictionary();
                
                for (var i = 0; i < cells.length; i++)
                {
                    dict.put(cells[i], true);
                }
                
                // LATER: Recurse up the cell hierarchy
                var parents = [];
                
                for (var i = 0; i < cells.length; i++)
                {
                    var parent = this.model.getParent(cells[i]);

                    if (parent != null && !dict.get(parent))
                    {
                        dict.put(parent, true);
                        parents.push(parent);
                    }
                }
                
                for (var i = 0; i < parents.length; i++)
                {
                    var state = this.view.getState(parents[i]);
                    
                    if (state != null && (this.model.isEdge(state.cell) || this.model.isVertex(state.cell)) && this.isCellDeletable(state.cell))
                    {
                        var stroke = mxUtils.getValue(state.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE);
                        var fill = mxUtils.getValue(state.style, mxConstants.STYLE_FILLCOLOR, mxConstants.NONE);
                        
                        if (stroke == mxConstants.NONE && fill == mxConstants.NONE)
                        {
                            var allChildren = true;
                            
                            for (var j = 0; j < this.model.getChildCount(state.cell) && allChildren; j++)
                            {
                                if (!dict.get(this.model.getChildAt(state.cell, j)))
                                {
                                    allChildren = false;
                                }
                            }
                            
                            if (allChildren)
                            {
                                cells.push(state.cell);
                            }
                        }
                    }
                }
            }
            
            mxGraph.prototype.cellsRemoved.apply(this, arguments);
        };
        
        /**
         * Overrides ungroup to check if group should be removed.
         */
        Graph.prototype.removeCellsAfterUngroup = function(cells)
        {
            var cellsToRemove = [];
            
            for (var i = 0; i < cells.length; i++)
            {
                if (this.isCellDeletable(cells[i]))
                {
                    var state = this.view.getState(cells[i]);
                    
                    if (state != null)
                    {
                        var stroke = mxUtils.getValue(state.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE);
                        var fill = mxUtils.getValue(state.style, mxConstants.STYLE_FILLCOLOR, mxConstants.NONE);
                        
                        if (stroke == mxConstants.NONE && fill == mxConstants.NONE)
                        {
                            cellsToRemove.push(cells[i]);
                        }
                    }
                }
            }
            
            cells = cellsToRemove;
            
            mxGraph.prototype.removeCellsAfterUngroup.apply(this, arguments);
        };
        
        /**
         * Sets the link for the given cell.
         */
        Graph.prototype.setLinkForCell = function(cell, link)
        {
            this.setAttributeForCell(cell, 'link', link);
        };
        
        /**
         * Sets the link for the given cell.
         */
        Graph.prototype.setTooltipForCell = function(cell, link)
        {
            this.setAttributeForCell(cell, 'tooltip', link);
        };
        
        Graph.prototype.getAttributeForCell = function(cell, attributeName, defaultValue)
        {
            return (cell.value != null && typeof cell.value === 'object') ?
                (cell.value.getAttribute(attributeName) || defaultValue) :
                defaultValue;
        };
        Graph.prototype.setAttributeForCell = function(cell, attributeName, attributeValue)
        {
            var value = null;
            
            if (cell.value != null && typeof(cell.value) == 'object')
            {
                value = cell.value.cloneNode(true);
            }
            else
            {
                var doc = mxUtils.createXmlDocument();
                
                value = doc.createElement('custom');
                value.setAttribute('label', cell.value || '');
            }
            
            if (attributeValue != null)
            {
                value.setAttribute(attributeName, attributeValue);
            }
            else
            {
                value.removeAttribute(attributeName);
            }
            
            this.model.setValue(cell, value);
        };
        
        /**
         * Overridden to stop moving edge labels between cells.
         */
        Graph.prototype.getDropTarget = function(cells, evt, cell, clone)
        {
            var model = this.getModel();
            
            // Disables drop into group if alt is pressed
            if (mxEvent.isAltDown(evt))
            {
                return null;
            }
            
            // Disables dragging edge labels out of edges
            for (var i = 0; i < cells.length; i++)
            {
                if (this.model.isEdge(this.model.getParent(cells[i])))
                {
                    return null;
                }
            }
            
            return mxGraph.prototype.getDropTarget.apply(this, arguments);
        };
    
        /**
         * Overrides double click handling to avoid accidental inserts of new labels in dblClick below.
         */
        Graph.prototype.click = function(me)
        {
            mxGraph.prototype.click.call(this, me);
            
            // Stores state and source for checking in dblClick
            this.firstClickState = me.getState();
            this.firstClickSource = me.getSource();
        };
        
        /**
         * Overrides double click handling to add the tolerance and inserting text.
         */
        Graph.prototype.dblClick = function(evt, cell)
        {
            if (this.isEnabled())
            {
                var pt = mxUtils.convertPoint(this.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
        
                // Automatically adds new child cells to edges on double click
                if (evt != null && !this.model.isVertex(cell))
                {
                    var state = (this.model.isEdge(cell)) ? this.view.getState(cell) : null;
                    var src = mxEvent.getSource(evt);
                    
                    if ((this.firstClickState == state && this.firstClickSource == src) &&
                        (state == null || (state.text == null || state.text.node == null ||
                        state.text.boundingBox == null || (!mxUtils.contains(state.text.boundingBox,
                        pt.x, pt.y) && !mxUtils.isAncestorNode(state.text.node, mxEvent.getSource(evt))))) &&
                        ((state == null && !this.isCellLocked(this.getDefaultParent())) ||
                        (state != null && !this.isCellLocked(state.cell))) &&
                        (state != null || src == this.view.getCanvas().ownerSVGElement))
                    {
                        cell = this.addText(pt.x, pt.y, state);
                    }
                }
            
                mxGraph.prototype.dblClick.call(this, evt, cell);
            }
        };
        
        /**
         * Returns a point that specifies the location for inserting cells.
         */
        Graph.prototype.getInsertPoint = function()
        {
            var gs = this.getGridSize();
            var dx = this.container.scrollLeft / this.view.scale - this.view.translate.x;
            var dy = this.container.scrollTop / this.view.scale - this.view.translate.y;
            
            if (this.pageVisible)
            {
                var layout = this.getPageLayout();
                var page = this.getPageSize();
                dx = Math.max(dx, layout.x * page.width);
                dy = Math.max(dy, layout.y * page.height);
            }
            
            return new mxPoint(this.snap(dx + gs), this.snap(dy + gs));
        };
        
        /**
         * 
         */
        Graph.prototype.getFreeInsertPoint = function()
        {
            var view = this.view;
            var bds = this.getGraphBounds();
            var pt = this.getInsertPoint();
            
            // Places at same x-coord and 2 grid sizes below existing graph
            var x = this.snap(Math.round(Math.max(pt.x, bds.x / view.scale - view.translate.x +
                ((bds.width == 0) ? 2 * this.gridSize : 0))));
            var y = this.snap(Math.round(Math.max(pt.y, (bds.y + bds.height) / view.scale - view.translate.y +
                2 * this.gridSize)));
            
            return new mxPoint(x, y);
        };
        
        /**
         * Hook for subclassers to return true if the current insert point was defined
         * using a mouse hover event.
         */
        Graph.prototype.isMouseInsertPoint = function()
        {			
            return false;
        };
        
        /**
         * Adds a new label at the given position and returns the new cell. State is
         * an optional edge state to be used as the parent for the label. Vertices
         * are not allowed currently as states.
         */
        Graph.prototype.addText = function(x, y, state)
        {
            // Creates a new edge label with a predefined text
            var label = new mxCell();
            label.value       = 'Текст';
            label.style       = 'text;html=1;resizable=0;points=[];';
            label.geometry    = new mxGeometry(0, 0, 0, 0);
            label.vertex      = true;
            
            if (state != null)
            {
                label.style += 'align=center;verticalAlign=middle;';
                label.geometry.relative = true;
                label.connectable = false;

                // Resets the relative location stored inside the geometry
                var pt2 = this.view.getRelativePoint(state, x, y);
                label.geometry.x = Math.round(pt2.x * 10000) / 10000;
                label.geometry.y = Math.round(pt2.y);
                
                // Resets the offset inside the geometry to find the offset from the resulting point
                label.geometry.offset = new mxPoint(0, 0);
                pt2 = this.view.getPoint(state, label.geometry);
            
                var scale = this.view.scale;
                label.geometry.offset = new mxPoint(Math.round((x - pt2.x) / scale), Math.round((y - pt2.y) / scale));
            }
            else
            {
                label.style += 'strokeColor=none;fillColor=none;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;';
                // make resizable
                label.style = mxUtils.setStyle(label.style, 'resizable');
                // make connectable
                label.style = mxUtils.setStyle(label.style, 'points');

                var tr = this.view.translate;
                label.geometry.width  = 40;
                label.geometry.height = 20;
                label.geometry.x = Math.round(x / this.view.scale) - tr.x;
                label.geometry.y = Math.round(y / this.view.scale) - tr.y;
            }
                
            this.getModel().beginUpdate();
            try
            {
                this.addCells([label], (state != null) ? state.cell : null);
                this.fireEvent(new mxEventObject('textInserted', 'cells', [label]));
                // Updates size of text after possible change of style via event
                this.autoSizeCell(label);
            }
            finally
            {
                this.getModel().endUpdate();
            }
            
            return label;
        };

        /**
         * Adds a handler for clicking on shapes with links. This replaces all links in labels.
         */
        Graph.prototype.addClickHandler = function(beforeClick, onClick)
        {
            // Replaces links in labels for consistent right-clicks
            var checkLinks = mxUtils.bind(this, function()
            {
                var links = this.container.getElementsByTagName('a');
                
                if (links != null)
                {
                    for (var i = 0; i < links.length; i++)
                    {
                        var href = this.getAbsoluteUrl(links[i].getAttribute('href'));
                        
                        if (href != null)
                        {
                            links[i].setAttribute('rel', this.linkRelation);
                            links[i].setAttribute('href', href);
                            
                            if (beforeClick != null)
                            {
                                mxEvent.addGestureListeners(links[i], null, null, beforeClick);
                            }
                        }
                    }
                }
            });
            
            this.model.addListener(mxEvent.CHANGE, checkLinks);
            checkLinks();
            
            var cursor = this.container.style.cursor;
            var tol = this.getTolerance();
            var graph = this;

            var mouseListener =
            {
                currentState: null,
                currentLink: null,
                highlight: new mxCellHighlight(graph, '#5b5b5b', 4),
                startX: 0,
                startY: 0,
                scrollLeft: 0,
                scrollTop: 0,
                updateCurrentState: function(me)
                {
                    var tmp = me.sourceState;
                    
                    // Gets topmost intersecting cell with link
                    if (tmp == null || graph.getLinkForCell(tmp.cell) == null)
                    {
                        var cell = graph.getCellAt(me.getGraphX(), me.getGraphY(), null, null, null, function(state, x, y)
                        {
                            return graph.getLinkForCell(state.cell) == null;
                        });
                        
                        tmp = graph.view.getState(cell);
                    }
                    
                    if (tmp != this.currentState)
                    {
                        if (this.currentState != null)
                        {
                            this.clear();
                        }
                        
                        this.currentState = tmp;
                        
                        if (this.currentState != null)
                        {
                            this.activate(this.currentState);
                        }
                    }
                },
                mouseDown: function(sender, me)
                {
                    this.startX = me.getGraphX();
                    this.startY = me.getGraphY();
                    this.scrollLeft = graph.container.scrollLeft;
                    this.scrollTop = graph.container.scrollTop;
                    
                    if (this.currentLink == null &&
                        graph.container.style.overflow == 'auto' &&
                        mxEvent.isMiddleMouseButton(me.getEvent()))
                    {
                        graph.container.style.cursor = 'move';
                    }
                    
                    this.updateCurrentState(me);
                },
                mouseMove: function(sender, me)
                {
                    if (graph.isMouseDown)
                    {
                        if (this.currentLink != null)
                        {
                            var dx = Math.abs(this.startX - me.getGraphX());
                            var dy = Math.abs(this.startY - me.getGraphY());
                            
                            if (dx > tol || dy > tol)
                            {
                                this.clear();
                            }
                        }
                    }
                    else
                    {
                        // Checks for parent link
                        var linkNode = me.getSource();
                        
                        while (linkNode != null && linkNode.nodeName.toLowerCase() != 'a')
                        {
                            linkNode = linkNode.parentNode;
                        }
                        
                        if (linkNode != null)
                        {
                            this.clear();
                        }
                        else
                        {
                            if (graph.tooltipHandler != null && this.currentLink != null && this.currentState != null)
                            {
                                graph.tooltipHandler.reset(me, true, this.currentState);
                            }
                            
                            if (this.currentState != null && (me.getState() == this.currentState || me.sourceState == null) &&
                                graph.intersects(this.currentState, me.getGraphX(), me.getGraphY()))
                            {
                                return;
                            }
                            
                            this.updateCurrentState(me);
                        }
                    }
                },
                mouseUp: function(sender, me)
                {
                    var source = me.getSource();
                    var evt = me.getEvent();
                    
                    // Checks for parent link
                    var linkNode = source;
                    
                    while (linkNode != null && linkNode.nodeName.toLowerCase() != 'a')
                    {
                        linkNode = linkNode.parentNode;
                    }
                    
                    // Ignores clicks on links and collapse/expand icon
                    if (linkNode == null &&
                        (((Math.abs(this.scrollLeft - graph.container.scrollLeft) < tol &&
                        Math.abs(this.scrollTop - graph.container.scrollTop) < tol) &&
                        (me.sourceState == null || !me.isSource(me.sourceState.control))) &&
                        (((mxEvent.isLeftMouseButton(evt) || mxEvent.isMiddleMouseButton(evt)) &&
                        !mxEvent.isPopupTrigger(evt)) || mxEvent.isTouchEvent(evt))))
                    {
                        if (this.currentLink != null)
                        {
                            var blank = graph.isBlankLink(this.currentLink);
                            
                            if ((this.currentLink.substring(0, 5) === 'data:' || !blank) && beforeClick != null)
                                beforeClick(evt, this.currentLink);

                            
                            if (!mxEvent.isConsumed(evt))
                            {
                                var target = (mxEvent.isMiddleMouseButton(evt)) ? '_blank' : ((blank) ? graph.linkTarget : '_top');
                                graph.openLink(this.currentLink, target);
                                me.consume();
                            }
                        }
                        else if (onClick != null && !me.isConsumed() &&
                            (Math.abs(this.scrollLeft - graph.container.scrollLeft) < tol &&
                            Math.abs(this.scrollTop - graph.container.scrollTop) < tol) &&
                            (Math.abs(this.startX - me.getGraphX()) < tol &&
                            Math.abs(this.startY - me.getGraphY()) < tol))
                        {
                            onClick(me.getEvent());
                        }
                    }
                    
                    this.clear();
                },
                activate: function(state)
                {
                    this.currentLink = graph.getAbsoluteUrl(graph.getLinkForCell(state.cell));

                    if (this.currentLink != null)
                    {
                        graph.container.style.cursor = 'pointer';

                        if (this.highlight != null)
                        {
                            this.highlight.highlight(state);
                        }
                    }
                },
                clear: function()
                {
                    if (graph.container != null)
                    {
                        graph.container.style.cursor = cursor;
                    }
                    
                    this.currentState = null;
                    this.currentLink = null;
                    
                    if (this.highlight != null)
                    {
                        this.highlight.hide();
                    }
                    
                    if (graph.tooltipHandler != null)
                    {
                        graph.tooltipHandler.hide();
                    }
                }
            };

            // Ignores built-in click handling
            //graph.click = function(me) {};
            graph.addMouseListener(mouseListener);
            
            mxEvent.addListener(document, 'mouseleave', function(evt)
            {
                mouseListener.clear();
            });
        };
        
        /**
         * Duplicates the given cells and returns the duplicates.
         */
        Graph.prototype.duplicateCells = function(cells, append)
        {
            cells = (cells != null) ? cells : this.getSelectionCells();
            append = (append != null) ? append : true;
            
            cells = this.model.getTopmostCells(cells);
            
            var model = this.getModel();
            var s = this.gridSize;
            var select = [];
            
            model.beginUpdate();
            try
            {
                var clones = this.cloneCells(cells, false, null, true);
                
                for (var i = 0; i < cells.length; i++)
                {
                    var parent = model.getParent(cells[i]);
                    var child = this.moveCells([clones[i]], s, s, false)[0];
                    select.push(child);
                    
                    if (append)
                    {
                        model.add(parent, clones[i]);
                    }
                    else
                    {
                        // Maintains child index by inserting after clone in parent
                        var index = parent.getIndex(cells[i]);
                        model.add(parent, clones[i], index + 1);
                    }
                }
            }
            finally
            {
                model.endUpdate();
            }
            
            return select;
        };
        
        /**
         * Inserts the given image at the cursor in a content editable text box using
         * the insertimage command on the document instance.
         */
        Graph.prototype.insertImage = function(newValue, w, h)
        {
            // To find the new image, we create a list of all existing links first
            if (newValue != null && this.cellEditor.textarea != null)
            {
                var tmp = this.cellEditor.textarea.getElementsByTagName('img');
                var oldImages = [];
                
                for (var i = 0; i < tmp.length; i++)
                {
                    oldImages.push(tmp[i]);
                }
                
                document.execCommand('insertimage', false, newValue);
                
                // Sets size of new image
                var newImages = this.cellEditor.textarea.getElementsByTagName('img');
                
                if (newImages.length == oldImages.length + 1)
                {
                    // Inverse order in favor of appended images
                    for (var i = newImages.length - 1; i >= 0; i--)
                    {
                        if (i == 0 || newImages[i] != oldImages[i - 1])
                        {
                            // Workaround for lost styles during undo and redo is using attributes
                            newImages[i].setAttribute('width', w);
                            newImages[i].setAttribute('height', h);
                            
                            break;
                        }
                    }
                }
            }
        };
                
        /**
         * Inserts the given image at the cursor in a content editable text box using
         * the insertimage command on the document instance.
         */
        Graph.prototype.insertLink = function(value)
        {
            if (this.cellEditor.textarea != null)
            {
                if (value.length == 0)
                {
                    document.execCommand('unlink', false);
                }
                else if (mxClient.IS_FF)
                {
                    // Workaround for Firefox that adds a new link and removes
                    // the href from the inner link if its parent is a span is
                    // to remove all inner links inside the new outer link
                    var tmp = this.cellEditor.textarea.getElementsByTagName('a');
                    var oldLinks = [];
                    
                    for (var i = 0; i < tmp.length; i++)
                    {
                        oldLinks.push(tmp[i]);
                    }
                    
                    document.execCommand('createlink', false, mxUtils.trim(value));
                    
                    // Finds the new link element
                    var newLinks = this.cellEditor.textarea.getElementsByTagName('a');
                    
                    if (newLinks.length == oldLinks.length + 1)
                    {
                        // Inverse order in favor of appended links
                        for (var i = newLinks.length - 1; i >= 0; i--)
                        {
                            if (newLinks[i] != oldLinks[i - 1])
                            {
                                // Removes all inner links from the new link and
                                // moves the children to the inner link parent
                                var tmp = newLinks[i].getElementsByTagName('a');
                                
                                while (tmp.length > 0)
                                {
                                    var parent = tmp[0].parentNode;
                                    
                                    while (tmp[0].firstChild != null)
                                    {
                                        parent.insertBefore(tmp[0].firstChild, tmp[0]);
                                    }
                                    
                                    parent.removeChild(tmp[0]);
                                }
                                
                                break;
                            }
                        }
                    }
                }
                else
                {
                    document.execCommand('createlink', false, mxUtils.trim(value));
                }
            }
        };

        Graph.prototype.isCellResizable = function(cell)
        {
            var result = mxGraph.prototype.isCellResizable.apply(this, arguments);
        
            var state = this.view.getState(cell);
            var style = (state != null) ? state.style : this.getCellStyle(cell);
                
            return result || (mxUtils.getValue(style, mxConstants.STYLE_RESIZABLE, '1') != '0' &&
                style[mxConstants.STYLE_WHITE_SPACE] == 'wrap');
        };
        
        /**
         * Function: distributeCells
         * 
         * Distribuets the centers of the given cells equally along the available
         * horizontal or vertical space.
         * 
         * Parameters:
         * 
         * horizontal - Boolean that specifies the direction of the distribution.
         * cells - Optional array of <mxCells> to be distributed. Edges are ignored.
         */
        Graph.prototype.distributeCells = function(horizontal, cells)
        {
            if (cells == null)
            {
                cells = this.getSelectionCells();
            }
            
            if (cells != null && cells.length > 1)
            {
                var vertices = [];
                var max = null;
                var min = null;
                
                for (var i = 0; i < cells.length; i++)
                {
                    if (this.getModel().isVertex(cells[i]))
                    {
                        var state = this.view.getState(cells[i]);
                        
                        if (state != null)
                        {
                            var tmp = (horizontal) ? state.getCenterX() : state.getCenterY();
                            max = (max != null) ? Math.max(max, tmp) : tmp;
                            min = (min != null) ? Math.min(min, tmp) : tmp;
                            
                            vertices.push(state);
                        }
                    }
                }
                
                if (vertices.length > 2)
                {
                    vertices.sort(function(a, b)
                    {
                        return (horizontal) ? a.x - b.x : a.y - b.y;
                    });
        
                    var t = this.view.translate;
                    var s = this.view.scale;
                    
                    min = min / s - ((horizontal) ? t.x : t.y);
                    max = max / s - ((horizontal) ? t.x : t.y);
                    
                    this.getModel().beginUpdate();
                    try
                    {
                        var dt = (max - min) / (vertices.length - 1);
                        var t0 = min;
                        
                        for (var i = 1; i < vertices.length - 1; i++)
                        {
                            var pstate = this.view.getState(this.model.getParent(vertices[i].cell));
                            var geo = this.getCellGeometry(vertices[i].cell);
                            t0 += dt;
                            
                            if (geo != null && pstate != null)
                            {
                                geo = geo.clone();
                                
                                if (horizontal)
                                {
                                    geo.x = Math.round(t0 - geo.width / 2) - pstate.origin.x;
                                }
                                else
                                {
                                    geo.y = Math.round(t0 - geo.height / 2) - pstate.origin.y;
                                }
                                
                                this.getModel().setGeometry(vertices[i].cell, geo);
                            }
                        }
                    }
                    finally
                    {
                        this.getModel().endUpdate();
                    }
                }
            }
            
            return cells;
        };
        
        /**
         * Adds meta-drag an Mac.
         * @param evt
         */
        Graph.prototype.isCloneEvent = function(evt)
        {
            return (mxClient.IS_MAC && mxEvent.isMetaDown(evt)) || mxEvent.isControlDown(evt);
        };
        
        /**
         * Translates this point by the given vector.
         * 
         * @param {number} dx X-coordinate of the translation.
         * @param {number} dy Y-coordinate of the translation.
         */
        Graph.prototype.encodeCells = function (cells)
        {
            var cloneMap = new Object();
            var clones = this.cloneCells(cells, null, cloneMap);

            // Creates a dictionary for fast lookups
            var dict = new mxDictionary();

            for (var i = 0; i < cells.length; i++)
            {
                dict.put(cells[i], true);
            }

            // Checks for orphaned relative children and makes absolute
            for (var i = 0; i < clones.length; i++)
            {
                var state = this.view.getState(cells[i]);

                if (state != null)
                {
                    var geo = this.getCellGeometry(clones[i]);

                    if (geo != null && geo.relative && !this.model.isEdge(cells[i]) &&
                        !dict.get(this.model.getParent(cells[i])))
                    {
                        geo.relative = false;
                        geo.x = state.x / state.view.scale - state.view.translate.x;
                        geo.y = state.y / state.view.scale - state.view.translate.y;
                    }
                }
            }

            var codec = new mxCodec();
            var model = new mxGraphModel();
            var parent = model.getChildAt(model.getRoot(), 0);

            for (var i = 0; i < clones.length; i++)
            {
                model.add(parent, clones[i]);
            }

            this.updateCustomLinks(this.createCellMapping(cloneMap,
                this.createCellLookup(cells)), clones);

            return codec.encode(model);
        };

		/**
		 * Overrides cloning cells in moveCells.
		 */
        var graphMoveCells = Graph.prototype.moveCells;
        Graph.prototype.moveCells = function (cells, dx, dy, clone, target, evt, mapping)
        {
            mapping = (mapping != null) ? mapping : new Object();
            var result = graphMoveCells.apply(this, arguments);

            if (clone)
            {
                this.updateCustomLinks(this.createCellMapping(mapping,
                    this.createCellLookup(cells)), result);
            }

            return result;
        };

		/**
		 * Updates cells IDs for custom links in the given cells.
		 */
        Graph.prototype.updateCustomLinks = function (mapping, cells)
        {
            for (var i = 0; i < cells.length; i++)
            {
                if (cells[i] != null)
                {
                    this.updateCustomLinksForCell(mapping, cells[i]);
                }
            }
        };

		/**
		 * Updates cell IDs in custom links on the given cell and its label.
		 */
        Graph.prototype.updateCustomLinksForCell = function (mapping, cell)
        {
            // Hook for subclassers
        };

        Graph.prototype.createSvgImageExport = function()
        {
            var exp = new mxImageExport();
            
            // Adds hyperlinks (experimental)
            exp.getLinkForCellState = mxUtils.bind(this, function(state, canvas)
            {
                return this.getLinkForCell(state.cell);
            });

            return exp;
        };
        Graph.prototype.getSvg = function(background, scale, border, nocrop, crisp, ignoreSelection, showText, imgExport, linkTarget, hasShadow)
        {
            //Disable Css Transforms if it is used
            var origUseCssTrans = this.useCssTransforms;
            
            if (origUseCssTrans) 
            {
                this.useCssTransforms = false;
                this.view.revalidate();
                this.sizeDidChange();
            }

            try 
            {
                scale = (scale != null) ? scale : 1;
                border = (border != null) ? border : 0;
                crisp = (crisp != null) ? crisp : true;
                ignoreSelection = (ignoreSelection != null) ? ignoreSelection : true;
                showText = (showText != null) ? showText : true;
    
                var bounds = (ignoreSelection || nocrop) ?
                        this.getGraphBounds() : this.getBoundingBox(this.getSelectionCells());
    
                if (bounds == null)
                {
                    throw Error(mxResources.get('drawingEmpty'));
                }
    
                var vs = this.view.scale;
                
                // Prepares SVG document that holds the output
                var svgDoc = mxUtils.createXmlDocument();
                var root = (svgDoc.createElementNS != null) ?
                    svgDoc.createElementNS(mxConstants.NS_SVG, 'svg') : svgDoc.createElement('svg');
                
                if (background != null)
                {
                    if (root.style != null)
                    {
                        root.style.backgroundColor = background;
                    }
                    else
                    {
                        root.setAttribute('style', 'background-color:' + background);
                    }
                }
                
                if (svgDoc.createElementNS == null)
                {
                    root.setAttribute('xmlns', mxConstants.NS_SVG);
                    root.setAttribute('xmlns:xlink', mxConstants.NS_XLINK);
                }
                else
                {
                    // KNOWN: Ignored in IE9-11, adds namespace for each image element instead. No workaround.
                    root.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xlink', mxConstants.NS_XLINK);
                }
                
                var s = scale / vs;
                var w = Math.max(1, Math.ceil(bounds.width * s) + 2 * border) + ((hasShadow) ? 5 : 0);
                var h = Math.max(1, Math.ceil(bounds.height * s) + 2 * border) + ((hasShadow) ? 5 : 0);
                
                root.setAttribute('version', '1.1');
                root.setAttribute('width', w + 'px');
                root.setAttribute('height', h + 'px');
                root.setAttribute('viewBox', ((crisp) ? '-0.5 -0.5' : '0 0') + ' ' + w + ' ' + h);
                svgDoc.appendChild(root);
            
                // Renders graph. Offset will be multiplied with state's scale when painting state.
                // TextOffset only seems to affect FF output but used everywhere for consistency.
                var group = (svgDoc.createElementNS != null) ?
                    svgDoc.createElementNS(mxConstants.NS_SVG, 'g') : svgDoc.createElement('g');
                root.appendChild(group);

                var svgCanvas = this.createSvgCanvas(group);
                svgCanvas.foOffset = (crisp) ? -0.5 : 0;
                svgCanvas.textOffset = (crisp) ? -0.5 : 0;
                svgCanvas.imageOffset = (crisp) ? -0.5 : 0;
                svgCanvas.translate(Math.floor((border / scale - bounds.x) / vs),
                    Math.floor((border / scale - bounds.y) / vs));
                
                // Convert HTML entities
                var htmlConverter = document.createElement('textarea');
                
                // Adds simple text fallback for viewers with no support for foreignObjects
                var createAlternateContent = svgCanvas.createAlternateContent;
                svgCanvas.createAlternateContent = function(fo, x, y, w, h, str, align, valign, wrap, format, overflow, clip, rotation)
                {
                    var s = this.state;
    
                    // Assumes a max character width of 0.2em
                    if (this.foAltText != null && (w == 0 || (s.fontSize != 0 && str.length < (w * 5) / s.fontSize)))
                    {
                        var alt = this.createElement('text');
                        alt.setAttribute('x', Math.round(w / 2));
                        alt.setAttribute('y', Math.round((h + s.fontSize) / 2));
                        alt.setAttribute('fill', s.fontColor || 'black');
                        alt.setAttribute('text-anchor', 'middle');
                        alt.setAttribute('font-size', Math.round(s.fontSize) + 'px');
                        alt.setAttribute('font-family', s.fontFamily);
                        
                        if ((s.fontStyle & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)
                        {
                            alt.setAttribute('font-weight', 'bold');
                        }
                        
                        if ((s.fontStyle & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)
                        {
                            alt.setAttribute('font-style', 'italic');
                        }
                        
                        if ((s.fontStyle & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)
                        {
                            alt.setAttribute('text-decoration', 'underline');
                        }
                        
                        try
                        {
                            htmlConverter.innerHTML = str;
                            alt.textContent = htmlConverter.value;
                            
                            return alt;
                        }
                        catch (e)
                        {
                            return createAlternateContent.apply(this, arguments);
                        }
                    }
                    else
                    {
                        return createAlternateContent.apply(this, arguments);
                    }
                };
                
                // Paints background image
                var bgImg = this.backgroundImage;
                
                if (bgImg != null)
                {
                    var s2 = vs / scale;
                    var tr = this.view.translate;
                    var tmp = new mxRectangle(tr.x * s2, tr.y * s2, bgImg.width * s2, bgImg.height * s2);
                    
                    // Checks if visible
                    if (mxUtils.intersects(bounds, tmp))
                    {
                        svgCanvas.image(tr.x, tr.y, bgImg.width, bgImg.height, bgImg.src, true);
                    }
                }
                
                svgCanvas.scale(s);
                svgCanvas.textEnabled = showText;
                
                imgExport = (imgExport != null) ? imgExport : this.createSvgImageExport();
                var imgExportDrawCellState = imgExport.drawCellState;

                // Ignores custom links
                var imgExportGetLinkForCellState = imgExport.getLinkForCellState;
                
                imgExport.getLinkForCellState = function(state, canvas)
                {
                    var result = imgExportGetLinkForCellState.apply(this, arguments);
                    
                    return (result != null && !state.view.graph.isCustomLink(result)) ? result : null;
                };
                
                // Implements ignoreSelection flag
                imgExport.drawCellState = function(state, canvas)
                {
                    var graph = state.view.graph;
                    var selected = graph.isCellSelected(state.cell);
                    var parent = graph.model.getParent(state.cell);
                    
                    // Checks if parent cell is selected
                    while (!ignoreSelection && !selected && parent != null)
                    {
                        selected = graph.isCellSelected(parent);
                        parent = graph.model.getParent(parent);
                    }
                    
                    if (ignoreSelection || selected)
                    {
                        imgExportDrawCellState.apply(this, arguments);
                    }
                };
    
                imgExport.drawState(this.getView().getState(this.model.root), svgCanvas);
                this.updateSvgLinks(root, linkTarget, true);
            
                return root;
            }
            finally
            {
                if (origUseCssTrans) 
                {
                    this.useCssTransforms = true;
                    this.view.revalidate();
                    this.sizeDidChange();
                }
            }
        };
        Graph.prototype.updateSvgLinks = function(node, target, removeCustom)
        {
            var links = node.getElementsByTagName('a');
            
            for (var i = 0; i < links.length; i++)
            {
                var href = links[i].getAttribute('href');
                
                if (href == null)
                {
                    href = links[i].getAttribute('xlink:href');
                }
                
                if (href != null)
                {
                    if (target != null && /^https?:\/\//.test(href))
                    {
                        links[i].setAttribute('target', target);
                    }
                    else if (removeCustom && this.isCustomLink(href))
                    {
                        links[i].setAttribute('href', 'javascript:void(0);');
                    }
                }
            }
        };
        Graph.prototype.createSvgCanvas = function(node)
        {
            var canvas = new mxSvgCanvas2D(node);
            canvas.pointerEvents = true;
            return canvas;
        };
        
        /**
         * Returns the first ancestor of the current selection with the given name.
         */
        Graph.prototype.getSelectedElement = function()
        {
            var node = null;
            
            if (window.getSelection)
            {
                var sel = window.getSelection();
                
                if (sel.getRangeAt && sel.rangeCount)
                {
                    var range = sel.getRangeAt(0);
                    node = range.commonAncestorContainer;
                }
            }
            else if (document.selection)
            {
                node = document.selection.createRange().parentElement();
            }
            
            return node;
        };
        
        /**
         * Returns the first ancestor of the current selection with the given name.
         */
        Graph.prototype.getParentByName = function(node, name, stopAt)
        {
            while (node != null)
            {
                if (node.nodeName == name)
                {
                    return node;
                }
        
                if (node == stopAt)
                {
                    return null;
                }
                
                node = node.parentNode;
            }
            
            return node;
        };
        
        /**
         * Returns the first ancestor of the current selection with the given name.
         */
        Graph.prototype.getParentByNames = function(node, names, stopAt)
        {
            while (node != null)
            {
                if (mxUtils.indexOf(names, node.nodeName) >= 0)
                {
                    return node;
                }
        
                if (node == stopAt)
                {
                    return null;
                }
                
                node = node.parentNode;
            }
            
            return node;
        };
        
        /**
         * Selects the given node.
         */
        Graph.prototype.selectNode = function(node)
        {
            var sel = null;
            
            // IE9 and non-IE
            if (window.getSelection)
            {
                sel = window.getSelection();
                
                if (sel.getRangeAt && sel.rangeCount)
                {
                    var range = document.createRange();
                    range.selectNode(node);
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
            }
            // IE < 9
            else if ((sel = document.selection) && sel.type != 'Control')
            {
                var originalRange = sel.createRange();
                originalRange.collapse(true);
                var range = sel.createRange();
                range.setEndPoint('StartToStart', originalRange);
                range.select();
            }
        };
        
        /**
         * Inserts a new row into the given table.
         */
        Graph.prototype.insertRow = function(table, index)
        {
            var bd = table.tBodies[0];
            var cells = bd.rows[0].cells;
            var cols = 0;
            
            // Counts columns including colspans
            for (var i = 0; i < cells.length; i++)
            {
                var colspan = cells[i].getAttribute('colspan');
                cols += (colspan != null) ? parseInt(colspan) : 1;
            }
            
            var row = bd.insertRow(index);
            
            for (var i = 0; i < cols; i++)
            {
                mxUtils.br(row.insertCell(-1));
            }
            
            return row.cells[0];
        };
        
        /**
         * Deletes the given column.
         */
        Graph.prototype.deleteRow = function(table, index)
        {
            table.tBodies[0].deleteRow(index);
        };
        
        /**
         * Deletes the given column.
         */
        Graph.prototype.insertColumn = function(table, index)
        {
            var hd = table.tHead;
            
            if (hd != null)
            {
                // TODO: use colIndex
                for (var h = 0; h < hd.rows.length; h++)
                {
                    var th = document.createElement('th');
                    hd.rows[h].appendChild(th);
                    mxUtils.br(th);
                }
            }
        
            var bd = table.tBodies[0];
            
            for (var i = 0; i < bd.rows.length; i++)
            {
                var cell = bd.rows[i].insertCell(index);
                mxUtils.br(cell);
            }
            
            return bd.rows[0].cells[(index >= 0) ? index : bd.rows[0].cells.length - 1];
        };
        
        /**
         * Deletes the given column.
         */
        Graph.prototype.deleteColumn = function(table, index)
        {
            if (index >= 0)
            {
                var bd = table.tBodies[0];
                var rows = bd.rows;
                
                for (var i = 0; i < rows.length; i++)
                {
                    if (rows[i].cells.length > index)
                    {
                        rows[i].deleteCell(index);
                    }
                }
            }
        };
        
        /**
         * Inserts the given HTML at the caret position (no undo).
         */
        Graph.prototype.pasteHtmlAtCaret = function(html)
        {
            //--->fix<---//
            // var sel, range;
        
            // // IE9 and non-IE
            // if (window.getSelection)
            // {
            //     sel = window.getSelection();
                
            //     if (sel.getRangeAt && sel.rangeCount)
            //     {
            //         range = sel.getRangeAt(0);
            //         range.deleteContents();
        
            //         // Range.createContextualFragment() would be useful here but is
            //         // only relatively recently standardized and is not supported in
            //         // some browsers (IE9, for one)
            //         var el = document.createElement("div");
            //         el.innerHTML = html;
            //         var frag = document.createDocumentFragment(), node;
                    
            //         while ((node = el.firstChild))
            //         {
            //             lastNode = frag.appendChild(node);
            //         }
                    
            //         range.insertNode(frag);
            //     }
            // }
            // // IE < 9
            // else if ((sel = document.selection) && sel.type != "Control")
            // {
            //     // FIXME: Does not work if selection is empty
            //     sel.createRange().pasteHTML(html);
            // }
              //--->fix<---//
        };
    
        /**
         * Creates an anchor elements for handling the given link in the
         * hint that is shown when the cell is selected.
         */
        Graph.prototype.createLinkForHint = function(link, label)
        {
            link = (link != null) ? link : 'javascript:void(0);';

            if (label == null || label.length == 0)
            {
                if (this.isCustomLink(link))
                {
                    label = this.getLinkTitle(link);
                }
                else
                {
                    label = link;
                }
            }

            // Helper function to shorten strings
            function short(str, max)
            {
                if (str.length > max)
                {
                    str = str.substring(0, Math.round(max / 2)) + '...' +
                        str.substring(str.length - Math.round(max / 4));
                }
                
                return str;
            };
            
            var a = document.createElement('a');
            a.setAttribute('rel', this.linkRelation);
            a.setAttribute('href', this.getAbsoluteUrl(link));
            a.setAttribute('title', short((this.isCustomLink(link)) ? this.getLinkTitle(link) : link, 80));
            
            if (this.linkTarget != null)
                a.setAttribute('target', this.linkTarget);
            
            // Adds shortened label to link
            mxUtils.write(a, short(label, 40));
            
            // Handles custom links
            if (this.isCustomLink(link))
            {
                mxEvent.addListener(a, 'click', mxUtils.bind(this, function(evt)
                {
                    this.customLinkClicked(link);
                    mxEvent.consume(evt);
                }));
            }
            
            return a;
        };
        
        /**
         * Customized graph for touch devices.
         */
        Graph.prototype.initTouch = function()
        {
            // Disables new connections via "hotspot"
            this.connectionHandler.marker.isEnabled = function()
            {
                return this.graph.connectionHandler.first != null;
            };
        
            // Hides menu when editing starts
            this.addListener(mxEvent.START_EDITING, function(sender, evt)
            {
                this.popupMenuHandler.hideMenu();
            });
        
            // Adds custom hit detection if native hit detection found no cell
            var graphUpdateMouseEvent = this.updateMouseEvent;
            this.updateMouseEvent = function(me)
            {
                me = graphUpdateMouseEvent.apply(this, arguments);
    
                if (mxEvent.isTouchEvent(me.getEvent()) && me.getState() == null)
                {
                    var cell = this.getCellAt(me.graphX, me.graphY);
        
                    if (cell != null && this.isSwimlane(cell) && this.hitsSwimlaneContent(cell, me.graphX, me.graphY))
                    {
                        cell = null;
                    }
                    else
                    {
                        me.state = this.view.getState(cell);
                        
                        if (me.state != null && me.state.shape != null)
                        {
                            this.container.style.cursor = me.state.shape.node.style.cursor;
                        }
                    }
                }
                
                if (me.getState() == null && this.isEnabled())
                {
                    this.container.style.cursor = 'default';
                }
                
                return me;
            };
        
            // Context menu trigger implementation depending on current selection state
            // combined with support for normal popup trigger.
            var cellSelected = false;
            var selectionEmpty = false;
            var menuShowing = false;
            
            var oldFireMouseEvent = this.fireMouseEvent;
            
            this.fireMouseEvent = function(evtName, me, sender)
            {
                if (evtName == mxEvent.MOUSE_DOWN)
                {
                    // For hit detection on edges
                    me = this.updateMouseEvent(me);
                    
                    cellSelected = this.isCellSelected(me.getCell());
                    selectionEmpty = this.isSelectionEmpty();
                    menuShowing = this.popupMenuHandler.isMenuShowing();
                }
                
                oldFireMouseEvent.apply(this, arguments);
            };
            
            // Shows popup menu if cell was selected or selection was empty and background was clicked
            // FIXME: Conflicts with mxPopupMenuHandler.prototype.getCellForPopupEvent in Editor.js by
            // selecting parent for selected children in groups before this check can be made.
            this.popupMenuHandler.mouseUp = mxUtils.bind(this, function(sender, me)
            {
                this.popupMenuHandler.popupTrigger = !this.isEditing() && this.isEnabled() &&
                    (me.getState() == null || !me.isSource(me.getState().control)) &&
                    (this.popupMenuHandler.popupTrigger || (!menuShowing && !mxEvent.isMouseEvent(me.getEvent()) &&
                    ((selectionEmpty && me.getCell() == null && this.isSelectionEmpty()) ||
                    (cellSelected && this.isCellSelected(me.getCell())))));
                mxPopupMenuHandler.prototype.mouseUp.apply(this.popupMenuHandler, arguments);
            });
        };
        
        /**
         * HTML in-place editor
         */
        mxCellEditor.prototype.isContentEditing = function()
        {
            var state = this.graph.view.getState(this.editingCell);
            
            return state != null && state.style['html'] == 1;
        };

        /**
         * Returns true if all selected text is inside a table element.
         */
        mxCellEditor.prototype.isTableSelected = function()
        {
            return this.graph.getParentByName(
                this.graph.getSelectedElement(),
                'TABLE', this.textarea) != null;
        };
        
        /**
         * Sets the alignment of the current selected cell. This sets the
         * alignment in the cell style, removes all alignment within the
         * text and invokes the built-in alignment function.
         * 
         * Only the built-in function is invoked if shift is pressed or
         * if table cells are selected and shift is not pressed.
         */
        mxCellEditor.prototype.alignText = function(align, evt)
        {
            if (!this.isTableSelected() == (evt == null || !mxEvent.isShiftDown(evt)))
            {
                this.graph.cellEditor.setAlign(align);
                
                this.graph.processElements(this.textarea, function(elt)
                {
                    elt.removeAttribute('align');
                    elt.style.textAlign = null;
                });
            }
            
            document.execCommand('justify' + align.toLowerCase(), false, null);
        };
        
        /**
         * Creates the keyboard event handler for the current graph and history.
         */
        mxCellEditor.prototype.saveSelection = function()
        {
            if (window.getSelection)
            {
                var sel = window.getSelection();
                
                if (sel.getRangeAt && sel.rangeCount)
                {
                    var ranges = [];
                    
                    for (var i = 0, len = sel.rangeCount; i < len; ++i)
                    {
                        ranges.push(sel.getRangeAt(i));
                    }
                    
                    return ranges;
                }
            }
            else if (document.selection && document.selection.createRange)
            {
                return document.selection.createRange();
            }
            
            return null;
        };
    
        /**
         * Creates the keyboard event handler for the current graph and history.
         */
        mxCellEditor.prototype.restoreSelection = function(savedSel)
        {
            //--->fix<---//
            // try
            // {
            //     if (savedSel)
            //     {
            //         if (window.getSelection)
            //         {
            //             sel = window.getSelection();
            //             sel.removeAllRanges();
        
            //             for (var i = 0, len = savedSel.length; i < len; ++i)
            //             {
            //                 sel.addRange(savedSel[i]);
            //             }
            //         }
            //         else if (document.selection && savedSel.select)
            //         {
            //             savedSel.select();
            //         }
            //     }
            // }
            // catch (e)
            // {
            //     // ignore
            // }
              //--->fix<---//
        };
    
        /**
         * Handling of special nl2Br style for not converting newlines to breaks in HTML labels.
         * NOTE: Since it's easier to set this when the label is created we assume that it does
         * not change during the lifetime of the mxText instance.
         */
        var mxCellRendererInitializeLabel = mxCellRenderer.prototype.initializeLabel;
        mxCellRenderer.prototype.initializeLabel = function(state)
        {
            if (state.text != null)
            {
                state.text.replaceLinefeeds = mxUtils.getValue(state.style, 'nl2Br', '1') != '0';
            }
            
            mxCellRendererInitializeLabel.apply(this, arguments);
        };
    
        var mxConstraintHandlerUpdate = mxConstraintHandler.prototype.update;
        mxConstraintHandler.prototype.update = function(me, source)
        {
            if (this.isKeepFocusEvent(me) || !mxEvent.isAltDown(me.getEvent()))
            {
                mxConstraintHandlerUpdate.apply(this, arguments);
            }
            else
            {
                this.reset();
            }
        };
    
        /**
         * No dashed shapes.
         */
        mxGuide.prototype.createGuideShape = function(horizontal)
        {
            var guide = new mxPolyline([], mxConstants.GUIDE_COLOR, mxConstants.GUIDE_STROKEWIDTH);
            
            return guide;
        };
        
        /**
         * HTML in-place editor
         */
        mxCellEditor.prototype.escapeCancelsEditing = false;
        
        var mxCellEditorStartEditing = mxCellEditor.prototype.startEditing;
        mxCellEditor.prototype.startEditing = function(cell, trigger)
        {
            mxCellEditorStartEditing.apply(this, arguments);
            
            // Overrides class in case of HTML content to add dashed borders for divs and table cells
            var state = this.graph.view.getState(cell);
            if (state != null && state.style['html'] == 1)
                this.textarea.className = 'mxCellEditor geContentEditable';
            else
                this.textarea.className = 'mxCellEditor mxPlainTextEditor';
            
            // Toggles markup vs wysiwyg mode
            this.codeViewMode = false;
            
            // Stores current selection range when switching between markup and code
            this.switchSelectionState = null;
            
            // Selects editing cell
            this.graph.setSelectionCell(cell);

            // Enables focus outline for edges and edge labels
            var parent = this.graph.getModel().getParent(cell);
            var geo = this.graph.getCellGeometry(cell);
            
            if ((this.graph.getModel().isEdge(parent) && geo != null && geo.relative) || this.graph.getModel().isEdge(cell))
            {
                // IE>8 and FF on Windows uses outline default of none
                if (mxClient.IS_IE || mxClient.IS_IE11 || (mxClient.IS_FF && mxClient.IS_WIN))
                    this.textarea.style.outline = 'gray dotted 1px';
                else
                    this.textarea.style.outline = '';
            }
        }

        /**
         * HTML in-place editor
         */
        var cellEditorInstallListeners = mxCellEditor.prototype.installListeners;
        mxCellEditor.prototype.installListeners = function(elt)
        {
            cellEditorInstallListeners.apply(this, arguments);

            // Adds a reference from the clone to the original node, recursively
            function reference(node, clone)
            {
                clone.originalNode = node;
                
                node = node.firstChild;
                var child = clone.firstChild;
                
                while (node != null && child != null)
                {
                    reference(node, child);
                    node = node.nextSibling;
                    child = child.nextSibling;
                }
                
                return clone;
            };
            
            // Checks the given node for new nodes, recursively
            function checkNode(node, clone)
            {
                if (node != null)
                {
                    if (clone.originalNode != node)
                    {
                        cleanNode(node);
                    }
                    else
                    {
                        node = node.firstChild;
                        clone = clone.firstChild;
                        
                        while (node != null)
                        {
                            var nextNode = node.nextSibling;
                            
                            if (clone == null)
                            {
                                cleanNode(node);
                            }
                            else
                            {
                                checkNode(node, clone);
                                clone = clone.nextSibling;
                            }
    
                            node = nextNode;
                        }
                    }
                }
            };

            // Removes unused DOM nodes and attributes, recursively
            function cleanNode(node)
            {
                var child = node.firstChild;
                
                while (child != null)
                {
                    var next = child.nextSibling;
                    cleanNode(child);
                    child = next;
                }
                
                if ((node.nodeType != 1 || (node.nodeName !== 'BR' && node.firstChild == null)) &&
                    (node.nodeType != 3 || mxUtils.trim(mxUtils.getTextContent(node)).length == 0))
                {
                    node.parentNode.removeChild(node);
                }
                else
                {
                    // Removes linefeeds
                    if (node.nodeType == 3)
                    {
                        mxUtils.setTextContent(node, mxUtils.getTextContent(node).replace(/\n|\r/g, ''));
                    }

                    // Removes CSS classes and styles (for Word and Excel)
                    if (node.nodeType == 1)
                    {
                        node.removeAttribute('style');
                        node.removeAttribute('class');
                        node.removeAttribute('width');
                        node.removeAttribute('cellpadding');
                        node.removeAttribute('cellspacing');
                        node.removeAttribute('border');
                    }
                }
            };
            
            // Handles paste from Word, Excel etc by removing styles, classnames and unused nodes
            // LATER: Fix undo/redo for paste
            if (document.documentMode !== 7 && document.documentMode !== 8)
            {
                mxEvent.addListener(this.textarea, 'paste', mxUtils.bind(this, function(evt)
                {
                    var clone = reference(this.textarea, this.textarea.cloneNode(true));
    
                    window.setTimeout(mxUtils.bind(this, function()
                    {
                        // Paste from Word or Excel
                        if (this.textarea != null &&
                            (this.textarea.innerHTML.indexOf('<o:OfficeDocumentSettings>') >= 0 ||
                            this.textarea.innerHTML.indexOf('<!--[if !mso]>') >= 0))
                        {
                            checkNode(this.textarea, clone);
                        }
                    }), 0);
                }));
            }
        };
        
        mxCellEditor.prototype.toggleViewMode = function()
        {
            var state = this.graph.view.getState(this.editingCell);
            
            if (state != null)
            {
                var nl2Br = state != null && mxUtils.getValue(state.style, 'nl2Br', '1') != '0';
                var tmp = this.saveSelection();
                
                if (!this.codeViewMode)
                {
                    // Clears the initial empty label on the first keystroke
                    if (this.clearOnChange && this.textarea.innerHTML == this.getEmptyLabelText())
                    {
                        this.clearOnChange = false;
                        this.textarea.innerHTML = '';
                    }
                    
                    // Removes newlines from HTML and converts breaks to newlines
                    // to match the HTML output in plain text
                    var content = mxUtils.htmlEntities(this.textarea.innerHTML);
        
                    // Workaround for trailing line breaks being ignored in the editor
                    if (document.documentMode != 8)
                        content = mxUtils.replaceTrailingNewlines(content, '<div><br></div>');
                    
                    content = this.graph.sanitizeHtml((nl2Br) ? content.replace(/\n/g, '').replace(/&lt;br\s*.?&gt;/g, '<br>') : content, true);
                    this.textarea.className = 'mxCellEditor mxPlainTextEditor';
                    
                    var size = mxConstants.DEFAULT_FONTSIZE;
                    
                    this.textarea.style.lineHeight = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? Math.round(size * mxConstants.LINE_HEIGHT) + 'px' : mxConstants.LINE_HEIGHT;
                    this.textarea.style.fontSize = Math.round(size) + 'px';
                    this.textarea.style.textDecoration = '';
                    this.textarea.style.fontWeight = 'normal';
                    this.textarea.style.fontStyle = '';
                    this.textarea.style.fontFamily = mxConstants.DEFAULT_FONTFAMILY;
                    this.textarea.style.textAlign = 'left';
                    
                    // Adds padding to make cursor visible with borders
                    this.textarea.style.padding = '2px';
                    
                    if (this.textarea.innerHTML != content)
                    {
                        this.textarea.innerHTML = content;
                    }
        
                    this.codeViewMode = true;
                }
                else
                {
                    var content = mxUtils.extractTextWithWhitespace(this.textarea.childNodes);
                    
                    // Strips trailing line break
                    if (content.length > 0 && content.charAt(content.length - 1) == '\n')
                    {
                        content = content.substring(0, content.length - 1);
                    }
                    
                    content = this.graph.sanitizeHtml((nl2Br) ? content.replace(/\n/g, '<br/>') : content, true)
                    this.textarea.className = 'mxCellEditor geContentEditable';
                    
                    var size = mxUtils.getValue(state.style, mxConstants.STYLE_FONTSIZE, mxConstants.DEFAULT_FONTSIZE);
                    var family = mxUtils.getValue(state.style, mxConstants.STYLE_FONTFAMILY, mxConstants.DEFAULT_FONTFAMILY);
                    var align = mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_LEFT);
                    var bold = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) &
                            mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD;
                    var italic = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) &
                            mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC;
                    var uline = (mxUtils.getValue(state.style, mxConstants.STYLE_FONTSTYLE, 0) &
                            mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE;
                    
                    this.textarea.style.lineHeight = (mxConstants.ABSOLUTE_LINE_HEIGHT) ? Math.round(size * mxConstants.LINE_HEIGHT) + 'px' : mxConstants.LINE_HEIGHT;
                    this.textarea.style.fontSize = Math.round(size) + 'px';
                    this.textarea.style.textDecoration = (uline) ? 'underline' : '';
                    this.textarea.style.fontWeight = (bold) ? 'bold' : 'normal';
                    this.textarea.style.fontStyle = (italic) ? 'italic' : '';
                    this.textarea.style.fontFamily = family;
                    this.textarea.style.textAlign = align;
                    this.textarea.style.padding = '0px';
                    
                    if (this.textarea.innerHTML != content)
                    {
                        this.textarea.innerHTML = content;
                        
                        if (this.textarea.innerHTML.length == 0)
                        {
                            this.textarea.innerHTML = this.getEmptyLabelText();
                            this.clearOnChange = this.textarea.innerHTML.length > 0;
                        }
                    }
        
                    this.codeViewMode = false;
                }
                
                this.textarea.focus();
            
                if (this.switchSelectionState != null)
                {
                    this.restoreSelection(this.switchSelectionState);
                }
                
                this.switchSelectionState = tmp;
                this.resize();
            }
        };
        
        var mxCellEditorResize = mxCellEditor.prototype.resize;
        mxCellEditor.prototype.resize = function(state, trigger)
        {
            if (this.textarea != null)
            {
                var state = this.graph.getView().getState(this.editingCell);
                
                if (this.codeViewMode && state != null)
                {
                    var scale = state.view.scale;
                    this.bounds = mxRectangle.fromRectangle(state);
                    
                    // General placement of code editor if cell has no size
                    // LATER: Fix HTML editor bounds for edge labels
                    if (this.bounds.width == 0 && this.bounds.height == 0)
                    {
                        this.bounds.width = 160 * scale;
                        this.bounds.height = 60 * scale;
                        
                        var m = (state.text != null) ? state.text.margin : null;
                        
                        if (m == null)
                        {
                            m = mxUtils.getAlignmentAsPoint(mxUtils.getValue(state.style, mxConstants.STYLE_ALIGN, mxConstants.ALIGN_CENTER),
                                    mxUtils.getValue(state.style, mxConstants.STYLE_VERTICAL_ALIGN, mxConstants.ALIGN_MIDDLE));
                        }
                        
                        this.bounds.x += m.x * this.bounds.width;
                        this.bounds.y += m.y * this.bounds.height;
                    }
        
                    this.textarea.style.width = Math.round((this.bounds.width - 4) / scale) + 'px';
                    this.textarea.style.height = Math.round((this.bounds.height - 4) / scale) + 'px';
                    this.textarea.style.overflow = 'auto';
        
                    // Adds scrollbar offset if visible
                    if (this.textarea.clientHeight < this.textarea.offsetHeight)
                    {
                        this.textarea.style.height = Math.round((this.bounds.height / scale)) + (this.textarea.offsetHeight - this.textarea.clientHeight) + 'px';
                        this.bounds.height = parseInt(this.textarea.style.height) * scale;
                    }
                    
                    if (this.textarea.clientWidth < this.textarea.offsetWidth)
                    {
                        this.textarea.style.width = Math.round((this.bounds.width / scale)) + (this.textarea.offsetWidth - this.textarea.clientWidth) + 'px';
                        this.bounds.width = parseInt(this.textarea.style.width) * scale;
                    }
                                    
                    this.textarea.style.left = Math.round(this.bounds.x) + 'px';
                    this.textarea.style.top = Math.round(this.bounds.y) + 'px';
        
                    mxUtils.setPrefixedStyle(this.textarea.style, 'transform', 'scale(' + scale + ',' + scale + ')');	
                }
                else
                {
                    this.textarea.style.height = '';
                    this.textarea.style.overflow = '';
                    mxCellEditorResize.apply(this, arguments);
                }
            }
        };
        
        let mxCellEditorGetInitialValue = mxCellEditor.prototype.getInitialValue;
        mxCellEditor.prototype.getInitialValue = function(state, trigger)
        {
            if (mxUtils.getValue(state.style, 'html', '0') == '0')
            {
                return mxCellEditorGetInitialValue.apply(this, arguments);
            }
            else
            {
                var result = this.graph.getEditingValue(state.cell, trigger)
            
                if (mxUtils.getValue(state.style, 'nl2Br', '1') == '1')
                {
                    result = result.replace(/\n/g, '<br/>');
                }
                
                result = this.graph.sanitizeHtml(result, true);
                
                return result;
            }
        };
        
        let mxCellEditorGetCurrentValue = mxCellEditor.prototype.getCurrentValue;
        mxCellEditor.prototype.getCurrentValue = function(state)
        {
            if (mxUtils.getValue(state.style, 'html', '0') == '0')
            {
                return mxCellEditorGetCurrentValue.apply(this, arguments);
            }
            else
            {
                var result = this.graph.sanitizeHtml(this.textarea.innerHTML, true);
    
                if (mxUtils.getValue(state.style, 'nl2Br', '1') == '1')
                {
                    result = result.replace(/\r\n/g, '<br/>').replace(/\n/g, '<br/>');
                }
                else
                {
                    result = result.replace(/\r\n/g, '').replace(/\n/g, '');
                }
                
                return result;
            }
        };
    
        var mxCellEditorStopEditing = mxCellEditor.prototype.stopEditing;
        mxCellEditor.prototype.stopEditing = function(cancel)
        {
            // Restores default view mode before applying value
            if (this.codeViewMode)
                this.toggleViewMode();
            
            mxCellEditorStopEditing.apply(this, arguments);
            
            // Tries to move focus back to container after editing if possible
            this.focusContainer();
        };
        
        mxCellEditor.prototype.focusContainer = function()
        {
            try
            {
                this.graph.container.focus();
            }
            catch (e)
            {
                // ignore
            }
        };
    
        var mxCellEditorApplyValue = mxCellEditor.prototype.applyValue;
        mxCellEditor.prototype.applyValue = function(state, value)
        {
            // Removes empty relative child labels in edges
            this.graph.getModel().beginUpdate();
            
            try
            {
                mxCellEditorApplyValue.apply(this, arguments);
                
                if (this.graph.isCellDeletable(state.cell) && this.graph.model.getChildCount(state.cell) == 0)
                {
                    var stroke = mxUtils.getValue(state.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE);
                    var fill = mxUtils.getValue(state.style, mxConstants.STYLE_FILLCOLOR, mxConstants.NONE);
                    
                    if (value == '' && stroke == mxConstants.NONE && fill == mxConstants.NONE)
                    {
                        this.graph.removeCells([state.cell], false);
                    }
                }
            }
            finally
            {
                this.graph.getModel().endUpdate();
            }
        };
        
        /**
         * Returns the background color to be used for the editing box. This returns
         * the label background for edge labels and null for all other cases.
         */
        mxCellEditor.prototype.getBackgroundColor = function(state)
        {
            var color = mxUtils.getValue(state.style, mxConstants.STYLE_LABEL_BACKGROUNDCOLOR, null);

            if ((color == null || color == mxConstants.NONE) &&
                (state.cell.geometry != null && state.cell.geometry.width > 0) &&
                (mxUtils.getValue(state.style, mxConstants.STYLE_ROTATION, 0) != 0 ||
                mxUtils.getValue(state.style, mxConstants.STYLE_HORIZONTAL, 1) == 0))
            {
                color = mxUtils.getValue(state.style, mxConstants.STYLE_FILLCOLOR, null);
            }

            if (color == mxConstants.NONE)
            {
                color = null;
            }
            
            return color;
        };
        
        mxCellEditor.prototype.getMinimumSize = function(state)
        {
            var scale = this.graph.getView().scale;
            return new mxRectangle(0, 0, (state.text == null) ? 30 :  state.text.size * scale + 20, 30);
        };
        
        // Hold alt to ignore drop target
        var mxGraphHandlerMoveCells = mxGraphHandler.prototype.moveCells;
        mxGraphHandler.prototype.moveCells = function(cells, dx, dy, clone, target, evt)
        {
            if (mxEvent.isAltDown(evt))
            {
                target = null;
            }
            
            mxGraphHandlerMoveCells.apply(this, arguments);
        };
        
        /**
         * Hints on handlers
         */
        function createHint()
        {
            var hint = document.createElement('div');
            hint.className = 'geHint';
            hint.style.whiteSpace = 'nowrap';
            hint.style.position = 'absolute';
            
            return hint;
        };
        
        /**
         * Updates the hint for the current operation.
         */
        mxGraphHandler.prototype.updateHint = function(me)
        {
            if (this.shape != null)
            {
                if (this.hint == null)
                {
                    this.hint = createHint();
                    this.graph.container.appendChild(this.hint);
                }
    
                var t = this.graph.view.translate;
                var s = this.graph.view.scale;
                var x = this.roundLength((this.bounds.x + this.currentDx) / s - t.x);
                var y = this.roundLength((this.bounds.y + this.currentDy) / s - t.y);
                
                this.hint.innerHTML = x + ', ' + y;
    
                this.hint.style.left = (this.shape.bounds.x + Math.round((this.shape.bounds.width - this.hint.clientWidth) / 2)) + 'px';
                this.hint.style.top = (this.shape.bounds.y + this.shape.bounds.height + 12) + 'px';
            }
        };
    
        /**
         * Updates the hint for the current operation.
         */
        mxGraphHandler.prototype.removeHint = function()
        {
            if (this.hint != null)
            {
                this.hint.parentNode.removeChild(this.hint);
                this.hint = null;
            }
        };
    
        /**
         * Enables recursive resize for groups.
         */
        mxVertexHandler.prototype.isRecursiveResize = function(state, me)
        {
            return !this.graph.isSwimlane(state.cell) && this.graph.model.getChildCount(state.cell) > 0 &&
                !mxEvent.isControlDown(me.getEvent()) && !this.graph.isCellCollapsed(state.cell) &&
                mxUtils.getValue(state.style, 'recursiveResize', '1') == '1' &&
                mxUtils.getValue(state.style, 'childLayout', null) == null;
        };
        
        /**
         * Enables centered resize events.
         */
        mxVertexHandler.prototype.isCenteredEvent = function(state, me)
        {
            return (!(!this.graph.isSwimlane(state.cell) && this.graph.model.getChildCount(state.cell) > 0 &&
                    !this.graph.isCellCollapsed(state.cell) &&
                    mxUtils.getValue(state.style, 'recursiveResize', '1') == '1' &&
                    mxUtils.getValue(state.style, 'childLayout', null) == null) &&
                    mxEvent.isControlDown(me.getEvent())) ||
                mxEvent.isMetaDown(me.getEvent());
        };
        
        var vertexHandlerGetHandlePadding = mxVertexHandler.prototype.getHandlePadding;
        mxVertexHandler.prototype.getHandlePadding = function ()
        {
            var result = new mxPoint(0, 0);
            var tol = this.tolerance;

            if (this.graph.cellEditor.getEditingCell() == this.state.cell &&
                this.sizers != null && this.sizers.length > 0 && this.sizers[0] != null)
            {
                tol /= 2;

                result.x = this.sizers[0].bounds.width + tol;
                result.y = this.sizers[0].bounds.height + tol;
            }
            else
            {
                result = vertexHandlerGetHandlePadding.apply(this, arguments);
            }

            return result;
        }; 
    
        /**
         * Updates the hint for the current operation.
         */
        mxVertexHandler.prototype.updateHint = function(me)
        {
            if (this.index != mxEvent.LABEL_HANDLE)
            {
                if (this.hint == null)
                {
                    this.hint = createHint();
                    this.state.view.graph.container.appendChild(this.hint);
                }
    
                if (this.index == mxEvent.ROTATION_HANDLE)
                {
                    this.hint.innerHTML = this.currentAlpha + '&deg;';
                }
                else
                {
                    var s = this.state.view.scale;
                    this.hint.innerHTML = this.roundLength(this.bounds.width / s) + ' x ' + this.roundLength(this.bounds.height / s);
                }
                
                var rot = (this.currentAlpha != null) ? this.currentAlpha : this.state.style[mxConstants.STYLE_ROTATION] || '0';
                var bb = mxUtils.getBoundingBox(this.bounds, rot);
                
                if (bb == null)
                {
                    bb = this.bounds;
                }
                
                this.hint.style.left = bb.x + Math.round((bb.width - this.hint.clientWidth) / 2) + 'px';
                this.hint.style.top = (bb.y + bb.height + 12) + 'px';
                
                if (this.linkHint != null)
                {
                    this.linkHint.style.display = 'none';
                }
            }
        };
    
        /**
         * Updates the hint for the current operation.
         */
        mxVertexHandler.prototype.removeHint = function()
        {
            mxGraphHandler.prototype.removeHint.apply(this, arguments);
            if (this.linkHint != null)
                this.linkHint.style.display = '';
        };

        /**
         * Hides link hint while moving cells.
         */
        var edgeHandlerMouseMove = mxEdgeHandler.prototype.mouseMove;
        mxEdgeHandler.prototype.mouseMove = function (sender, me)
        {
            edgeHandlerMouseMove.apply(this, arguments);
            if (this.graph.graphHandler != null && this.graph.graphHandler.first != null && this.linkHint != null && this.linkHint.style.display != 'none')
                this.linkHint.style.display = 'none';
        }

		/**
		 * Hides link hint while moving cells.
		 */
        var edgeHandlerMouseUp = mxEdgeHandler.prototype.mouseUp;
        mxEdgeHandler.prototype.mouseUp = function (sender, me)
        {
            edgeHandlerMouseUp.apply(this, arguments);
            if (this.linkHint != null && this.linkHint.style.display == 'none')
                this.linkHint.style.display = '';
        }

        /**
         * Updates the hint for the current operation.
         */
        mxEdgeHandler.prototype.updateHint = function(me, point)
        {
            if (this.hint == null)
            {
                this.hint = createHint();
                this.state.view.graph.container.appendChild(this.hint);
            }
    
            var t = this.graph.view.translate;
            var s = this.graph.view.scale;
            var x = this.roundLength(point.x / s - t.x);
            var y = this.roundLength(point.y / s - t.y);
            
            this.hint.innerHTML = x + ', ' + y;
            this.hint.style.visibility = 'visible';
            
            if (this.isSource || this.isTarget)
            {
                if (this.constraintHandler.currentConstraint != null && this.constraintHandler.currentFocus != null)
                {
                    var pt = this.constraintHandler.currentConstraint.point;
                    this.hint.innerHTML = '[' + Math.round(pt.x * 100) + '%, '+ Math.round(pt.y * 100) + '%]';
                }
                else if (this.marker.hasValidState())
                {
                    this.hint.style.visibility = 'hidden';
                }
            }
            
            this.hint.style.left = Math.round(me.getGraphX() - this.hint.clientWidth / 2) + 'px';
            this.hint.style.top = (Math.max(me.getGraphY(), point.y) + this.state.view.graph.gridSize) + 'px';
            
            if (this.linkHint != null)
            {
                this.linkHint.style.display = 'none';
            }
        };
    
        /**
         * Updates the hint for the current operation.
         */
        mxEdgeHandler.prototype.removeHint = mxVertexHandler.prototype.removeHint;
    
        /**
         * Defines the handles for the UI. Uses data-URIs to speed-up loading time where supported.
         */
        // TODO: Increase handle padding
        HoverIcons.prototype.mainHandle      = Graph.createSvgImage(18, 18, '<circle cx="9" cy="9" r="5" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '" stroke-width="1"/>');
        HoverIcons.prototype.secondaryHandle = Graph.createSvgImage(16, 16, '<path d="m 8 3 L 13 8 L 8 13 L 3 8 z" stroke="#fff" fill="#fca000"/>');
        HoverIcons.prototype.fixedHandle     = Graph.createSvgImage(18, 18, '<circle cx="9" cy="9" r="5" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '" stroke-width="1"/><path d="m 7 7 L 11 11 M 7 11 L 11 7" stroke="#fff"/>');
        HoverIcons.prototype.terminalHandle  = Graph.createSvgImage(18, 18, '<circle cx="9" cy="9" r="5" stroke="#fff" fill="' + HoverIcons.prototype.arrowFill + '" stroke-width="1"/><circle cx="9" cy="9" r="2" stroke="#fff" fill="transparent"/>');
        HoverIcons.prototype.rotationHandle  = new mxImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABMAAAAVCAYAAACkCdXRAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAA6ZJREFUeNqM001IY1cUB/D/fYmm2sbR2lC1zYlgoRG6MpEyBlpxM9iFIGKFIm3s0lCKjOByhCLZCFqLBF1YFVJdSRbdFHRhBbULtRuFVBTzYRpJgo2mY5OX5N9Fo2TG+eiFA/dd3vvd8+65ByTxshARTdf1JySp6/oTEdFe9T5eg5lIcnBwkCSZyWS+exX40oyur68/KxaLf5Okw+H4X+A9JBaLfUySZ2dnnJqaosPhIAACeC34DJRKpb7IZrMcHx+nwWCgUopGo/EOKwf9fn/1CzERUevr6+9ls1mOjIwQAH0+H4PBIKPR6D2ofAQCgToRUeVYJUkuLy8TANfW1kiS8/PzCy84Mw4MDBAAZ2dnmc/nub+/X0MSEBF1cHDwMJVKsaGhgV6vl+l0mqOjo1+KyKfl1dze3l4NBoM/PZ+diFSLiIKIGBOJxA9bW1sEwNXVVSaTyQMRaRaRxrOzs+9J8ujoaE5EPhQRq67rcZ/PRwD0+/3Udf03EdEgIqZisZibnJykwWDg4eEhd3Z2xkXELCJvPpdBrYjUiEhL+Xo4HH4sIhUaAKNSqiIcDsNkMqG+vh6RSOQQQM7tdhsAQCkFAHC73UUATxcWFqypVApmsxnDw8OwWq2TADQNgAYAFosF+XweyWQSdru9BUBxcXFRB/4rEgDcPouIIx6P4+bmBi0tLSCpAzBqAIqnp6c/dnZ2IpfLYXNzE62traMADACKNputpr+/v8lms9UAKAAwiMjXe3t7KBQKqKurQy6Xi6K0i2l6evpROp1mbW0t29vbGY/Hb8/IVIqq2zlJXl1dsaOjg2azmefn5wwEAl+JSBVExCgi75PkzMwMlVJsbGxkIpFgPp8PX15ePopEIs3JZPITXdf/iEajbGpqolKKExMT1HWdHo/nIxGpgIgoEXnQ3d39kCTHxsYIgC6Xi3NzcwyHw8xkMozFYlxaWmJbWxuVUuzt7WUul6PX6/1cRN4WEe2uA0SkaWVl5XGpRVhdXU0A1DSNlZWVdz3qdDrZ09PDWCzG4+Pjn0XEWvp9KJKw2WwKwBsA3gHQHAqFfr24uMDGxgZ2d3cRiUQAAHa7HU6nE319fTg5Ofmlq6vrGwB/AngaCoWK6rbsNptNA1AJoA7Aux6Pp3NoaMhjsVg+QNmIRqO/u1yubwFEASRKUAEA7rASqABUAKgC8KAUb5XWCOAfAFcA/gJwDSB7C93DylCtdM8qABhLc5TumV6KQigUeubjfwcAHkQJ94ndWeYAAAAASUVORK5CYII=', 19, 21);
        
        mxConstraintHandler.prototype.pointImage = Graph.createSvgImage(5, 5, '<path d="m 0 0 L 5 5 M 0 5 L 5 0" stroke="' + HoverIcons.prototype.arrowFill + '"/>');
        
        mxVertexHandler.prototype.handleImage          = HoverIcons.prototype.mainHandle;
        mxVertexHandler.prototype.secondaryHandleImage = HoverIcons.prototype.secondaryHandle;
        mxEdgeHandler.prototype.handleImage            = HoverIcons.prototype.mainHandle;
        mxEdgeHandler.prototype.terminalHandleImage    = HoverIcons.prototype.terminalHandle;
        mxEdgeHandler.prototype.fixedHandleImage       = HoverIcons.prototype.fixedHandle;
        mxEdgeHandler.prototype.labelHandleImage       = HoverIcons.prototype.secondaryHandle;
        mxOutline.prototype.sizerImage                 = HoverIcons.prototype.mainHandle;
        
        if (window.Sidebar != null)
        {
            Sidebar.prototype.triangleUp    = HoverIcons.prototype.triangleUp;
            Sidebar.prototype.triangleRight = HoverIcons.prototype.triangleRight;
            Sidebar.prototype.triangleDown  = HoverIcons.prototype.triangleDown;
            Sidebar.prototype.triangleLeft  = HoverIcons.prototype.triangleLeft;
            Sidebar.prototype.refreshTarget = HoverIcons.prototype.refreshTarget;
            Sidebar.prototype.roundDrop     = HoverIcons.prototype.roundDrop;
        }
        
        // Adds rotation handle and live preview
        mxVertexHandler.prototype.rotationEnabled = true;
        mxVertexHandler.prototype.manageSizers = true;
        mxVertexHandler.prototype.livePreview = true;
        mxGraphHandler.prototype.maxLivePreview = 16;
    
        // Increases default rubberband opacity (default is 20)
        mxRubberband.prototype.defaultOpacity = 30;
        
        // Enables connections along the outline, virtual waypoints, parent highlight etc
        mxConnectionHandler.prototype.outlineConnect = false;
        mxCellHighlight.prototype.keepOnTop = true;
        mxVertexHandler.prototype.parentHighlightEnabled = true;
        mxVertexHandler.prototype.rotationHandleVSpacing = -20;
        
        mxEdgeHandler.prototype.parentHighlightEnabled = true;
        mxEdgeHandler.prototype.dblClickRemoveEnabled = true;
        mxEdgeHandler.prototype.straightRemoveEnabled = true;
        mxEdgeHandler.prototype.virtualBendsEnabled = true;
        mxEdgeHandler.prototype.mergeRemoveEnabled = true;
        mxEdgeHandler.prototype.manageLabelHandle = true;
        mxEdgeHandler.prototype.outlineConnect = false;
        
        // Disables adding waypoints if shift is pressed
        mxEdgeHandler.prototype.isAddVirtualBendEvent = function(me)
        {
            return !mxEvent.isShiftDown(me.getEvent());
        };
        // Disables custom handles if shift is pressed
        mxEdgeHandler.prototype.isCustomHandleEvent = function(me)
        {
            return !mxEvent.isShiftDown(me.getEvent());
        };
        
        /**
         * Implements touch style
         */
        if (Graph.touchStyle)
        {
            // Larger tolerance for real touch devices
            if (mxClient.IS_TOUCH || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0)
            {
                mxShape.prototype.svgStrokeTolerance = 18;
                mxVertexHandler.prototype.tolerance = 12;
                mxEdgeHandler.prototype.tolerance = 12;
                Graph.prototype.tolerance = 12;
                
                mxVertexHandler.prototype.rotationHandleVSpacing = -24;
                
                // Implements a smaller tolerance for mouse events and a larger tolerance for touch
                // events on touch devices. The default tolerance (4px) is used for mouse events.
                mxConstraintHandler.prototype.getTolerance = function(me)
                {
                    return (mxEvent.isMouseEvent(me.getEvent())) ? 10 : this.graph.getTolerance();
                };
            }
                
            // One finger pans (no rubberband selection) must start regardless of mouse button
            mxPanningHandler.prototype.isPanningTrigger = function(me)
            {
                var evt = me.getEvent();
                
                return (me.getState() == null && !mxEvent.isMouseEvent(evt)) ||
                    (mxEvent.isPopupTrigger(evt) && (me.getState() == null ||
                    mxEvent.isControlDown(evt) || mxEvent.isShiftDown(evt)));
            };
            
            // Don't clear selection if multiple cells selected
            var graphHandlerMouseDown = mxGraphHandler.prototype.mouseDown;
            mxGraphHandler.prototype.mouseDown = function(sender, me)
            {
                graphHandlerMouseDown.apply(this, arguments);
    
                if (mxEvent.isTouchEvent(me.getEvent()) && this.graph.isCellSelected(me.getCell()) && this.graph.getSelectionCount() > 1)
                    this.delayedSelection = false;
            };
        }
        else
        {
            // Removes ctrl+shift as panning trigger for space splitting
            mxPanningHandler.prototype.isPanningTrigger = function(me)
            {
                var evt = me.getEvent();
                
                return (mxEvent.isLeftMouseButton(evt) && ((this.useLeftButtonForPanning &&
                        me.getState() == null) || (mxEvent.isControlDown(evt) &&
                        !mxEvent.isShiftDown(evt)))) || (this.usePopupTrigger &&
                        mxEvent.isPopupTrigger(evt));
            };
        }

        // Overrides/extends rubberband for space handling with Ctrl+Shift(+Alt) drag ("scissors tool")
        mxRubberband.prototype.isSpaceEvent = function(me)
        {
            return this.graph.isEnabled() && !this.graph.isCellLocked(this.graph.getDefaultParent()) &&
                mxEvent.isControlDown(me.getEvent()) && mxEvent.isShiftDown(me.getEvent());
        };
        
        // Handles moving of cells in both half panes
        mxRubberband.prototype.mouseUp = function(sender, me)
        {
            var execute = this.div != null && this.div.style.display != 'none';

            var x0 = null;
            var y0 = null;
            var dx = null;
            var dy = null;

            if (this.first != null && this.currentX != null && this.currentY != null)
            {
                x0 = this.first.x;
                y0 = this.first.y;
                dx = (this.currentX - x0) / this.graph.view.scale;
                dy = (this.currentY - y0) / this.graph.view.scale;

                if (!mxEvent.isAltDown(me.getEvent()))
                {
                    dx = this.graph.snap(dx);
                    dy = this.graph.snap(dy);
                    
                    if (!this.graph.isGridEnabled())
                    {
                        if (Math.abs(dx) < this.graph.tolerance)
                        {
                            dx = 0;
                        }
                        
                        if (Math.abs(dy) < this.graph.tolerance)
                        {
                            dy = 0;
                        }
                    }
                }
            }
            
            this.reset();
            
            if (execute)
            {
                if (mxEvent.isAltDown(me.getEvent()) && this.graph.isToggleEvent(me.getEvent()))
                {
                    var rect = new mxRectangle(this.x, this.y, this.width, this.height);
                    var cells = this.graph.getCells(rect.x, rect.y, rect.width, rect.height);
                    
                    this.graph.removeSelectionCells(cells);
                }
                else if (this.isSpaceEvent(me))
                {
                    this.graph.model.beginUpdate();
                    try
                    {
                        var cells = this.graph.getCellsBeyond(x0, y0, this.graph.getDefaultParent(), true, true);

                        for (var i = 0; i < cells.length; i++)
                        {
                            if (this.graph.isCellMovable(cells[i]))
                            {
                                var tmp = this.graph.view.getState(cells[i]);
                                var geo = this.graph.getCellGeometry(cells[i]);
                                
                                if (tmp != null && geo != null)
                                {
                                    geo = geo.clone();
                                    geo.translate(dx, dy);
                                    this.graph.model.setGeometry(cells[i], geo);
                                }
                            }
                        }
                    }
                    finally
                    {
                        this.graph.model.endUpdate();
                    }
                }
                else
                {
                    var rect = new mxRectangle(this.x, this.y, this.width, this.height);
                    this.graph.selectRegion(rect, me.getEvent());
                }
                
                me.consume();
            }
        };
        
        // Handles preview for creating/removing space in diagram
        mxRubberband.prototype.mouseMove = function(sender, me)
        {
            if (!me.isConsumed() && this.first != null)
            {
                var origin = mxUtils.getScrollOrigin(this.graph.container);
                var offset = mxUtils.getOffset(this.graph.container);
                origin.x -= offset.x;
                origin.y -= offset.y;
                var x = me.getX() + origin.x;
                var y = me.getY() + origin.y;
                var dx = this.first.x - x;
                var dy = this.first.y - y;
                var tol = this.graph.tolerance;
                
                if (this.div != null || Math.abs(dx) > tol ||  Math.abs(dy) > tol)
                {
                    if (this.div == null)
                    {
                        this.div = this.createShape();
                    }
                    
                    // Clears selection while rubberbanding. This is required because
                    // the event is not consumed in mouseDown.
                    mxUtils.clearSelection();
                    this.update(x, y);
                    
                    if (this.isSpaceEvent(me))
                    {
                        var right = this.x + this.width;
                        var bottom = this.y + this.height;
                        var scale = this.graph.view.scale;
                        
                        if (!mxEvent.isAltDown(me.getEvent()))
                        {
                            this.width = this.graph.snap(this.width / scale) * scale;
                            this.height = this.graph.snap(this.height / scale) * scale;
                            
                            if (!this.graph.isGridEnabled())
                            {
                                if (this.width < this.graph.tolerance)
                                {
                                    this.width = 0;
                                }
                                
                                if (this.height < this.graph.tolerance)
                                {
                                    this.height = 0;
                                }
                            }
                            
                            if (this.x < this.first.x)
                            {
                                this.x = right - this.width;
                            }
                            
                            if (this.y < this.first.y)
                            {
                                this.y = bottom - this.height;
                            }
                        }
                        
                        this.div.style.borderStyle = 'dashed';
                        this.div.style.backgroundColor = 'white';
                        this.div.style.left = this.x + 'px';
                        this.div.style.top = this.y + 'px';
                        this.div.style.width = Math.max(0, this.width) + 'px';
                        this.div.style.height = this.graph.container.clientHeight + 'px';
                        this.div.style.borderWidth = (this.width <= 0) ? '0px 1px 0px 0px' : '0px 1px 0px 1px';
                        
                        if (this.secondDiv == null)
                        {
                            this.secondDiv = this.div.cloneNode(true);
                            this.div.parentNode.appendChild(this.secondDiv);
                        }
                        
                        this.secondDiv.style.left = this.x + 'px';
                        this.secondDiv.style.top = this.y + 'px';
                        this.secondDiv.style.width = this.graph.container.clientWidth + 'px';
                        this.secondDiv.style.height = Math.max(0, this.height) + 'px';
                        this.secondDiv.style.borderWidth = (this.height <= 0) ? '1px 0px 0px 0px' : '1px 0px 1px 0px';
                    }
                    else
                    {
                        // Hides second div and restores style
                        this.div.style.backgroundColor = '';
                        this.div.style.borderWidth = '';
                        this.div.style.borderStyle = '';
                        
                        if (this.secondDiv != null)
                        {
                            this.secondDiv.parentNode.removeChild(this.secondDiv);
                            this.secondDiv = null;
                        }
                    }

                    me.consume();
                }
            }
        };
        
        // Removes preview
        var mxRubberbandReset = mxRubberband.prototype.reset;
        mxRubberband.prototype.reset = function()
        {
            if (this.secondDiv != null)
            {
                this.secondDiv.parentNode.removeChild(this.secondDiv);
                this.secondDiv = null;
            }
            
            mxRubberbandReset.apply(this, arguments);
        };
        
        // Timer-based activation of outline connect in connection handler
        var startTime = new Date().getTime();
        var timeOnTarget = 0;
        
        var mxEdgeHandlerUpdatePreviewState = mxEdgeHandler.prototype.updatePreviewState;
        mxEdgeHandler.prototype.updatePreviewState = function(edge, point, terminalState, me)
        {
            mxEdgeHandlerUpdatePreviewState.apply(this, arguments);
            
            if (terminalState != this.currentTerminalState)
            {
                startTime = new Date().getTime();
                timeOnTarget = 0;
            }
            else
            {
                timeOnTarget = new Date().getTime() - startTime;
            }
            
            this.currentTerminalState = terminalState;
        };
    
        // Timer-based outline connect
        var mxEdgeHandlerIsOutlineConnectEvent = mxEdgeHandler.prototype.isOutlineConnectEvent;
        mxEdgeHandler.prototype.isOutlineConnectEvent = function(me)
        {
            return (this.currentTerminalState != null && me.getState() == this.currentTerminalState && timeOnTarget > 2000) ||
                ((this.currentTerminalState == null || mxUtils.getValue(this.currentTerminalState.style, 'outlineConnect', '1') != '0') &&
                mxEdgeHandlerIsOutlineConnectEvent.apply(this, arguments));
        };
        
        // Disables custom handles if shift is pressed
        mxVertexHandler.prototype.isCustomHandleEvent = function(me)
        {
            return !mxEvent.isShiftDown(me.getEvent());
        };
    
        // Shows secondary handle for fixed connection points
        mxEdgeHandler.prototype.createHandleShape = function(index, virtual)
        {
            var source = index != null && index == 0;
            var terminalState = this.state.getVisibleTerminalState(source);

            var c = (index != null && (index == 0 || index >= this.state.absolutePoints.length - 1 ||
                (this.constructor == mxElbowEdgeHandler && index == 2))) ?
                this.graph.getConnectionConstraint(this.state, terminalState, source) : null;
            var pt = (c != null) ? this.graph.getConnectionPoint(this.state.getVisibleTerminalState(source), c) : null;

            var img = (pt != null) ? this.fixedHandleImage : ((c != null && terminalState != null) ? this.terminalHandleImage : this.handleImage);
            if (img != null)
            {
                var shape = new mxImageShape(new mxRectangle(0, 0, img.width, img.height), img.src);
                // Allows HTML rendering of the images
                shape.preserveImageAspect = false;
                return shape;
            }
            else
            {
                var s = mxConstants.HANDLE_SIZE;
                if (this.preferHtml)
                    s -= 1;
                return new mxRectangleShape(new mxRectangle(0, 0, s, s), mxConstants.HANDLE_FILLCOLOR, mxConstants.HANDLE_STROKECOLOR);
            }
        };

        //var vertexHandlerCreateSizer = mxVertexHandler.prototype.createSizer;
        //mxVertexHandler.prototype.createSizer = function (cursor, index, size, fillColor)
        //{
        //    if (this.state != null && this.state.shape != null && this.state.shape.createSizer)
        //    {
        //        var args = [vertexHandlerCreateSizer].concat([].slice.call(arguments));
        //        return this.state.shape.createSizer.apply(this, args);
        //    }
        //    return vertexHandlerCreateSizer.apply(this, arguments);
        //};

        var vertexHandlerCreateSizerShape = mxVertexHandler.prototype.createSizerShape;
        mxVertexHandler.prototype.createSizerShape = function(bounds, index, fillColor)
        {
            this.handleImage = (index == mxEvent.ROTATION_HANDLE) ? HoverIcons.prototype.rotationHandle : (index == mxEvent.LABEL_HANDLE) ? this.secondaryHandleImage : this.handleImage;
            return vertexHandlerCreateSizerShape.apply(this, arguments);
        };

        var vertexHandlerIsSizerVisible = mxVertexHandler.prototype.isSizerVisible;
        mxVertexHandler.prototype.isSizerVisible = function (index)
        {
            if (this.state != null && this.state.shape != null && this.state.shape.isSizerVisible)
                return this.state.shape.isSizerVisible.apply(this, arguments);
            return vertexHandlerIsSizerVisible.apply(this, arguments);
        };

        // Special case for single edge label handle moving in which case the text bounding box is used
        var mxGraphHandlerGetBoundingBox = mxGraphHandler.prototype.getBoundingBox;
        mxGraphHandler.prototype.getBoundingBox = function(cells)
        {
            if (cells != null && cells.length == 1)
            {
                var model = this.graph.getModel();
                var parent = model.getParent(cells[0]);
                var geo = this.graph.getCellGeometry(cells[0]);
                
                if (model.isEdge(parent) && geo != null && geo.relative)
                {
                    var state = this.graph.view.getState(cells[0]);
                    
                    if (state != null && state.width < 2 && state.height < 2 && state.text != null && state.text.boundingBox != null)
                    {
                        return mxRectangle.fromRectangle(state.text.boundingBox);
                    }
                }
            }
            
            return mxGraphHandlerGetBoundingBox.apply(this, arguments);
        };

        // Ignores child cells with part style as guides
        var mxGraphHandlerGetGuideStates = mxGraphHandler.prototype.getGuideStates;

        mxGraphHandler.prototype.getGuideStates = function ()
        {
            var states = mxGraphHandlerGetGuideStates.apply(this, arguments);
            var result = [];

            for (var i = 0; i < states.length; i++)
            {
                if (mxUtils.getValue(states[i].style, 'part', '0') != '1')
                {
                    result.push(states[i]);
                }
            }

            return result;
        };

        // Uses text bounding box for edge labels
        var mxVertexHandlerGetSelectionBounds = mxVertexHandler.prototype.getSelectionBounds;
        mxVertexHandler.prototype.getSelectionBounds = function(state)
        {
            var model = this.graph.getModel();
            var parent = model.getParent(state.cell);
            var geo = this.graph.getCellGeometry(state.cell);
            
            if (model.isEdge(parent) && geo != null && geo.relative && state.width < 2 && state.height < 2 && state.text != null && state.text.boundingBox != null)
            {
                var bbox = state.text.unrotatedBoundingBox || state.text.boundingBox;
                
                return new mxRectangle(Math.round(bbox.x), Math.round(bbox.y), Math.round(bbox.width), Math.round(bbox.height));
            }
            else
            {
                return mxVertexHandlerGetSelectionBounds.apply(this, arguments);
            }
        };
    
        // Redirects moving of edge labels to mxGraphHandler by not starting here.
        // This will use the move preview of mxGraphHandler (see above).
        var mxVertexHandlerMouseDown = mxVertexHandler.prototype.mouseDown;
        mxVertexHandler.prototype.mouseDown = function(sender, me)
        {
            var model = this.graph.getModel();
            var parent = model.getParent(this.state.cell);
            var geo = this.graph.getCellGeometry(this.state.cell);
            
            // Lets rotation events through
            var handle = this.getHandleForEvent(me);
            
            if (handle == mxEvent.ROTATION_HANDLE || !model.isEdge(parent) || geo == null || !geo.relative ||
                this.state == null || this.state.width >= 2 || this.state.height >= 2)
            {
                mxVertexHandlerMouseDown.apply(this, arguments);
            }
        };

        // Shows rotation handle for edge labels.
        mxVertexHandler.prototype.isRotationHandleVisible = function()
        {
            return this.graph.isEnabled() && this.rotationEnabled && this.graph.isCellRotatable(this.state.cell) &&
                (mxGraphHandler.prototype.maxCells <= 0 || this.graph.getSelectionCount() < mxGraphHandler.prototype.maxCells);
        };
    
        // Invokes turn on single click on rotation handle
        mxVertexHandler.prototype.rotateClick = function()
        {
            this.state.view.graph.turnShapes([this.state.cell]);
        };
        
        // Workaround for "isConsumed not defined" in MS Edge is to use arguments
        var vertexHandlerMouseMove = mxVertexHandler.prototype.mouseMove;
        mxVertexHandler.prototype.mouseMove = function(sender, me)
        {
            vertexHandlerMouseMove.apply(this, arguments);
            if (this.graph.graphHandler.first != null)
            {
                if (this.rotationShape != null && this.rotationShape.node != null)
                    this.rotationShape.node.style.display = 'none';
                if (this.linkHint != null && this.linkHint.style.display != 'none')
                    this.linkHint.style.display = 'none';
            }
        };
        
        var vertexHandlerMouseUp = mxVertexHandler.prototype.mouseUp;
        mxVertexHandler.prototype.mouseUp = function(sender, me)
        {
            vertexHandlerMouseUp.apply(this, arguments);
            
            // Shows rotation handle only if one vertex is selected
            if (this.rotationShape != null && this.rotationShape.node != null)
                this.rotationShape.node.style.display = (this.graph.getSelectionCount() == 1) ? '' : 'none';
            if (this.linkHint != null && this.linkHint.style.display == 'none')
                this.linkHint.style.display = '';
        };
    
        var vertexHandlerInit = mxVertexHandler.prototype.init;
        mxVertexHandler.prototype.init = function ()
        {
            vertexHandlerInit.apply(this, arguments);
            var redraw = false;

            if (this.rotationShape != null)
            {
                this.rotationShape.node.setAttribute('title', mxResources.get('rotateTooltip'));
            }

            var update = mxUtils.bind(this, function ()
            {
                if (this.specialHandle != null)
                {
                    this.specialHandle.node.style.display = (this.graph.isEnabled() && this.graph.getSelectionCount() < this.graph.graphHandler.maxCells) ? '' : 'none';
                }

                this.redrawHandles();
            });

            this.changeHandler = mxUtils.bind(this, function (sender, evt)
            {
                this.updateLinkHint(this.graph.getLinkForCell(this.state.cell),
                    this.graph.getLinksForState(this.state));
                update();
            });

            this.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.changeHandler);
            this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);

            // Repaint needed when editing stops and no change event is fired
            this.editingHandler = mxUtils.bind(this, function (sender, evt)
            {
                this.redrawHandles();
            });

            this.graph.addListener(mxEvent.EDITING_STOPPED, this.editingHandler);

            var link = this.graph.getLinkForCell(this.state.cell);
            var links = this.graph.getLinksForState(this.state);
            this.updateLinkHint(link, links);

            if (link != null || (links != null && links.length > 0))
                redraw = true;

            if (redraw)
                this.redrawHandles();
        }; 
    
        mxVertexHandler.prototype.updateLinkHint = function(link, links)
        {
            if ((link == null && (links == null || links.length == 0)) || this.graph.getSelectionCount() > 1)
            {
                if (this.linkHint != null)
                {
                    this.linkHint.parentNode.removeChild(this.linkHint);
                    this.linkHint = null;
                }
            }
            else if (link != null || (links != null && links.length > 0))
            {
                if (this.linkHint == null)
                {
                    this.linkHint = createHint();
                    this.linkHint.style.padding = '6px 8px 6px 8px';
                    this.linkHint.style.opacity = '1';
                    this.linkHint.style.filter = '';
                    
                    this.graph.container.appendChild(this.linkHint);
                }

                this.linkHint.innerHTML = '';
                
                if (link != null)
                {
                    this.linkHint.appendChild(this.graph.createLinkForHint(link));
                    
                    if (this.graph.isEnabled() && typeof this.graph.editLink === 'function')
                    {
                        var changeLink = document.createElement('img');
                        changeLink.setAttribute('src', Editor.editImage);
                        changeLink.setAttribute('title', mxResources.get('editLink'));
                        changeLink.setAttribute('width', '11');
                        changeLink.setAttribute('height', '11');
                        changeLink.style.marginLeft = '10px';
                        changeLink.style.marginBottom = '-1px';
                        changeLink.style.cursor = 'pointer';
                        this.linkHint.appendChild(changeLink);
                        
                        mxEvent.addListener(changeLink, 'click', mxUtils.bind(this, function(evt)
                        {
                            this.graph.setSelectionCell(this.state.cell);
                            this.graph.editLink();
                            mxEvent.consume(evt);
                        }));
                        
                        var removeLink = document.createElement('img');
                        removeLink.setAttribute('src', Dialog.prototype.clearImage);
                        removeLink.setAttribute('title', mxResources.get('removeIt', [mxResources.get('link')]));
                        removeLink.setAttribute('width', '13');
                        removeLink.setAttribute('height', '10');
                        removeLink.style.marginLeft = '4px';
                        removeLink.style.marginBottom = '-1px';
                        removeLink.style.cursor = 'pointer';
                        this.linkHint.appendChild(removeLink);
                        
                        mxEvent.addListener(removeLink, 'click', mxUtils.bind(this, function(evt)
                        {
                            this.graph.setLinkForCell(this.state.cell, null);
                            mxEvent.consume(evt);
                        }));
                    }
                }

                if (links != null)
                {
                    for (var i = 0; i < links.length; i++)
                    {
                        var div = document.createElement('div');
                        div.style.marginTop = (link != null || i > 0) ? '6px' : '0px';
                        div.appendChild(this.graph.createLinkForHint(
                            links[i].getAttribute('href'),
                            mxUtils.getTextContent(links[i])));
                        
                        this.linkHint.appendChild(div);
                    }
                }
            }
        };
        mxEdgeHandler.prototype.updateLinkHint = mxVertexHandler.prototype.updateLinkHint;
        
        var edgeHandlerInit = mxEdgeHandler.prototype.init;
        mxEdgeHandler.prototype.init = function()
        {
            edgeHandlerInit.apply(this, arguments);
            
            // Disables connection points
            this.constraintHandler.isEnabled = mxUtils.bind(this, function()
            {
                return this.state.view.graph.connectionHandler.isEnabled();
            });
            
            var update = mxUtils.bind(this, function()
            {
                if (this.linkHint != null)
                {
                    this.linkHint.style.display = (this.graph.getSelectionCount() == 1) ? '' : 'none';
                }
                
                if (this.labelShape != null)
                {
                    this.labelShape.node.style.display = (this.graph.isEnabled() && this.graph.getSelectionCount() < this.graph.graphHandler.maxCells) ? '' : 'none';
                }
            });
                
            this.changeHandler = mxUtils.bind(this, function(sender, evt)
            {
                this.updateLinkHint(this.graph.getLinkForCell(this.state.cell), this.graph.getLinksForState(this.state));
                update();
                this.redrawHandles();
            });

            this.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.changeHandler);
            this.graph.getModel().addListener(mxEvent.CHANGE, this.changeHandler);
    
            var link = this.graph.getLinkForCell(this.state.cell);
            var links = this.graph.getLinksForState(this.state);                    
            if (link != null || (links != null && links.length > 0))
            {
                this.updateLinkHint(link, links);
                this.redrawHandles();
            }
        };
    
        // Disables connection points
        var connectionHandlerInit = mxConnectionHandler.prototype.init;
        mxConnectionHandler.prototype.init = function()
        {
            connectionHandlerInit.apply(this, arguments);   
            this.constraintHandler.isEnabled = mxUtils.bind(this, function()
            {
                return this.graph.connectionHandler.isEnabled();
            });
        };
    
        var vertexHandlerRedrawHandles = mxVertexHandler.prototype.redrawHandles;
        mxVertexHandler.prototype.redrawHandles = function()
        {
            // Shows rotation handle only if one vertex is selected
            if (this.rotationShape != null && this.rotationShape.node != null)
            {
                this.rotationShape.node.style.display = (this.graph.getSelectionCount() == 1 &&
                    (this.index == null || this.index == mxEvent.ROTATION_HANDLE)) ? '' : 'none';
            }

            vertexHandlerRedrawHandles.apply(this);

            if (this.state != null && this.linkHint != null)
            {
                var c = new mxPoint(this.state.getCenterX(), this.state.getCenterY());
                var tmp = new mxRectangle(this.state.x, this.state.y - 22, this.state.width + 24, this.state.height + 22);
                var bb = mxUtils.getBoundingBox(tmp, this.state.style[mxConstants.STYLE_ROTATION] || '0', c);
                var rs = (bb != null) ? mxUtils.getBoundingBox(this.state,
                    this.state.style[mxConstants.STYLE_ROTATION] || '0') : this.state;
                var tb = (this.state.text != null) ? this.state.text.boundingBox : null;
                
                if (bb == null)
                {
                    bb = this.state;
                }
                
                var b = bb.y + bb.height;
                
                if (tb != null)
                {
                    b = Math.max(b, tb.y + tb.height);
                }
                
                this.linkHint.style.left = Math.max(0, Math.round(rs.x + (rs.width - this.linkHint.clientWidth) / 2)) + 'px';
                this.linkHint.style.top = Math.round(b + this.verticalOffset / 2 + 6 + this.state.view.graph.tolerance) + 'px';
            }
        };

        //var vertexHandlerReset = mxVertexHandler.prototype.reset;
        //mxVertexHandler.prototype.reset = function()
        //{
        //    vertexHandlerReset.apply(this, arguments);
        //    // Shows rotation handle only if one vertex is selected
        //    if (this.rotationShape != null && this.rotationShape.node != null)
        //        this.rotationShape.node.style.display = (this.graph.getSelectionCount() == 1) ? '' : 'none';
        //};
    
        var vertexHandlerDestroy = mxVertexHandler.prototype.destroy;
        mxVertexHandler.prototype.destroy = function()
        {
            vertexHandlerDestroy.apply(this, arguments);
            
            if (this.linkHint != null)
            {
                this.linkHint.parentNode.removeChild(this.linkHint);
                this.linkHint = null;
            }
            
            if  (this.changeHandler != null)
            {
                this.graph.getSelectionModel().removeListener(this.changeHandler);
                this.graph.getModel().removeListener(this.changeHandler);
                this.changeHandler = null;
            }
            
            if  (this.editingHandler != null)
            {
                this.graph.removeListener(this.editingHandler);
                this.editingHandler = null;
            }
        };
        
        var edgeHandlerRedrawHandles = mxEdgeHandler.prototype.redrawHandles;
        mxEdgeHandler.prototype.redrawHandles = function()
        {
            // Workaround for special case where handler is reset before this which leads to a NPE
            if (this.marker != null)
            {
                edgeHandlerRedrawHandles.apply(this);
        
                if (this.state != null && this.linkHint != null)
                {
                    var b = this.state;
                    
                    if (this.state.text != null && this.state.text.bounds != null)
                    {
                        b = new mxRectangle(b.x, b.y, b.width, b.height);
                        b.add(this.state.text.bounds);
                    }
                    
                    this.linkHint.style.left = Math.max(0, Math.round(b.x + (b.width - this.linkHint.clientWidth) / 2)) + 'px';
                    this.linkHint.style.top = Math.round(b.y + b.height + 6 + this.state.view.graph.tolerance) + 'px';
                }
            }
        };
    
        var edgeHandlerReset = mxEdgeHandler.prototype.reset;
        mxEdgeHandler.prototype.reset = function()
        {
            edgeHandlerReset.apply(this, arguments);
            if (this.linkHint != null)
                this.linkHint.style.visibility = '';
        };
        
        var edgeHandlerDestroy = mxEdgeHandler.prototype.destroy;
        mxEdgeHandler.prototype.destroy = function()
        {
            edgeHandlerDestroy.apply(this, arguments);
            
            if (this.linkHint != null)
            {
                this.linkHint.parentNode.removeChild(this.linkHint);
                this.linkHint = null;
            }
    
            if  (this.changeHandler != null)
            {
                this.graph.getModel().removeListener(this.changeHandler);
                this.graph.getSelectionModel().removeListener(this.changeHandler);
                this.changeHandler = null;
            }
        };

        mxVertexHandler.prototype.resizeVertex = function (me)
        {
            var ct = new mxPoint(this.state.getCenterX(), this.state.getCenterY());
            var alpha = mxUtils.toRadians(this.state.style[mxConstants.STYLE_ROTATION] || '0');
            var point = new mxPoint(me.getGraphX(), me.getGraphY());
            var tr = this.graph.view.translate;
            var scale = this.graph.view.scale;
            var cos = Math.cos(-alpha);
            var sin = Math.sin(-alpha);

            var dx = point.x - this.startX;
            var dy = point.y - this.startY;

            // Rotates vector for mouse gesture
            var tx = cos * dx - sin * dy;
            var ty = sin * dx + cos * dy;

            dx = tx;
            dy = ty;

            var geo = this.graph.getCellGeometry(this.state.cell);
            this.unscaledBounds = this.union(geo, dx / scale, dy / scale, this.index,
                this.graph.isGridEnabledEvent(me.getEvent()), 1,
                new mxPoint(0, 0), this.isConstrainedEvent(me),
                this.isCenteredEvent(this.state, me));

            // Keeps vertex within maximum graph or parent bounds
            if (!geo.relative)
            {
                var max = this.graph.getMaximumGraphBounds();

                // Handles child cells
                if (max != null && this.parentState != null)
                {
                    max = mxRectangle.fromRectangle(max);

                    max.x -= (this.parentState.x - tr.x * scale) / scale;
                    max.y -= (this.parentState.y - tr.y * scale) / scale;
                }

                if (this.graph.isConstrainChild(this.state.cell))
                {
                    var tmp = this.graph.getCellContainmentArea(this.state.cell);

                    if (tmp != null)
                    {
                        var overlap = this.graph.getOverlap(this.state.cell);

                        if (overlap > 0)
                        {
                            tmp = mxRectangle.fromRectangle(tmp);

                            tmp.x -= tmp.width * overlap;
                            tmp.y -= tmp.height * overlap;
                            tmp.width += 2 * tmp.width * overlap;
                            tmp.height += 2 * tmp.height * overlap;
                        }

                        if (max == null)
                        {
                            max = tmp;
                        }
                        else
                        {
                            max = mxRectangle.fromRectangle(max);
                            max.intersect(tmp);
                        }
                    }
                }

                if (max != null)
                {
                    if (this.unscaledBounds.x < max.x)
                    {
                        this.unscaledBounds.width -= max.x - this.unscaledBounds.x;
                        this.unscaledBounds.x = max.x;
                    }

                    if (this.unscaledBounds.y < max.y)
                    {
                        this.unscaledBounds.height -= max.y - this.unscaledBounds.y;
                        this.unscaledBounds.y = max.y;
                    }

                    if (this.unscaledBounds.x + this.unscaledBounds.width > max.x + max.width)
                    {
                        this.unscaledBounds.width -= this.unscaledBounds.x +
                            this.unscaledBounds.width - max.x - max.width;
                    }

                    if (this.unscaledBounds.y + this.unscaledBounds.height > max.y + max.height)
                    {
                        this.unscaledBounds.height -= this.unscaledBounds.y +
                            this.unscaledBounds.height - max.y - max.height;
                    }
                }
            }

            this.bounds = new mxRectangle(((this.parentState != null) ? this.parentState.x : tr.x * scale) +
                (this.unscaledBounds.x) * scale, ((this.parentState != null) ? this.parentState.y : tr.y * scale) +
                (this.unscaledBounds.y) * scale, this.unscaledBounds.width * scale, this.unscaledBounds.height * scale);

            if (geo.relative && this.parentState != null)
            {
                this.bounds.x += this.state.x - this.parentState.x;
                this.bounds.y += this.state.y - this.parentState.y;
            }

            cos = Math.cos(alpha);
            sin = Math.sin(alpha);

            var c2 = new mxPoint(this.bounds.getCenterX(), this.bounds.getCenterY());

            var dx = c2.x - ct.x;
            var dy = c2.y - ct.y;

            var dx2 = cos * dx - sin * dy;
            var dy2 = sin * dx + cos * dy;

            var dx3 = dx2 - dx;
            var dy3 = dy2 - dy;

            var dx4 = this.bounds.x - this.state.x;
            var dy4 = this.bounds.y - this.state.y;

            var dx5 = cos * dx4 - sin * dy4;
            var dy5 = sin * dx4 + cos * dy4;

            this.bounds.x += dx3;
            this.bounds.y += dy3;

            // Rounds unscaled bounds to int
            this.unscaledBounds.x = this.roundLength(this.unscaledBounds.x + dx3 / scale);
            this.unscaledBounds.y = this.roundLength(this.unscaledBounds.y + dy3 / scale);
            this.unscaledBounds.width = this.roundLength(this.unscaledBounds.width);
            this.unscaledBounds.height = this.roundLength(this.unscaledBounds.height);

            // Shifts the children according to parent offset
            if (!this.graph.isCellCollapsed(this.state.cell) && (dx3 != 0 || dy3 != 0))
            {
                this.childOffsetX = this.state.x - this.bounds.x + dx5;
                this.childOffsetY = this.state.y - this.bounds.y + dy5;
            }
            else
            {
                this.childOffsetX = 0;
                this.childOffsetY = 0;
            }

            if (this.livePreview)
            {
                this.updateLivePreview(me);
            }

            if (this.preview != null)
            {
                this.drawPreview();
            }
        };

        var vertexHandlerUnion = mxVertexHandler.prototype.union;
        mxVertexHandler.prototype.union = function (bounds, dx, dy, index, gridEnabled, scale, tr, constrained)
        {
            var result = vertexHandlerUnion.apply(this, arguments);

            var minW = mxUtils.getNumber(this.state.style, 'minWidth',  5);
            var minH = mxUtils.getNumber(this.state.style, 'minHeight', 5);

            result.width  = Math.max(result.width, minW);
            result.height = Math.max(result.height, minH);

            return result;
        };
    })();
}

// export { HoverIcons };

//Sidebar.js

// import * as mxgraph from 'mxgraph';
// import $ from "jquery";
// import Editor from './Editor'
// import Graph from './Graph'
// let { 
//     HoverIcons,
//     mxClient, 
//     mxUtils, 
//     mxResources, 
//     mxRectangle,
//     mxConstants,
//     mxEvent,
//     mxPoint,
//     mxDragSource,
//     mxPopupMenu,
//     mxStackLayout,
//     mxEventObject,
//     mxCell,
//     mxGeometry,
// } = mxgraph();

/**
 * Construcs a new sidebar for the given editor.
 */

function Sidebar(editorUi, container)
{
    this.editorUi = editorUi;
    this.container = container;
    this.palettes = new Object();
    this.showTooltips = true;
    this.graph = editorUi.createTemporaryGraph(this.editorUi.editor.graph.getStylesheet());
    this.graph.cellRenderer.minSvgStrokeWidth = this.minThumbStrokeWidth;
    this.graph.cellRenderer.antiAlias = this.thumbAntiAlias;
    this.graph.container.style.visibility = 'hidden';
    this.graph.foldingEnabled = false;

    document.body.appendChild(this.graph.container);
    
    this.pointerUpHandler = mxUtils.bind(this, function()
    {
        this.showTooltips = true;
    });
    mxEvent.addListener(document, (mxClient.IS_POINTER) ? 'pointerup' : 'mouseup', this.pointerUpHandler);

    this.pointerDownHandler = mxUtils.bind(this, function()
    {
        this.showTooltips = false;
        this.hideTooltip();
    });
    mxEvent.addListener(document, (mxClient.IS_POINTER) ? 'pointerdown' : 'mousedown', this.pointerDownHandler);
    
    this.pointerMoveHandler = mxUtils.bind(this, function(evt)
    {
        var src = mxEvent.getSource(evt);
        
        while (src != null)
        {
            if (src == this.currentElt)
            {
                return;
            }
            
            src = src.parentNode;
        }
        
        this.hideTooltip();
    });
    mxEvent.addListener(document, (mxClient.IS_POINTER) ? 'pointermove' : 'mousemove', this.pointerMoveHandler);

    // Handles mouse leaving the window
    this.pointerOutHandler = mxUtils.bind(this, function(evt)
    {
        if (evt.toElement == null && evt.relatedTarget == null)
            this.hideTooltip();
    });
    mxEvent.addListener(document, (mxClient.IS_POINTER) ? 'pointerout' : 'mouseout', this.pointerOutHandler);

    // Enables tooltips after scroll
    mxEvent.addListener(container, 'scroll', mxUtils.bind(this, function()
    {
        this.showTooltips = true;
        this.hideTooltip();
    }));
    
    this.init();
}
//export default Sidebar;
/**
 * Adds all palettes to the sidebar.
 */
Sidebar.prototype.init = function()
{   
    if (this.editorUi.editor.isViewMode())
    {
        this.addDispatcherPalette(true);
    } else
    {
        this.addGeneralPalette(true);
        this.addFSKPalette(true);
    }    
};

Sidebar.prototype.collapsedImage    = 'data:image/gif;base64,R0lGODlhDQANAIABAJmZmf///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNUQyRTJFNjZGNUYxMUU1QjZEOThCNDYxMDQ2MzNCQiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNUQyRTJFNzZGNUYxMUU1QjZEOThCNDYxMDQ2MzNCQiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjFERjc3MEUxNkY1RjExRTVCNkQ5OEI0NjEwNDYzM0JCIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjFERjc3MEUyNkY1RjExRTVCNkQ5OEI0NjEwNDYzM0JCIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAAQAsAAAAAA0ADQAAAhSMj6lrwAjcC1GyahV+dcZJgeIIFgA7';
Sidebar.prototype.expandedImage     = 'data:image/gif;base64,R0lGODlhDQANAIABAJmZmf///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxREY3NzBERjZGNUYxMUU1QjZEOThCNDYxMDQ2MzNCQiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxREY3NzBFMDZGNUYxMUU1QjZEOThCNDYxMDQ2MzNCQiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjFERjc3MERENkY1RjExRTVCNkQ5OEI0NjEwNDYzM0JCIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjFERjc3MERFNkY1RjExRTVCNkQ5OEI0NjEwNDYzM0JCIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAAQAsAAAAAA0ADQAAAhGMj6nL3QAjVHIu6azbvPtWAAA7';
Sidebar.prototype.dragPreviewBorder = '1px dashed black';

/**
 * Specifies if tooltips should be visible. Default is true.
 */
Sidebar.prototype.enableTooltips = true;
/**
 * Specifies the delay for the tooltip. Default is 10px.
 */
Sidebar.prototype.tooltipBorder = 10;
/**
 * Specifies the delay for the tooltip. Default is 300 ms.
 */
Sidebar.prototype.tooltipDelay = 300;
/**
 * Specifies the delay for the drop target icons. Default is 200 ms.
 */
Sidebar.prototype.dropTargetDelay = 200;

/**
 * Specifies the width of the thumbnails.
 */
Sidebar.prototype.thumbWidth = 30;
/**
 * Specifies the height of the thumbnails.
 */
Sidebar.prototype.thumbHeight = 30;
/**
 * Specifies the width of the thumbnails.
 */
Sidebar.prototype.minThumbStrokeWidth = 1;
/**
 * Specifies the width of the thumbnails.
 */
Sidebar.prototype.thumbAntiAlias = true;
/**
 * Specifies the padding for the thumbnails. Default is 2.
 */
Sidebar.prototype.thumbPadding = 2;
/**
 * Specifies the border for thumbnails. Default is 1 px.
 */
Sidebar.prototype.thumbBorder = 1;

/**
 * Specifies if titles in the tooltips should be enabled.
 */
Sidebar.prototype.tooltipTitles    = true;
Sidebar.prototype.maxTooltipWidth  = 350;
Sidebar.prototype.maxTooltipHeight = 300;

Sidebar.prototype.getTooltipOffset = function()
{
    var wnd = $(this.container).parents('div:last')[0];
    return wnd ? new mxPoint(wnd.offsetLeft, wnd.offsetTop) : new mxPoint(0, 0);
};
Sidebar.prototype.showTooltip = function (elt, cells, w, h, title, showLabel, showTitle)
{
    if (this.enableTooltips && this.showTooltips)
    {
        if (this.currentElt != elt)
        {
            if (this.thread != null)
            {
                window.clearTimeout(this.thread);
                this.thread = null;
            }
            
            var show = mxUtils.bind(this, function()
            {
                // Lazy creation of the DOM nodes and graph instance
                if (this.tooltip == null)
                {
                    this.tooltip = document.createElement('div');
                    this.tooltip.className = 'geSidebarTooltip';
                    this.tooltip.style.zIndex = mxPopupMenu.prototype.zIndex - 1;
                    document.body.appendChild(this.tooltip);
                    
                    this.graph2 = new Graph(this.tooltip, null, null, this.editorUi.editor.graph.getStylesheet());
                    this.graph2.resetViewOnRootChange = false;
                    this.graph2.foldingEnabled = false;
                    this.graph2.gridEnabled = false;
                    this.graph2.autoScroll = false;
                    this.graph2.setTooltips(false);
                    this.graph2.setConnectable(false);
                    this.graph2.setEnabled(false);
                }
                
                this.graph2.model.clear();
                this.graph2.view.setTranslate(this.tooltipBorder, this.tooltipBorder);

                if (w > this.maxTooltipWidth || h > this.maxTooltipHeight)
                    this.graph2.view.scale = Math.round(Math.min(this.maxTooltipWidth / w, this.maxTooltipHeight / h) * 100) / 100;
                else
                    this.graph2.view.scale = 1;
                
                this.tooltip.style.display = 'block';
                //this.graph2.labelsVisible = (showLabel == null || showLabel);
                var fo = mxClient.NO_FO;
                mxClient.NO_FO = Editor.prototype.originalNoForeignObject;
                this.graph2.addCells(cells);
                mxClient.NO_FO = fo;
                
                var bounds = this.graph2.getGraphBounds();
                var width  = bounds.width  + 2 * this.tooltipBorder;
                var height = bounds.height + 2 * this.tooltipBorder;

                this.tooltip.style.overflow = 'visible';
                this.tooltip.style.width = width + 'px';
                var w2 = width;

                // Adds title for entry
                var showTooltipTitle = (showTitle == null || showTitle);
                if (this.tooltipTitles && showTooltipTitle && title != null && title.length > 0)
                {
                    // Tooltip width correction
                    var titleSize = mxUtils.getSizeForString(title.replace(/\n/g, "<br>"));
                    width = (width <= titleSize.width ? titleSize.width : width) + 20;
                    this.tooltip.style.width = width + 'px';

                    if (this.tooltipTitle == null)
                    {
                        this.tooltipTitle = document.createElement('div');
                        this.tooltipTitle.style.borderTop = '1px solid gray';
                        this.tooltipTitle.style.textAlign = 'center';
                        this.tooltipTitle.style.width     = '100%';
                        
                        // Oversize titles are cut-off currently. Should make tooltip wider later.
                        this.tooltipTitle.style.overflow   = 'hidden';
                        this.tooltipTitle.style.position   = 'absolute';
                        this.tooltipTitle.style.paddingTop = '6px';
                        this.tooltipTitle.style.bottom     = '6px';

                        this.tooltip.appendChild(this.tooltipTitle);
                    }
                    else
                    {
                        this.tooltipTitle.innerHTML = '';
                    }
                    
                    this.tooltipTitle.style.display = '';
                    mxUtils.write(this.tooltipTitle, title);

                    // Allows for wider labels
                    w2 = Math.min(this.maxTooltipWidth, Math.max(width, this.tooltipTitle.scrollWidth + 4));

                    var ddy = this.tooltipTitle.offsetHeight + 10;
                    height += ddy;
                    this.tooltipTitle.style.marginTop = (2 - ddy) + 'px';
                }
                else if (this.tooltipTitle != null && this.tooltipTitle.parentNode != null)
                {
                    this.tooltipTitle.style.display = 'none';
                }

                // Updates width if label is wider
                if (w2 > width)
                {
                    this.tooltip.style.width = w2 + 'px';
                }

                this.tooltip.style.height = height + 'px';
                
                var off = this.getTooltipOffset();
                var left = off.x + this.container.clientWidth + 20;
                var top  = off.y + this.container.offsetTop + elt.offsetTop - this.container.scrollTop;

                this.graph2.center(true, true, 0.5, 0.3);

                // Workaround for ignored position CSS style in IE9 (changes to relative without the following line)
                this.tooltip.style.position = 'absolute';
                this.tooltip.style.left     = left + 'px';
                this.tooltip.style.top      = top + 'px';
            });

            if (this.tooltip != null && this.tooltip.style.display != 'none')
                show();
            else
                this.thread = window.setTimeout(show, this.tooltipDelay);

            this.currentElt = elt;
        }
    }
};
Sidebar.prototype.hideTooltip = function()
{
    if (this.thread != null)
    {
        window.clearTimeout(this.thread);
        this.thread = null;
    }
    
    if (this.tooltip != null)
    {
        this.tooltip.style.display = 'none';
        this.currentElt = null;
    }
};

Sidebar.prototype.addEntry = function(tags, fn)
{
    return fn;
};
Sidebar.prototype.cloneCell = function(cell, value)
{
    var clone = cell.clone();
    if (value != null)
        clone.value = value;
    return clone;
};

Sidebar.prototype.addGeneralPalette = function(expand)
{    
    var sb = this;
    
    var fns = [
        this.createVertexTemplateEntry('text;whiteSpace=wrap;overflow=hidden;', 40, 30, 'Текст', 'Текст'),
        this.createVertexTemplateEntry('text;html=1;spacing=5;spacingTop=-20;whiteSpace=wrap;overflow=hidden;', 150, 75,'<h1>Заголовок</h1><p>Произвольный текст.</p>', 'Текстовое поле/HTML'),
        this.createVertexTemplateEntry('rectangle', 60, 30, '', 'Прямоугольник'),
        this.createVertexTemplateEntry('ellipse', 60, 30, '', 'Эллипс'),
        this.createVertexTemplateEntry('rectangle;aspect=fixed;', 30, 30, '', 'Квадрат'),
        this.createVertexTemplateEntry('ellipse;aspect=fixed;', 30, 30, '', 'Окружность'),
        this.createVertexTemplateEntry('rhombus', 30, 30, '', 'Ромб'),
        this.createVertexTemplateEntry('triangle', 30, 30, '', 'Треугольник'),
        this.createVertexTemplateEntry('trapezoid', 40, 30, '', 'Трапеция'),
        this.createVertexTemplateEntry('parallelogram', 60, 30, '', 'Параллелограм'),
        this.createVertexTemplateEntry('cylinder', 30, 40, '', 'Цилиндр'),
        this.createVertexTemplateEntry('cube', 40, 30, '', 'Куб'),
        this.createVertexTemplateEntry('cloud', 30, 30, '', 'Облако'),
        this.createVertexTemplateEntry('actor', 25, 30, '', 'Человек'),
        //this.createEdgeTemplateEntry('arrow', 60, 30, '', 'Стрелка', true, true), // <-- arrow is edge !!!
        this.createVertexTemplateEntry('singleArrow', 60, 30, '', 'Стрелка'),
        this.createVertexTemplateEntry('doubleArrow', 60, 30, '', 'Двойная стрелка'),
        this.createVertexTemplateEntry('arc', 15, 30, '', 'Дуга'),
        this.createEdgeTemplateEntry('endArrow=none;html=1;', 50, 50, '', 'Линия'),
        this.createEdgeTemplateEntry('shape=link;html=1;', 50, 50, '', 'Двойная линия'),
        this.createVertexTemplateEntry('button', 50, 30, 'ОК', 'Кнопка'),
        this.createVertexTemplateEntry('image', 30, 30, '', 'Изображение'),
        this.createVertexTemplateEntry('sound', 30, 30, '', 'Звук'),
        this.createVertexTemplateEntry('table', 150, 80, 'Таблица', 'Таблица'),
        this.createVertexTemplateEntry('swimlane', 150, 100, 'Контейнер', 'Контейнер'),
        this.addEntry('hyperlink', mxUtils.bind(this, function ()
        {
            var cell = new mxCell('WWW', new mxGeometry(0, 0, 40, 25), 'text;html=1;shape=label;strokeColor=none;fillColor=none;whiteSpace=wrap;align=center;verticalAlign=middle;fontColor=#0000EE;fontStyle=4;');
            console.log(cell)
            cell.vertex = true;
            this.graph.setLinkForCell(cell, 'https://');
            return this.createVertexTemplateFromCells([cell], cell.geometry.width, cell.geometry.height, 'Ссылка');
        })),
        this.createVertexTemplateEntry('chart', 230, 140, null, 'График'),
// @if LINKMT
        this.createVertexTemplateEntry('bmrz', 50, 50, null, 'Блок БМРЗ')
// @endif
    ];
    
    this.addPaletteFunctions('general', mxResources.get('general'), (expand != null) ? expand : true, fns);
};
Sidebar.prototype.addFSKPalette = function (expand)
{
    var fns = [
        // dynamic
        this.createVertexTemplateEntry('bus', 150, 20, null, 'Шина'),
        this.createVertexTemplateEntry('switch', 20, 20, null, 'Выключатель'),
        this.createVertexTemplateEntry('rollswitch', 20, 60, null, 'Выкатные тележки КРУ, выкатные автоматы 0.4 кВ'),
        this.createVertexTemplateEntry('rolldisconnector', 20, 60, null, 'Выкатная тележка разъединителя'),
        this.createVertexTemplateEntry('disconnector', 25, 30, null, 'Разъединитель'),
        this.createVertexTemplateEntry('separator', 25, 30, null, 'Отделитель'),
        this.createVertexTemplateEntry('ground', 25, 40, null, 'Заземляющий нож'),
        this.createVertexTemplateEntry('contactor', 25, 40, null, 'Короткозамыкатель'),
        this.createVertexTemplateEntry('rollelement', 20, 15, null, 'Выкатной элемент'),
        this.createVertexTemplateEntry('actuator', 50, 25, null, 'Задвижка'),
        this.createVertexTemplateEntry('simpleswitch', 20, 30, null, 'Простой выключатель'),
        // static
        this.createVertexTemplateEntry('wstar', 30, 20, null, "Обозначение обмотки типа 'Звезда'"),
        this.createVertexTemplateEntry('wtriangle', 30, 30, null, "Обозначение обмотки типа 'Треугольник'"),
        this.createVertexTemplateEntry('wtorn', 30, 14, null, "Обозначение обмотки типа 'Разорванный треугольник'"),
        this.createVertexTemplateEntry('fuse', 15, 30, null, "Предохранитель"),
        this.createVertexTemplateEntry('current_transformer', 25, 35, null, "Трансформатор тока"),
        this.createVertexTemplateEntry('current_transformer_ru', 20, 35, null, "Трансформатор тока"),
        this.createVertexTemplateEntry('current_transformer_fsk', 40, 30, null, "Трансформатор тока"),
        this.createVertexTemplateEntry('reactor', 30, 30, null, "Реактор"),
        this.createVertexTemplateEntry('opn',  20, 30, null, "Ограничитель перенапряжения(ОПН)"),
        this.createVertexTemplateEntry('opn_nl', 20, 30, null, "Ограничитель перенапряжения(ОПН) нелинейный"),
        this.createVertexTemplateEntry('rezistor', 15, 30, null, "Сопротивление"),
        this.createVertexTemplateEntry('condensator', 20, 20, null, "Конденсатор"),
        this.createVertexTemplateEntry('inductance', 10, 30, null, "Индуктивность"),
        this.createVertexTemplateEntry('ground1', 20, 10, null, "Заземление"),
        this.createVertexTemplateEntry('cable_cone', 30, 30, null, "Кабельная воронка"),
        this.createVertexTemplateEntry('ac', 20, 10, null, "Переменное напряжение"),
        this.createVertexTemplateEntry('load', 10, 20, null, "Нагрузка"),
        this.createVertexTemplateEntry('compensator', 20, 20, null, "Синхронный компенсатор")
    ];
        this.addPaletteFunctions('fsk', "ФСК ЕЭС", expand, fns);
};

Sidebar.prototype.addDispatcherPalette = function (expanded)
{
    var fns = [
        this.createVertexTemplateEntry('poster', 80, 40, null, "Плакат"),
        this.createVertexTemplateEntry('dispatcher_mark', 40, 40, null, "Пометка"),
    ];
    this.addPaletteFunctions('dispatcher', "Диспетчерские пометки", expanded, fns);
};

/**
 * Creates and returns the given title element.
 */
Sidebar.prototype.createTitle = function(label)
{
    var elt = document.createElement('a');
    elt.setAttribute('title', mxResources.get('sidebarTooltip'));
    elt.className = 'geTitle';
    mxUtils.write(elt, label);
    return elt;
};
/**
 * Creates a thumbnail for the given cells.
 */
Sidebar.prototype.createThumb = function(cells, width, height, parent, title, showLabel, showTitle, realWidth, realHeight)
{
    this.graph.labelsVisible = (showLabel == null || showLabel);
    var fo = mxClient.NO_FO;
    mxClient.NO_FO = Editor.prototype.originalNoForeignObject;
    this.graph.view.scaleAndTranslate(1, 0, 0);
    this.graph.addCells(cells);
    var bounds = this.graph.getGraphBounds();
    var s = Math.floor(Math.min((width - 2 * this.thumbBorder) / bounds.width,
            (height - 2 * this.thumbBorder) / bounds.height) * 100) / 100;
    this.graph.view.scaleAndTranslate(s, Math.floor((width - bounds.width * s) / 2 / s - bounds.x),
            Math.floor((height - bounds.height * s) / 2 / s - bounds.y));
    var node = null;
    
    // For supporting HTML labels in IE9 standards mode the container is cloned instead
    if (this.graph.dialect == mxConstants.DIALECT_SVG && !mxClient.NO_FO && this.graph.view.getCanvas().ownerSVGElement != null)
    {
        node = this.graph.view.getCanvas().ownerSVGElement.cloneNode(true);
    }
    else
    {
        node = this.graph.container.cloneNode(false);
        node.innerHTML = this.graph.container.innerHTML;
    }
    
    this.graph.getModel().clear();
    mxClient.NO_FO = fo;
        
    node.style.position = 'relative';
    node.style.overflow = 'hidden';
    node.style.left = this.thumbBorder + 'px';
    node.style.top = this.thumbBorder + 'px';
    node.style.width = width + 'px';
    node.style.height = height + 'px';
    node.style.visibility = '';
    node.style.minWidth = '';
    node.style.minHeight = '';
    
    parent.appendChild(node);
    
    return bounds;
};

/**
 * Creates and returns a new palette item for the given image.
 */
Sidebar.prototype.createItem = function(cells, title, showLabel, showTitle, width, height, allowCellsInserted)
{
    var elt            = document.createElement('a');
    elt.className      = 'geItem';
    elt.style.overflow = 'hidden';
    var border         = this.thumbBorder * 2;
    elt.style.width    = (this.thumbWidth + border) + 'px';
    elt.style.height   = (this.thumbHeight + border) + 'px';
    elt.style.padding  = this.thumbPadding + 'px';
    
    // Blocks default click action
    mxEvent.addListener(elt, 'click', function(evt)
    {
        mxEvent.consume(evt);
    });

    this.createThumb(cells, this.thumbWidth, this.thumbHeight, elt, title, showLabel, showTitle, width, height);
    var bounds = new mxRectangle(0, 0, width, height);
    
    if (cells.length > 1 || cells[0].vertex)
    {
        var ds = this.createDragSource(elt, 
            this.createDropHandler(cells, true, allowCellsInserted, bounds),
            this.createDragPreview(width, height), cells, bounds);
        this.addClickHandler(elt, ds, cells);
    
        // Uses guides for vertices only if enabled in graph
        ds.isGuidesEnabled = mxUtils.bind(this, function()
        {
            return this.editorUi.editor.graph.graphHandler.guidesEnabled;
        });
    }
    else if (cells[0] != null && cells[0].edge)
    {
        var ds = this.createDragSource(elt, this.createDropHandler(cells, false, allowCellsInserted,
            bounds), this.createDragPreview(width, height), cells, bounds);
        this.addClickHandler(elt, ds, cells);
    }
    
    // Shows a tooltip with the rendered cell
    if (!mxClient.IS_IOS)
    {
        mxEvent.addGestureListeners(elt, null, mxUtils.bind(this, function(evt)
        {
            if (mxEvent.isMouseEvent(evt))
                this.showTooltip(elt, cells, bounds.width, bounds.height, title, showLabel, showTitle);
        }));
    }
    
    return elt;
};

Sidebar.prototype.updateShapes = function(source, targets)
{
    var graph = this.editorUi.editor.graph;
    var sourceCellStyle = graph.getCellStyle(source);
    var result = [];
    
    graph.model.beginUpdate();
    try
    {
        var cellStyle = graph.getModel().getStyle(source);

        // Lists the styles to carry over from the existing shape
        var styles = ['shadow', 'dashed', 'dashPattern', 'fontFamily', 'fontSize', 'fontColor', 'align', 'startFill',
                      'startSize', 'endFill', 'endSize', 'strokeColor', 'strokeWidth', 'fillColor', 'gradientColor',
                      'html', 'part', 'noEdgeStyle', 'edgeStyle', 'elbow', 'childLayout', 'recursiveResize',
                      'container', 'collapsible', mxConstants.STYLE_CONNECTABLE];
        
        for (var i = 0; i < targets.length; i++)
        {
            var targetCell = targets[i];
            
            if ((graph.getModel().isVertex(targetCell) == graph.getModel().isVertex(source)) ||
                (graph.getModel().isEdge(targetCell) == graph.getModel().isEdge(source)))
            {
                var state = graph.view.getState(targetCell);
                var style = (state != null) ? state.style : graph.getCellStyle(targets[i]);
                graph.getModel().setStyle(targetCell, cellStyle);
                
                // Removes all children of composite cells
                if (state != null && mxUtils.getValue(state.style, 'composite', '0') == '1')
                {
                    var childCount = graph.model.getChildCount(targetCell);
                    
                    for (var j = childCount; j >= 0; j--)
                    {
                        graph.model.remove(graph.model.getChildAt(targetCell, j));
                    }
                }

                if (style != null)
                {                    
                    for (var j = 0; j < styles.length; j++)
                    {
                        var value = style[styles[j]];
                        
                        if (value != null)
                        {
                            graph.setCellStyles(styles[j], value, [targetCell]);
                        }
                    }
                }
                
                result.push(targetCell);
            }
        }
    }
    finally
    {
        graph.model.endUpdate();
    }
    
    return result;
};
/**
 * Creates a drop handler for inserting the given cells.
 */
Sidebar.prototype.createDropHandler = function(cells, allowSplit, allowCellsInserted, bounds)
{
    allowCellsInserted = (allowCellsInserted != null) ? allowCellsInserted : true;
    
    return mxUtils.bind(this, function(graph, evt, target, x, y, force)
    {
        var elt = (force) ? null : ((mxEvent.isTouchEvent(evt) || mxEvent.isPenEvent(evt)) ?
            document.elementFromPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt)) :
            mxEvent.getSource(evt));
        
        while (elt != null && elt != this.container)
        {
            elt = elt.parentNode;
        }
        
        if (elt == null && graph.isEnabled())
        {
            cells = graph.getImportableCells(cells);
            
            if (cells.length > 0)
            {
                graph.stopEditing();
                
                // Holding alt while mouse is released ignores drop target
                var validDropTarget = (target != null && !mxEvent.isAltDown(evt)) ? graph.isValidDropTarget(target, cells, evt) : false;
                var select = null;

                if (target != null && !validDropTarget)
                    target = null;
                
                if (!graph.isCellLocked(target || graph.getDefaultParent()))
                {
                    graph.model.beginUpdate();
                    try
                    {
                        x = Math.round(x);
                        y = Math.round(y);
                        
                        // Splits the target edge or inserts into target group
                        if (allowSplit && graph.isSplitTarget(target, cells, evt))
                        {
                            var clones = graph.cloneCells(cells);
                            graph.splitEdge(target, clones, null,
                                x - bounds.width / 2, y - bounds.height / 2);
                            select = clones;
                        }
                        else if (cells.length > 0)
                        {
                            select = graph.importCells(cells, x, y, target);
                        }
                        
                        // Executes parent layout hooks for position/order
                        if (graph.layoutManager != null)
                        {
                            var layout = graph.layoutManager.getLayout(target);
                            
                            if (layout != null)
                            {
                                var s = graph.view.scale;
                                var tr = graph.view.translate;
                                var tx = (x + tr.x) * s;
                                var ty = (y + tr.y) * s;
                                
                                for (var i = 0; i < select.length; i++)
                                {
                                    layout.moveCell(select[i], tx, ty);
                                }
                            }
                        }
    
                        if (allowCellsInserted && (evt == null || !mxEvent.isShiftDown(evt)))
                        {
                            graph.fireEvent(new mxEventObject('cellsInserted', 'cells', select));
                        }
                    }
                    catch (e)
                    {
                        this.editorUi.handleError(e);
                    }
                    finally
                    {
                        graph.model.endUpdate();
                    }
    
                    if (select != null && select.length > 0)
                    {
                        graph.scrollCellToVisible(select[0]);
                        graph.setSelectionCells(select);
                    }

                    if (graph.editAfterInsert && evt != null && mxEvent.isMouseEvent(evt) &&
                        select != null && select.length == 1)
                    {
                        window.setTimeout(function()
                        {
                            graph.startEditing(select[0]);
                        }, 0);
                    }
                }
            }
            
            mxEvent.consume(evt);
        }
    });
};
/**
 * Creates and returns a preview element for the given width and height.
 */
Sidebar.prototype.createDragPreview = function(width, height)
{
    var elt = document.createElement('div');
    elt.style.border = this.dragPreviewBorder;
    elt.style.width = width + 'px';
    elt.style.height = height + 'px';
    
    return elt;
};

/**
 * Creates a drag source for the given element.
 */
Sidebar.prototype.dropAndConnect = function(source, targets, direction, dropCellIndex, evt)
{
    var geo = this.getDropAndConnectGeometry(source, targets[dropCellIndex], direction, targets);
    
    // Targets without the new edge for selection
    var tmp = [];
    
    if (geo != null)
    {
        var graph = this.editorUi.editor.graph;
        var editingCell = null;

        graph.model.beginUpdate();
        try
        {
            var sourceGeo = graph.getCellGeometry(source);
            var geo2 = graph.getCellGeometry(targets[dropCellIndex]);

            // Handles special case where target should be ignored for stack layouts
            var targetParent = graph.model.getParent(source);
            var validLayout = true;
            
            // Ignores parent if it has a stack layout
            if (graph.layoutManager != null)
            {
                var layout = graph.layoutManager.getLayout(targetParent);
            
                // LATER: Use parent of parent if valid layout
                if (layout != null && layout.constructor == mxStackLayout)
                {
                    validLayout = false;

                    var tmp = graph.view.getState(targetParent);
                    
                    // Offsets by parent position
                    if (tmp != null)
                    {
                        var offset = new mxPoint((tmp.x / graph.view.scale - graph.view.translate.x),
                                (tmp.y / graph.view.scale - graph.view.translate.y));
                        geo.x += offset.x;
                        geo.y += offset.y;
                        var pt = geo.getTerminalPoint(false);
                        
                        if (pt != null)
                        {
                            pt.x += offset.x;
                            pt.y += offset.y;
                        }
                    }
                }
            }
            
            var dx = geo2.x;
            var dy = geo2.y;
            
            // Ignores geometry of edges
            if (graph.model.isEdge(targets[dropCellIndex]))
            {
                dx = 0;
                dy = 0;
            }
            
            var useParent = graph.model.isEdge(source) || (sourceGeo != null && !sourceGeo.relative && validLayout);
            targets = graph.importCells(targets, (geo.x - (useParent ? dx : 0)),
                    (geo.y - (useParent ? dy : 0)), (useParent) ? targetParent : null);
            tmp = targets;
            
            if (graph.model.isEdge(source))
            {
                // Adds new terminal to edge
                // LATER: Push new terminal out radially from edge start point
                graph.model.setTerminal(source, targets[dropCellIndex], direction == mxConstants.DIRECTION_NORTH);
            }
            else if (graph.model.isEdge(targets[dropCellIndex]))
            {
                // Adds new outgoing connection to vertex and clears points
                graph.model.setTerminal(targets[dropCellIndex], source, true);
                var geo3 = graph.getCellGeometry(targets[dropCellIndex]);
                geo3.points = null;
                
                if (geo3.getTerminalPoint(false) != null)
                {
                    geo3.setTerminalPoint(geo.getTerminalPoint(false), false);
                }
                else if (useParent && graph.model.isVertex(targetParent))
                {
                    // Adds parent offset to other nodes
                    var tmpState = graph.view.getState(targetParent);
                    var offset = (tmpState.cell != graph.view.currentRoot) ?
                        new mxPoint((tmpState.x / graph.view.scale - graph.view.translate.x),
                        (tmpState.y / graph.view.scale - graph.view.translate.y)) : new mxPoint(0, 0);

                    graph.cellsMoved(targets, offset.x, offset.y, null, null, true);
                }
            }
            else
            {
                geo2 = graph.getCellGeometry(targets[dropCellIndex]);
                dx = geo.x - Math.round(geo2.x);
                dy = geo.y - Math.round(geo2.y);
                geo.x = Math.round(geo2.x);
                geo.y = Math.round(geo2.y);
                graph.model.setGeometry(targets[dropCellIndex], geo);
                graph.cellsMoved(targets, dx, dy, null, null, true);
                tmp = targets.slice();
                editingCell = (tmp.length == 1) ? tmp[0] : null;
                targets.push(graph.insertEdge(null, null, '', source, targets[dropCellIndex],
                    graph.createCurrentEdgeStyle()));
            }
            
            if (evt == null || !mxEvent.isShiftDown(evt))
            {
                graph.fireEvent(new mxEventObject('cellsInserted', 'cells', targets));
            }
        }
        catch (e)
        {
            this.editorUi.handleError(e);
        }
        finally
        {
            graph.model.endUpdate();
        }
        
        if (graph.editAfterInsert && evt != null && mxEvent.isMouseEvent(evt) && editingCell != null)
        {
            window.setTimeout(function() { graph.startEditing(editingCell); }, 0);
        }
    }
    
    return tmp;
};

Sidebar.prototype.getDropAndConnectGeometry = function(source, target, direction, targets)
{
    var graph = this.editorUi.editor.graph;
    var view = graph.view;
    var keepSize = targets.length > 1;
    var geo = graph.getCellGeometry(source);
    var geo2 = graph.getCellGeometry(target);
    
    if (geo != null && geo2 != null)
    {
        geo2 = geo2.clone();

        if (graph.model.isEdge(source))
        {
            var state = graph.view.getState(source);
            var pts = state.absolutePoints;
            var p0 = pts[0];
            var pe = pts[pts.length - 1];
            
            if (direction == mxConstants.DIRECTION_NORTH)
            {
                geo2.x = p0.x / view.scale - view.translate.x - geo2.width / 2;
                geo2.y = p0.y / view.scale - view.translate.y - geo2.height / 2;
            }
            else
            {
                geo2.x = pe.x / view.scale - view.translate.x - geo2.width / 2;
                geo2.y = pe.y / view.scale - view.translate.y - geo2.height / 2;
            }
        }
        else
        {
            if (geo.relative)
            {
                var state = graph.view.getState(source);
                geo = geo.clone();
                geo.x = (state.x - view.translate.x) / view.scale;
                geo.y = (state.y - view.translate.y) / view.scale;
            }
            
            var length = graph.defaultEdgeLength;
            
            // Maintains edge length
            if (graph.model.isEdge(target) && geo2.getTerminalPoint(true) != null && geo2.getTerminalPoint(false) != null)
            {
                var p0 = geo2.getTerminalPoint(true);
                var pe = geo2.getTerminalPoint(false);
                var dx = pe.x - p0.x;
                var dy = pe.y - p0.y;
                
                length = Math.sqrt(dx * dx + dy * dy);
                
                geo2.x = geo.getCenterX();
                geo2.y = geo.getCenterY();
                geo2.width = 1;
                geo2.height = 1;
                
                if (direction == mxConstants.DIRECTION_NORTH)
                {
                    geo2.height = length
                    geo2.y = geo.y - length;
                    geo2.setTerminalPoint(new mxPoint(geo2.x, geo2.y), false);
                }
                else if (direction == mxConstants.DIRECTION_EAST)
                {
                    geo2.width = length
                    geo2.x = geo.x + geo.width;
                    geo2.setTerminalPoint(new mxPoint(geo2.x + geo2.width, geo2.y), false);
                }
                else if (direction == mxConstants.DIRECTION_SOUTH)
                {
                    geo2.height = length
                    geo2.y = geo.y + geo.height;
                    geo2.setTerminalPoint(new mxPoint(geo2.x, geo2.y + geo2.height), false);
                }
                else if (direction == mxConstants.DIRECTION_WEST)
                {
                    geo2.width = length
                    geo2.x = geo.x - length;
                    geo2.setTerminalPoint(new mxPoint(geo2.x, geo2.y), false);
                }
            }
            else
            {
                // Try match size or ignore if width or height < 45 which
                // is considered special enough to be ignored here
                if (!keepSize && geo2.width > 45 && geo2.height > 45 &&
                    geo.width > 45 && geo.height > 45)
                {
                    geo2.width = geo2.width * (geo.height / geo2.height);
                    geo2.height = geo.height;
                }
    
                geo2.x = geo.x + geo.width / 2 - geo2.width / 2;
                geo2.y = geo.y + geo.height / 2 - geo2.height / 2;

                if (direction == mxConstants.DIRECTION_NORTH)
                {
                    geo2.y = geo2.y - geo.height / 2 - geo2.height / 2 - length;
                }
                else if (direction == mxConstants.DIRECTION_EAST)
                {
                    geo2.x = geo2.x + geo.width / 2 + geo2.width / 2 + length;
                }
                else if (direction == mxConstants.DIRECTION_SOUTH)
                {
                    geo2.y = geo2.y + geo.height / 2 + geo2.height / 2 + length;
                }
                else if (direction == mxConstants.DIRECTION_WEST)
                {
                    geo2.x = geo2.x - geo.width / 2 - geo2.width / 2 - length;
                }
                
                // Adds offset to match cells without connecting edge
                if (graph.model.isEdge(target) && geo2.getTerminalPoint(true) != null && target.getTerminal(false) != null)
                {
                    var targetGeo = graph.getCellGeometry(target.getTerminal(false));
                    
                    if (targetGeo != null)
                    {
                        if (direction == mxConstants.DIRECTION_NORTH)
                        {
                            geo2.x -= targetGeo.getCenterX();
                            geo2.y -= targetGeo.getCenterY() + targetGeo.height / 2;
                        }
                        else if (direction == mxConstants.DIRECTION_EAST)
                        {
                            geo2.x -= targetGeo.getCenterX() - targetGeo.width / 2;
                            geo2.y -= targetGeo.getCenterY();
                        }
                        else if (direction == mxConstants.DIRECTION_SOUTH)
                        {
                            geo2.x -= targetGeo.getCenterX();
                            geo2.y -= targetGeo.getCenterY() - targetGeo.height / 2;
                        }
                        else if (direction == mxConstants.DIRECTION_WEST)
                        {
                            geo2.x -= targetGeo.getCenterX() + targetGeo.width / 2;
                            geo2.y -= targetGeo.getCenterY();
                        }
                    }
                }
            }
        }
    }
    
    return geo2;
};
/**
 * Creates a drag source for the given element.
 */
Sidebar.prototype.createDragSource = function(elt, dropHandler, preview, cells, bounds)
{
    // Checks if the cells contain any vertices
    var ui = this.editorUi;
    var graph = ui.editor.graph;
    var freeSourceEdge = null;
    var firstVertex = null;
    var sidebar = this;
    
    for (var i = 0; i < cells.length; i++)
    {
        if (firstVertex == null && this.editorUi.editor.graph.model.isVertex(cells[i]))
        {
            firstVertex = i;
        }
        else if (freeSourceEdge == null && this.editorUi.editor.graph.model.isEdge(cells[i]) &&
                this.editorUi.editor.graph.model.getTerminal(cells[i], true) == null)
        {
            freeSourceEdge = i;
        }
        
        if (firstVertex != null && freeSourceEdge != null)
        {
            break;
        }
    }
    
    var dragSource = mxUtils.makeDraggable(elt, this.editorUi.editor.graph, mxUtils.bind(this, function(graph, evt, target, x, y)
    {
        if (this.updateThread != null)
        {
            window.clearTimeout(this.updateThread);
        }
        
        if (cells != null && currentStyleTarget != null && activeArrow == styleTarget)
        {
            var tmp = graph.isCellSelected(currentStyleTarget.cell) ? graph.getSelectionCells() : [currentStyleTarget.cell];
            var updatedCells = this.updateShapes((graph.model.isEdge(currentStyleTarget.cell)) ? cells[0] : cells[firstVertex], tmp);
            graph.setSelectionCells(updatedCells);
        }
        else if (cells != null && activeArrow != null && currentTargetState != null && activeArrow != styleTarget)
        {
            var index = (graph.model.isEdge(currentTargetState.cell) || freeSourceEdge == null) ? firstVertex : freeSourceEdge;
            graph.setSelectionCells(this.dropAndConnect(currentTargetState.cell, cells, direction, index, evt));
        }
        else
        {
            dropHandler.apply(this, arguments);
        }
        
        if (this.editorUi.hoverIcons != null)
        {
            this.editorUi.hoverIcons.update(graph.view.getState(graph.getSelectionCell()));
        }
    }), preview, 0, 0, graph.autoscroll, true, true);
    
    // Stops dragging if cancel is pressed
    graph.addListener(mxEvent.ESCAPE, function(sender, evt)
    {
        if (dragSource.isActive())
        {
            dragSource.reset();
        }
    });

    // Overrides mouseDown to ignore popup triggers
    var mouseDown = dragSource.mouseDown;
    
    dragSource.mouseDown = function(evt)
    {
        if (!mxEvent.isPopupTrigger(evt) && !mxEvent.isMultiTouchEvent(evt))
        {
            graph.stopEditing();
            mouseDown.apply(this, arguments);
        }
    };

    function createArrow(img, tooltip)
    {
        var arrow = mxUtils.createImage(img.src);
        arrow.style.width = img.width + 'px';
        arrow.style.height = img.height + 'px';
        
        if (tooltip != null)
            arrow.setAttribute('title', tooltip);
        
        mxUtils.setOpacity(arrow, (img == this.refreshTarget) ? 30 : 20);
        arrow.style.position = 'absolute';
        arrow.style.cursor = 'crosshair';
        
        return arrow;
    };

    var currentTargetState = null;
    var currentStateHandle = null;
    var currentStyleTarget = null;
    var activeTarget = false;
    
    var arrowUp = createArrow(this.triangleUp, mxResources.get('connect'));
    var arrowRight = createArrow(this.triangleRight, mxResources.get('connect'));
    var arrowDown = createArrow(this.triangleDown, mxResources.get('connect'));
    var arrowLeft = createArrow(this.triangleLeft, mxResources.get('connect'));
    var styleTarget = createArrow(this.refreshTarget, mxResources.get('replace'));
    // Workaround for actual parentNode not being updated in old IE
    var styleTargetParent = null;
    var roundSource = createArrow(this.roundDrop);
    var roundTarget = createArrow(this.roundDrop);
    var direction = mxConstants.DIRECTION_NORTH;
    var activeArrow = null;
    
    function checkArrow(x, y, bounds, arrow)
    {
        if (arrow.parentNode != null)
        {
            if (mxUtils.contains(bounds, x, y))
            {
                mxUtils.setOpacity(arrow, 100);
                activeArrow = arrow;
            }
            else
            {
                mxUtils.setOpacity(arrow, (arrow == styleTarget) ? 30 : 20);
            }
        }
        
        return bounds;
    };
    
    // Hides guides and preview if target is active
    var dsCreatePreviewElement = dragSource.createPreviewElement;
    
    // Stores initial size of preview element
    dragSource.createPreviewElement = function(graph)
    {
        var elt = dsCreatePreviewElement.apply(this, arguments);
        
        // Pass-through events required to tooltip on replace shape
        elt.style.pointerEvents = 'none';
        
        this.previewElementWidth = elt.style.width;
        this.previewElementHeight = elt.style.height;
        
        return elt;
    };
    
    // Shows/hides hover icons
    var dragEnter = dragSource.dragEnter;
    dragSource.dragEnter = function(graph, evt)
    {
        if (ui.hoverIcons != null)
        {
            ui.hoverIcons.setDisplay('none');
        }
        
        dragEnter.apply(this, arguments);
    };
    
    var dragExit = dragSource.dragExit;
    dragSource.dragExit = function(graph, evt)
    {
        if (ui.hoverIcons != null)
        {
            ui.hoverIcons.setDisplay('');
        }
        
        dragExit.apply(this, arguments);
    };
    
    dragSource.dragOver = function(graph, evt)
    {
        mxDragSource.prototype.dragOver.apply(this, arguments);

        if (this.currentGuide != null && activeArrow != null)
        {
            this.currentGuide.hide();
        }

        if (this.previewElement != null)
        {
            var view = graph.view;
            
            if (currentStyleTarget != null && activeArrow == styleTarget)
            {
                this.previewElement.style.display = (graph.model.isEdge(currentStyleTarget.cell)) ? 'none' : '';
                
                this.previewElement.style.left = currentStyleTarget.x + 'px';
                this.previewElement.style.top = currentStyleTarget.y + 'px';
                this.previewElement.style.width = currentStyleTarget.width + 'px';
                this.previewElement.style.height = currentStyleTarget.height + 'px';
            }
            else if (currentTargetState != null && activeArrow != null)
            {
                var index = (graph.model.isEdge(currentTargetState.cell) || freeSourceEdge == null) ? firstVertex : freeSourceEdge;
                var geo = sidebar.getDropAndConnectGeometry(currentTargetState.cell, cells[index], direction, cells);
                var geo2 = (!graph.model.isEdge(currentTargetState.cell)) ? graph.getCellGeometry(currentTargetState.cell) : null;
                var geo3 = graph.getCellGeometry(cells[index]);
                var parent = graph.model.getParent(currentTargetState.cell);
                var dx = view.translate.x * view.scale;
                var dy = view.translate.y * view.scale;
                
                if (geo2 != null && !geo2.relative && graph.model.isVertex(parent) && parent != view.currentRoot)
                {
                    var pState = view.getState(parent);
                    
                    dx = pState.x;
                    dy = pState.y;
                }
                
                var dx2 = geo3.x;
                var dy2 = geo3.y;

                // Ignores geometry of edges
                if (graph.model.isEdge(cells[index]))
                {
                    dx2 = 0;
                    dy2 = 0;
                }
                
                // Shows preview at drop location
                this.previewElement.style.left = ((geo.x - dx2) * view.scale + dx) + 'px';
                this.previewElement.style.top = ((geo.y - dy2) * view.scale + dy) + 'px';
                
                if (cells.length == 1)
                {
                    this.previewElement.style.width = (geo.width * view.scale) + 'px';
                    this.previewElement.style.height = (geo.height * view.scale) + 'px';
                }
                
                this.previewElement.style.display = '';
            }
            else if (dragSource.currentHighlight.state != null &&
                graph.model.isEdge(dragSource.currentHighlight.state.cell))
            {
                // Centers drop cells when splitting edges
                this.previewElement.style.left = Math.round(parseInt(this.previewElement.style.left) -
                    bounds.width * view.scale / 2) + 'px';
                this.previewElement.style.top = Math.round(parseInt(this.previewElement.style.top) -
                    bounds.height * view.scale / 2) + 'px';
            }
            else
            {
                this.previewElement.style.width = this.previewElementWidth;
                this.previewElement.style.height = this.previewElementHeight;
                this.previewElement.style.display = '';
            }
        }
    };
    
    var startTime = new Date().getTime();
    var timeOnTarget = 0;
    var prev = null;
    
    // Gets source cell style to compare shape below
    var sourceCellStyle = this.editorUi.editor.graph.getCellStyle(cells[0]);
    
    // Allows drop into cell only if target is a valid root
    dragSource.getDropTarget = mxUtils.bind(this, function(graph, x, y, evt)
    {
        // Alt means no targets at all
        // LATER: Show preview where result will go
        var cell = (!mxEvent.isAltDown(evt) && cells != null) ? graph.getCellAt(x, y) : null;
        
        // Uses connectable parent vertex if one exists
        if (cell != null && !this.graph.isCellConnectable(cell))
        {
            var parent = this.graph.getModel().getParent(cell);
            
            if (this.graph.getModel().isVertex(parent) && this.graph.isCellConnectable(parent))
            {
                cell = parent;
            }
        }
        
        // Ignores locked cells
        if (graph.isCellLocked(cell))
            cell = null;
        
        var state = graph.view.getState(cell);
        activeArrow = null;
        var bbox = null;

        // Time on target
        if (prev != state)
        {
            prev = state;
            startTime = new Date().getTime();
            timeOnTarget = 0;

            if (this.updateThread != null)
            {
                window.clearTimeout(this.updateThread);
            }
            
            if (state != null)
            {
                this.updateThread = window.setTimeout(function()
                {
                    if (activeArrow == null)
                    {
                        prev = state;
                        dragSource.getDropTarget(graph, x, y, evt);
                    }
                }, this.dropTargetDelay + 10);
            }
        }
        else
        {
            timeOnTarget = new Date().getTime() - startTime;
        }

        // Shift means disabled, delayed on cells with children, shows after this.dropTargetDelay, hides after 2500ms
        if (timeOnTarget < 2500 && state != null && !mxEvent.isShiftDown(evt) &&
            // If shape is equal or target has no stroke, fill and gradient then use longer delay except for images
            (((mxUtils.getValue(state.style, mxConstants.STYLE_SHAPE) != mxUtils.getValue(sourceCellStyle, mxConstants.STYLE_SHAPE) &&
            (mxUtils.getValue(state.style, mxConstants.STYLE_STROKECOLOR, mxConstants.NONE) != mxConstants.NONE ||
            mxUtils.getValue(state.style, mxConstants.STYLE_FILLCOLOR, mxConstants.NONE) != mxConstants.NONE ||
            mxUtils.getValue(state.style, mxConstants.STYLE_GRADIENTCOLOR, mxConstants.NONE) != mxConstants.NONE)) ||
            mxUtils.getValue(sourceCellStyle, mxConstants.STYLE_SHAPE) == 'image') ||
            timeOnTarget > 1500 || graph.model.isEdge(state.cell)) && (timeOnTarget > this.dropTargetDelay) && 
            ((graph.model.isVertex(state.cell) && firstVertex != null) ||
            (graph.model.isEdge(state.cell) && graph.model.isEdge(cells[0]))))
        {
            currentStyleTarget = state;
            var tmp = (graph.model.isEdge(state.cell)) ? graph.view.getPoint(state) :
                new mxPoint(state.getCenterX(), state.getCenterY());
            tmp = new mxRectangle(tmp.x - this.refreshTarget.width / 2, tmp.y - this.refreshTarget.height / 2,
                this.refreshTarget.width, this.refreshTarget.height);
            
            styleTarget.style.left = Math.floor(tmp.x) + 'px';
            styleTarget.style.top = Math.floor(tmp.y) + 'px';
            
            if (styleTargetParent == null)
            {
                graph.container.appendChild(styleTarget);
                styleTargetParent = styleTarget.parentNode;
            }
            
            checkArrow(x, y, tmp, styleTarget);
        }
        // Does not reset on ignored edges
        else if (currentStyleTarget == null || !mxUtils.contains(currentStyleTarget, x, y) ||
            (timeOnTarget > 1500 && !mxEvent.isShiftDown(evt)))
        {
            currentStyleTarget = null;
            
            if (styleTargetParent != null)
            {
                styleTarget.parentNode.removeChild(styleTarget);
                styleTargetParent = null;
            }
        }
        else if (currentStyleTarget != null && styleTargetParent != null)
        {
            // Sets active Arrow as side effect
            var tmp = (graph.model.isEdge(currentStyleTarget.cell)) ? graph.view.getPoint(currentStyleTarget) : new mxPoint(currentStyleTarget.getCenterX(), currentStyleTarget.getCenterY());
            tmp = new mxRectangle(tmp.x - this.refreshTarget.width / 2, tmp.y - this.refreshTarget.height / 2,
                this.refreshTarget.width, this.refreshTarget.height);
            checkArrow(x, y, tmp, styleTarget);
        }
        
        // Checks if inside bounds
        if (activeTarget && currentTargetState != null && !mxEvent.isAltDown(evt) && activeArrow == null)
        {
            // LATER: Use hit-detection for edges
            bbox = mxRectangle.fromRectangle(currentTargetState);
            
            if (graph.model.isEdge(currentTargetState.cell))
            {
                var pts = currentTargetState.absolutePoints;
                
                if (roundSource.parentNode != null)
                {
                    var p0 = pts[0];
                    bbox.add(checkArrow(x, y, new mxRectangle(p0.x - this.roundDrop.width / 2,
                        p0.y - this.roundDrop.height / 2, this.roundDrop.width, this.roundDrop.height), roundSource));
                }
                
                if (roundTarget.parentNode != null)
                {
                    var pe = pts[pts.length - 1];
                    bbox.add(checkArrow(x, y, new mxRectangle(pe.x - this.roundDrop.width / 2,
                        pe.y - this.roundDrop.height / 2,
                        this.roundDrop.width, this.roundDrop.height), roundTarget));
                }
            }
            else
            {
                var bds = mxRectangle.fromRectangle(currentTargetState);
                
                // Uses outer bounding box to take rotation into account
                if (currentTargetState.shape != null && currentTargetState.shape.boundingBox != null)
                {
                    bds = mxRectangle.fromRectangle(currentTargetState.shape.boundingBox);
                }

                bds.grow(this.graph.tolerance);
                bds.grow(HoverIcons.prototype.arrowSpacing);
                
                var handler = this.graph.selectionCellsHandler.getHandler(currentTargetState.cell);
                
                if (handler != null)
                {
                    bds.x -= handler.horizontalOffset / 2;
                    bds.y -= handler.verticalOffset / 2;
                    bds.width += handler.horizontalOffset;
                    bds.height += handler.verticalOffset;
                    
                    // Adds bounding box of rotation handle to avoid overlap
                    if (handler.rotationShape != null && handler.rotationShape.node != null &&
                        handler.rotationShape.node.style.visibility != 'hidden' &&
                        handler.rotationShape.node.style.display != 'none' &&
                        handler.rotationShape.boundingBox != null)
                    {
                        bds.add(handler.rotationShape.boundingBox);
                    }
                }
                
                bbox.add(checkArrow(x, y, new mxRectangle(currentTargetState.getCenterX() - this.triangleUp.width / 2,
                    bds.y - this.triangleUp.height, this.triangleUp.width, this.triangleUp.height), arrowUp));
                bbox.add(checkArrow(x, y, new mxRectangle(bds.x + bds.width,
                    currentTargetState.getCenterY() - this.triangleRight.height / 2,
                    this.triangleRight.width, this.triangleRight.height), arrowRight));
                bbox.add(checkArrow(x, y, new mxRectangle(currentTargetState.getCenterX() - this.triangleDown.width / 2,
                        bds.y + bds.height, this.triangleDown.width, this.triangleDown.height), arrowDown));
                bbox.add(checkArrow(x, y, new mxRectangle(bds.x - this.triangleLeft.width,
                        currentTargetState.getCenterY() - this.triangleLeft.height / 2,
                        this.triangleLeft.width, this.triangleLeft.height), arrowLeft));
            }
            
            // Adds tolerance
            if (bbox != null)
                bbox.grow(10);
        }
        
        direction = mxConstants.DIRECTION_NORTH;
        
        if (activeArrow == arrowRight)
        {
            direction = mxConstants.DIRECTION_EAST;
        }
        else if (activeArrow == arrowDown || activeArrow == roundTarget)
        {
            direction = mxConstants.DIRECTION_SOUTH;
        }
        else if (activeArrow == arrowLeft)
        {
            direction = mxConstants.DIRECTION_WEST;
        }
        
        if (currentStyleTarget != null && activeArrow == styleTarget)
        {
            state = currentStyleTarget;
        }

        var validTarget = (firstVertex == null || graph.isCellConnectable(cells[firstVertex])) &&
            ((graph.model.isEdge(cell) && firstVertex != null) ||
            (graph.model.isVertex(cell) && graph.isCellConnectable(cell)));
        
        // Drop arrows shown after this.dropTargetDelay, hidden after 5 secs, switches arrows after 500ms
        if ((currentTargetState != null && timeOnTarget >= 5000) ||
            (currentTargetState != state &&
            (bbox == null || !mxUtils.contains(bbox, x, y) ||
            (timeOnTarget > 500 && activeArrow == null && validTarget))))
        {
            activeTarget = false;
            currentTargetState = ((timeOnTarget < 5000 && timeOnTarget > this.dropTargetDelay) || graph.model.isEdge(cell)) ? state : null;

            if (currentTargetState != null && validTarget)
            {
                var elts = [roundSource, roundTarget, arrowUp, arrowRight, arrowDown, arrowLeft];
                
                for (var i = 0; i < elts.length; i++)
                {
                    if (elts[i].parentNode != null)
                    {
                        elts[i].parentNode.removeChild(elts[i]);
                    }
                }
                
                if (graph.model.isEdge(cell))
                {
                    var pts = state.absolutePoints;
                    
                    if (pts != null)
                    {
                        var p0 = pts[0];
                        var pe = pts[pts.length - 1];
                        var tol = graph.tolerance;
                        var box = new mxRectangle(x - tol, y - tol, 2 * tol, 2 * tol);
                        
                        roundSource.style.left = Math.floor(p0.x - this.roundDrop.width / 2) + 'px';
                        roundSource.style.top = Math.floor(p0.y - this.roundDrop.height / 2) + 'px';
                        
                        roundTarget.style.left = Math.floor(pe.x - this.roundDrop.width / 2) + 'px';
                        roundTarget.style.top = Math.floor(pe.y - this.roundDrop.height / 2) + 'px';
                        
                        if (graph.model.getTerminal(cell, true) == null)
                        {
                            graph.container.appendChild(roundSource);
                        }
                        
                        if (graph.model.getTerminal(cell, false) == null)
                        {
                            graph.container.appendChild(roundTarget);
                        }
                    }
                }
                else
                {
                    var bds = mxRectangle.fromRectangle(state);
                    
                    // Uses outer bounding box to take rotation into account
                    if (state.shape != null && state.shape.boundingBox != null)
                    {
                        bds = mxRectangle.fromRectangle(state.shape.boundingBox);
                    }

                    bds.grow(this.graph.tolerance);
                    bds.grow(HoverIcons.prototype.arrowSpacing);
                    
                    var handler = this.graph.selectionCellsHandler.getHandler(state.cell);
                    if (handler != null)
                    {
                        bds.x -= handler.horizontalOffset / 2;
                        bds.y -= handler.verticalOffset / 2;
                        bds.width += handler.horizontalOffset;
                        bds.height += handler.verticalOffset;
                        
                        // Adds bounding box of rotation handle to avoid overlap
                        if (handler.rotationShape != null && handler.rotationShape.node != null &&
                            handler.rotationShape.node.style.visibility != 'hidden' &&
                            handler.rotationShape.node.style.display != 'none' &&
                            handler.rotationShape.boundingBox != null)
                        {
                            bds.add(handler.rotationShape.boundingBox);
                        }
                    }
                    
                    arrowUp.style.left = Math.floor(state.getCenterX() - this.triangleUp.width / 2) + 'px';
                    arrowUp.style.top  = Math.floor(bds.y - this.triangleUp.height) + 'px';
                    
                    arrowRight.style.left = Math.floor(bds.x + bds.width) + 'px';
                    arrowRight.style.top  = Math.floor(state.getCenterY() - this.triangleRight.height / 2) + 'px';
                    
                    arrowDown.style.left = arrowUp.style.left
                    arrowDown.style.top  = Math.floor(bds.y + bds.height) + 'px';
                    
                    arrowLeft.style.left = Math.floor(bds.x - this.triangleLeft.width) + 'px';
                    arrowLeft.style.top  = arrowRight.style.top;
                    
                    if (state.style['portConstraint'] != 'eastwest')
                    {
                        graph.container.appendChild(arrowUp);
                        graph.container.appendChild(arrowDown);
                    }

                    graph.container.appendChild(arrowRight);
                    graph.container.appendChild(arrowLeft);
                }
                
                // Hides handle for cell under mouse
                if (state != null)
                {
                    currentStateHandle = graph.selectionCellsHandler.getHandler(state.cell);
                    if (currentStateHandle != null && currentStateHandle.setHandlesVisible != null)
                    {
                        currentStateHandle.setHandlesVisible(false);
                    }
                }
                
                activeTarget = true;
            }
            else
            {
                var elts = [roundSource, roundTarget, arrowUp, arrowRight, arrowDown, arrowLeft];
                
                for (var i = 0; i < elts.length; i++)
                {
                    if (elts[i].parentNode != null)
                    {
                        elts[i].parentNode.removeChild(elts[i]);
                    }
                }
            }
        }

        if (!activeTarget && currentStateHandle != null)
        {
            currentStateHandle.setHandlesVisible(true);
        }
        
        // Handles drop target
        var target = ((!mxEvent.isAltDown(evt) || mxEvent.isShiftDown(evt)) &&
            !(currentStyleTarget != null && activeArrow == styleTarget)) ?
            mxDragSource.prototype.getDropTarget.apply(this, arguments) : null;
        var model = graph.getModel();
        
        if (target != null)
        {
            if (activeArrow != null || !graph.isSplitTarget(target, cells, evt))
            {
                // Selects parent group as drop target
                while (target != null && !graph.isValidDropTarget(target, cells, evt) && model.isVertex(model.getParent(target)))
                {
                    target = model.getParent(target);
                }
                
                if (graph.view.currentRoot == target || (!graph.isValidRoot(target) &&
                    graph.getModel().getChildCount(target) == 0) ||
                    graph.isCellLocked(target) || model.isEdge(target))
                {
                    target = null;
                }
            }
        }
        
        return target;
    });
    
    dragSource.stopDrag = function()
    {
        mxDragSource.prototype.stopDrag.apply(this, arguments);
        
        var elts = [roundSource, roundTarget, styleTarget, arrowUp, arrowRight, arrowDown, arrowLeft];
        
        for (var i = 0; i < elts.length; i++)
        {
            if (elts[i].parentNode != null)
            {
                elts[i].parentNode.removeChild(elts[i]);
            }
        }
        
        if (currentTargetState != null && currentStateHandle != null)
        {
            currentStateHandle.reset();
        }
        
        currentStateHandle = null;
        currentTargetState = null;
        currentStyleTarget = null;
        styleTargetParent = null;
        activeArrow = null;
    };
    
    return dragSource;
};

/**
 * Adds a handler for inserting the cell with a single click.
 */
Sidebar.prototype.itemClicked = function(cells, ds, evt, elt)
{
    var graph = this.editorUi.editor.graph;
    graph.container.focus();
    
    // Alt+Click inserts and connects
    if (mxEvent.isAltDown(evt) && graph.getSelectionCount() == 1 && graph.model.isVertex(graph.getSelectionCell()))
    {
        var firstVertex = null;
        
        for (var i = 0; i < cells.length && firstVertex == null; i++)
        {
            if (graph.model.isVertex(cells[i]))
            {
                firstVertex = i;
            }
        }
        
        if (firstVertex != null)
        {
            graph.setSelectionCells(this.dropAndConnect(graph.getSelectionCell(), cells, (mxEvent.isMetaDown(evt) || mxEvent.isControlDown(evt)) ?
                (mxEvent.isShiftDown(evt) ? mxConstants.DIRECTION_WEST : mxConstants.DIRECTION_NORTH) : 
                (mxEvent.isShiftDown(evt) ? mxConstants.DIRECTION_EAST : mxConstants.DIRECTION_SOUTH),
                firstVertex, evt));
            graph.scrollCellToVisible(graph.getSelectionCell());
        }
    }
    // Shift+Click updates shape
    else if (mxEvent.isShiftDown(evt) && !graph.isSelectionEmpty())
    {
        this.updateShapes(cells[0], graph.getSelectionCells());
        graph.scrollCellToVisible(graph.getSelectionCell());
    }
    else
    {
        var pt = graph.getFreeInsertPoint();
        if (mxEvent.isAltDown(evt))
        {
            var bounds = graph.getGraphBounds();
            var tr = graph.view.translate;
            var s = graph.view.scale;
            pt.x = bounds.x / s - tr.x + bounds.width / s + graph.gridSize;
            pt.y = bounds.y / s - tr.y;
        }
        
        ds.drop(graph, evt, null, pt.x, pt.y, true);
        
        if (this.editorUi.hoverIcons != null && (mxEvent.isTouchEvent(evt) || mxEvent.isPenEvent(evt)))
            this.editorUi.hoverIcons.update(graph.view.getState(graph.getSelectionCell()));
    }
};

/**
 * Adds a handler for inserting the cell with a single click.
 */
Sidebar.prototype.addClickHandler = function(elt, ds, cells)
{
    var graph = this.editorUi.editor.graph;
    var oldMouseDown = ds.mouseDown;
    var oldMouseMove = ds.mouseMove;
    var oldMouseUp = ds.mouseUp;
    var tol = graph.tolerance;
    var first = null;
    var sb = this;
    
    ds.mouseDown =function(evt)
    {
        oldMouseDown.apply(this, arguments);
        first = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt));
        
        if (this.dragElement != null)
        {
            this.dragElement.style.display = 'none';
            mxUtils.setOpacity(elt, 50);
        }
    };
    
    ds.mouseMove = function(evt)
    {
        if (this.dragElement != null && this.dragElement.style.display == 'none' &&
            first != null && (Math.abs(first.x - mxEvent.getClientX(evt)) > tol ||
            Math.abs(first.y - mxEvent.getClientY(evt)) > tol))
        {
            this.dragElement.style.display = '';
            mxUtils.setOpacity(elt, 100);
        }
        
        oldMouseMove.apply(this, arguments);
    };
    
    ds.mouseUp = function(evt)
    {
        if (!mxEvent.isPopupTrigger(evt) && this.currentGraph == null &&
            this.dragElement != null && this.dragElement.style.display == 'none')
        {
            sb.itemClicked(cells, ds, evt, elt);
        }

        oldMouseUp.apply(ds, arguments);
        mxUtils.setOpacity(elt, 100);
        first = null;
        
        // Blocks tooltips on this element after single click
        sb.currentElt = elt;
    };
};

Sidebar.prototype.createVertexTemplateEntry = function (style, width, height, value, title, showLabel, showTitle)
{
    return this.addEntry(title, mxUtils.bind(this, function ()
    {
        return this.createVertexTemplate(style, width, height, value, title, showLabel, showTitle);
    }));
};
Sidebar.prototype.createVertexTemplate = function(style, width, height, value, title, showLabel, showTitle, allowCellsInserted)
{
    var cells = [new mxCell((value != null) ? value : '', new mxGeometry(0, 0, width, height), style)];
    console.log(cells)
    cells[0].vertex = true;
    return this.createItem(cells, title, showLabel, showTitle, width, height, allowCellsInserted);
};
Sidebar.prototype.createEdgeTemplateEntry = function(style, width, height, value, title, showLabel, allowCellsInserted)
{
    return this.addEntry(title, mxUtils.bind(this, function()
    {
        var cell = new mxCell((value != null) ? value : '', new mxGeometry(0, 0, width, height), style);
        console.log(cell)
        cell.geometry.setTerminalPoint(new mxPoint(0, height), true);
        cell.geometry.setTerminalPoint(new mxPoint(width, 0), false);
        cell.geometry.relative = true;
        cell.edge = true;
        return this.createItem([cell], title, showLabel, true, width, height, allowCellsInserted);
    }));
};
Sidebar.prototype.createVertexTemplateFromCells = function (cells, width, height, title, showLabel, showTitle, allowCellsInserted)
{
    // Use this line to convert calls to this function with lots of boilerplate code for creating cells
    //console.trace('xml', Graph.compress(mxUtils.getXml(this.graph.encodeCells(cells))), cells);
    return this.createItem(cells, title, showLabel, showTitle, width, height, allowCellsInserted);
};

Sidebar.prototype.addPaletteFunctions = function(id, title, expanded, fns)
{
    this.addPalette(id, title, expanded, mxUtils.bind(this, function(content)
    {
        for (var i = 0; i < fns.length; i++)
        {
            content.appendChild(fns[i](content));
        }
    }));
};
Sidebar.prototype.addPalette = function(id, title, expanded, onInit)
{
    var elt = this.createTitle(title);
    this.container.appendChild(elt);
    
    var div = document.createElement('div');
    div.className = 'geSidebar';
    
    // Disables built-in pan and zoom in IE10 and later
    if (mxClient.IS_POINTER)
        div.style.touchAction = 'none';

    if (expanded)
    {
        onInit(div);
        onInit = null;
    }
    else
    {
        div.style.display = 'none';
    }
    
    this.addFoldingHandler(elt, div, onInit);
    
    var outer = document.createElement('div');
    outer.appendChild(div);
    this.container.appendChild(outer);
    
    // Keeps references to the DOM nodes
    if (id != null)
        this.palettes[id] = [elt, outer];
    
    return div;
};

Sidebar.prototype.addFoldingHandler = function(title, content, funct)
{
    var initialized = false;

    // Avoids mixed content warning in IE6-8
    if (!mxClient.IS_IE || document.documentMode >= 8)
    {
        title.style.backgroundImage = (content.style.display == 'none') ?
            'url(\'' + this.collapsedImage + '\')' : 'url(\'' + this.expandedImage + '\')';
    }
    
    title.style.backgroundRepeat = 'no-repeat';
    title.style.backgroundPosition = '0% 50%';

    mxEvent.addListener(title, 'click', mxUtils.bind(this, function(evt)
    {
        if (content.style.display == 'none')
        {
            if (!initialized)
            {
                initialized = true;

                if (funct != null)
                {
                    // Wait cursor does not show up on Mac
                    title.style.cursor = 'wait';
                    var prev = title.innerHTML;
                    title.innerHTML = mxResources.get('loading') + '...';
                    
                    window.setTimeout(function()
                    {
                        content.style.display = 'block';
                        title.style.cursor = '';
                        title.innerHTML = prev;

                        var fo = mxClient.NO_FO;
                        mxClient.NO_FO = Editor.prototype.originalNoForeignObject;
                        funct(content, title);
                        mxClient.NO_FO = fo;
                    }, (mxClient.IS_FF) ? 20 : 0);
                }
                else
                    content.style.display = 'block';
            }
            else
                content.style.display = 'block';
            
            title.style.backgroundImage = 'url(\'' + this.expandedImage + '\')';
        }
        else
        {
            title.style.backgroundImage = 'url(\'' + this.collapsedImage + '\')';
            content.style.display = 'none';
        }
        
        mxEvent.consume(evt);
    }));
    
    // Prevents focus
    mxEvent.addListener(title, (mxClient.IS_POINTER) ? 'pointerdown' : 'mousedown', mxUtils.bind(this, function(evt)
    {
        evt.preventDefault();
    }));
};

Sidebar.prototype.removePalette = function(id)
{
    var elts = this.palettes[id];
    if (elts)
    {
        this.palettes[id] = null;
        for (var i = 0; i < elts.length; i++)
            this.container.removeChild(elts[i]);
        return true;
    }
    return false;
};
Sidebar.prototype.destroy = function()
{
    if (this.graph != null)
    {
        if (this.graph.container != null && this.graph.container.parentNode != null)
            this.graph.container.parentNode.removeChild(this.graph.container);
        this.graph.destroy();
        this.graph = null;
    }
    
    if (this.pointerUpHandler != null)
    {
        mxEvent.removeListener(document, (mxClient.IS_POINTER) ? 'pointerup' : 'mouseup', this.pointerUpHandler);
        this.pointerUpHandler = null;
    }

    if (this.pointerDownHandler != null)
    {
        mxEvent.removeListener(document, (mxClient.IS_POINTER) ? 'pointerdown' : 'mousedown', this.pointerDownHandler);
        this.pointerDownHandler = null;
    }
    
    if (this.pointerMoveHandler != null)
    {
        mxEvent.removeListener(document, (mxClient.IS_POINTER) ? 'pointermove' : 'mousemove', this.pointerMoveHandler);
        this.pointerMoveHandler = null;
    }
    
    if (this.pointerOutHandler != null)
    {
        mxEvent.removeListener(document, (mxClient.IS_POINTER) ? 'pointerout' : 'mouseout', this.pointerOutHandler);
        this.pointerOutHandler = null;
    }
};


//Bindings.js

// import $ from "jquery";
// import * as mxgraph from 'mxgraph';
// import { Base64 } from 'js-base64';
// import { API } from './scada'
// import { VCLASS } from './Init'
// import 
// { 
//   HELP, 
//   GUID, 
//   isDefined, 
//   AJAX, 
//   isNullOrEmpty, 
//   getExtension, 
//   parseNumber 
// } from './client'
// import Chart from "chart.js"
// import * as webix from 'webix/webix.js';
// import 'webix/webix.css';
// import moment from 'moment';
// const {
//   $$
//   } = webix

// let { 
//     mxGraphModel, 
//     mxGraphView, 
//     mxUtils, 
//     mxResources, 
//     mxConstants,
//     mxEvent,
//     mxCell,
//     mxGeometry,
//     mxCodecRegistry,

// } = mxgraph();

//export default function BindingsHandler (editorUi) {

function BindingsHandler (editorUi) {
    webix.protoUI(
      {
        name: 'link',
        $init: function (config) {
          this.config = config;
          this.config.icon = 'wxi-trash';
          this.config.readonly = true;
          this.config.attributes = { drop_target: true };
  
          this.config.bind = mxUtils.bind(this, function (data) {
            if (data == null) return;
  
            let form = this.getFormView();
            if (form == null) return;
  
            let context = form.context;
            if (context == null) return;
  
            let item = GUID.isValid(data.id)
              ? context.eqTree.getItem(data.id)
              : context.paramsList.find(function (item) {
                  return item.n == data.id;
                }, true);
            if (item != null) {
              item = mxUtils.clone(item);
              form.blockEvent();
              this.config.setValue(item);
              form.unblockEvent();
            }
          });
          this.config.setValue = mxUtils.bind(this, function (item) {
            if (item == null) {
              this.value = null;
              this.setValue('');
              return;
            }
            // tag
            if (item.mid) {
              this.value = { id: item.n };
              this.setValue(item.n);
              return;
            }
            // eq
            if (item.$count == 0 || item.eq) {
              let context = this.getFormView().context;
              if (context != null) {
                this.value = { id: item.id };
                let parent = context.eqTree.findParentEquipment(item.id);
                if (parent != null) this.value.parent = parent.id;
  
                let path = context.eqTree.buildPath(item.id);
                this.setValue(path);
              }
              return;
            }
          });
          this.config.getValue = mxUtils.bind(this, function () {
            return this.value;
          });
          this.config.on = {
            onFocus: function (current, prev) {
              let dnd = webix.DragControl.getContext();
              if (dnd != null) return;
  
              var form = current.getFormView();
              if (form == null) return;
  
              var context = form.context;
              context.currentView = this;
  
              var value = current.config.getValue();
              if (value == null) return;
              context.showItem(value.id);
            },
            onSearchIconClick: function (e) {
              this.config.setValue(null);
            },
          };
        },
        $cssName: 'search',
        $renderIcon: function (config) {
          $(this.$view).attr('drop_target', true);
          return '<span style="height:26px;padding-top:6px;" class="webix_input_icon ' + config.icon + '" title="Очистить привязку"></span>';
        },
      },
      webix.ui.search
    );
    webix.protoUI(
      {
        name: 'param',
        $init: function (config) {
          this.config = config;
          this.config.icon = 'wxi-trash';
          this.config.readonly = false;
  
          this.config.bind = mxUtils.bind(this, function (data) {
            if (data == null) return;
  
            let form = this.getFormView();
            if (form == null) return;
  
            let context = form.context;
            if (context == null) return;
  
            let item = data;
            if (isDefined(data.id)) {
              item = GUID.isValid(data.id)
                ? context.eqTree.getItem(data.id)
                : context.paramsList.find(function (item) {
                    return item.n == data.id;
                  }, true);
            }
  
            if (item != null) {
              item = mxUtils.clone(item);
              this.config.setValue(item);
            }
          });
          this.config.setValue = mxUtils.bind(this, function (item) {
            try {
              this.changing = true;
              if (item == null) {
                this.value = null;
                // set display value
                this.setValue('');
                return;
              }
              // tag
              if (item.mid) {
                this.value = { id: item.n };
                // set display value
                this.setValue(item.n);
                return;
              }
              // eq
              if (item.$count == 0 || item.eq) {
                let context = this.getFormView().context;
                if (context != null) {
                  this.value = { id: item.id };
                  let parent = context.eqTree.findParentEquipment(item.id);
                  if (parent != null) this.value.parent = parent.id;
  
                  let path = context.eqTree.buildPath(item.id);
                  // set display value
                  this.setValue(path);
                }
                return;
              }
              // text
              if (isDefined(item.text)) {
                // set custom value
                this.value = item;
                // set display value
                this.setValue(item.text);
              }
            } finally {
              this.changing = false;
            }
          });
          this.config.getValue = mxUtils.bind(this, function () {
            return this.value;
          });
          this.config.on = $.extend(this.config.on || {}, {
            onFocus: function (current, prev) {
              let dnd = webix.DragControl.getContext();
              if (dnd != null) return;
  
              var form = current.getFormView();
              if (form == null) return;
  
              var context = form.context;
              context.currentView = this;
  
              var value = current.config.getValue();
              if (value == null) return;
              context.showItem(value.id);
            },
            onChange: function (newv, oldv) {
              if (!this.changing) this.config.setValue({ text: newv });
            },
            onSearchIconClick: function (e) {
              this.config.setValue(null);
            },
          });
        },
        $cssName: 'search',
        $renderIcon: function (config) {
          return '<span style="height:26px;padding-top:6px;" class="webix_input_icon ' + config.icon + '" title="Очистить"></span>';
        },
      },
      webix.ui.search
    );
    webix.protoUI(
      {
        name: 'path',
        $init: function (config) {
          this.config = config;
          this.config.icon = 'wxi-folder-open';
          this.config.readonly = false;
  
          this.config.bind = mxUtils.bind(this, function (data) {
            if (data == null) return;
  
            let form = this.getFormView();
            if (form == null) return;
  
            let context = form.context;
            if (context == null) return;
  
            let item = data;
            if (item != null) {
              item = mxUtils.clone(item);
              this.config.setValue(item);
            }
          });
          this.config.setValue = mxUtils.bind(this, function (item) {
            try {
              this.changing = true;
              if (item == null) {
                this.value = null;
                // set display value
                this.setValue('');
                return;
              }
              // text
              if (isDefined(item.text)) {
                // set custom value
                this.value = item;
                // set display value
                this.setValue(item.text);
              }
            } finally {
              this.changing = false;
            }
          });
          this.config.getValue = mxUtils.bind(this, function () {
            return this.value;
          });
          this.config.on = $.extend(this.config.on || {}, {
            onChange: function (newv, oldv) {
              if (!this.changing) this.config.setValue({ text: newv });
            },
            onSearchIconClick: function (e) {
              let context = this;
              let queryID = GUID.newID();
  
              // save current timeout
              let savedTimeout = AJAX.getTimeout();
              // temporary reset timeout
              AJAX.setTimeout(0);
              AJAX.post(
                '/linkmt/file/select/' + this.config.ext,
                null,
                queryID,
                function (xhr, resp) {
                  if (!isNullOrEmpty(resp)) context.config.setValue({ text: resp });
                },
                function (xhr, err) {
                  console.log('Ошибка выбора файла.')
                  // messageError('Ошибка выбора файла.');
                },
                function (xhr) {
                  // restore current timeout
                  AJAX.setTimeout(savedTimeout);
                }
              );
            },
          });
        },
        $cssName: 'search',
        $renderIcon: function (config) {
          return '<span style="height:26px;padding-top:6px;padding-right:3px;" class="webix_input_icon ' + config.icon + '" title="Выбрать"></span>';
        },
      },
      webix.ui.search
    );
    webix.protoUI(
      {
        name: 'editlist',
      },
      webix.EditAbility,
      webix.ui.list
    );
  
    this.ui = editorUi;
    this.editor = this.ui.editor;
    this.graph = this.editor.graph;
    (function () {
        function Bindings (window, container) {
        this.window = window;
        this.container = container;
        this.titleBase = mxResources.get('bindings');
  
        webix.require(
          ['/js/common/params_tree.js'],
          mxUtils.bind(this, function () {
            this.init();
          })
        );
      };
  
      Bindings.prototype.ui = editorUi;
      Bindings.prototype.editor = editorUi.editor;
      Bindings.prototype.graph = editorUi.editor.graph;
  
      Bindings.prototype.init = function () {
        //---fix---//
        // var paramsView = paramstree.buildList({
        //   css: 'params_tree_acc',
        //   callback: mxUtils.bind(this, function (items) {
        //     if (!items || items.length != 1) return;
  
        //     if (this.currentView != null) {
        //       let itemToSet = items[0];
        //       let setValueAction = this.currentView.config.setValue || this.currentView.setValue;
        //       if (setValueAction) setValueAction.call(this.currentView, itemToSet);
        //     }
        //   }),
        // });
    //---fix---//
        let properties = {
          view: 'form',
          id: 'properties',
          borderless: false,
          margin: 0,
          padding: 8,
          scroll: false,
          width: 400,
          drag: 'target',
          complexData: false, // !!!! REQUIRED !!!
          elements: [],
          elementsConfig: {
            checkValue: '1',
            uncheckValue: '0',
          },
          on: {
            onChange: function (val, prev) {
              var ui = this.context.ui;
              var graph = this.context.graph;
  
              if (graph && graph.isEnabled()) {
                if (!this.context.validate()) return;
  
                try {
                  graph.model.beginUpdate();
  
                  var bindings = [];
                  var getValue = function (el) {
                    if (el == null) return null;
                    let getValueAction = el.config.getValue || el.getValue;
                    if (getValueAction == null) return null;
                    return getValueAction.call(el);
                  };
  
                  this.getValues(function (el) {
                    var value = getValue(el);
  
                    // check linked value
                    if (!isNullOrEmpty(el.config.link)) {
                      let linkedElement = this.elements[el.config.link];
                      if (linkedElement == null) return;
                      let res = getValue(linkedElement);
                      if (isNullOrEmpty(res)) return;
                    }
  
                    // check defaults
                    if (value == el.config.default) return;
  
                    var item = { name: el.config.name, value: JSON.stringify(value) };
                    bindings.push(item);
                  });
  
                  // update cell bindings
                  graph.model.setBindings(this.targetCell, bindings);
  
                  // rebuild view
                  if (this.targetCell.onBindingsUpdated) this.targetCell.onBindingsUpdated();
                } catch (e) {
                  ui.handleError(e);
                } finally {
                  graph.model.endUpdate();
                }
              }
            },
          },
        };
        let resizer = {
          view: 'resizer',
          hidden: true,
        };
        let params = {
          id: 'params',
          gravity: 1,
          hidden: true,
          rows: [
            {
              view: 'tabbar',
              id: 'paramsTab',
              multiview: true,
              bottomOffset: 1,
              height: 30,
              options: [
                { id: 'eqTree', value: 'Оборудование' },
                { id: 'params_tree_list', value: 'Параметры' },
              ],
            },
            {
              cells: [
                {
                  view: 'tree',
                  id: 'eqTree',
                  select: true,
                  drag: 'source',
                  scroll: 'auto',
                  navigation: true,
                  template: function (obj, common) {
                    let tmpl = common.icon(obj, common) + common.folder(obj, common);
                    return tmpl + '<span>' + (obj.eq ? '<b>' + obj.desc + '</b>' : obj.desc) + '</span>';
                  },
                  type: {
                    folder: function (obj) {
                      if (obj.eq) return "<span class='webix_icon fas fa-cog'></span>";
                      if (obj.jrn) return "<span class='webix_icon fas fa-list'></span>";
                      if (obj.osc) return "<span class='webix_icon fas fa-image'></span>";
                      if (obj.states) return "<span class='webix_icon fas fa-eye'></span>";
                      if (obj.commands) return "<span class='webix_icon fas fa-bolt'></span>";
                      if (obj.pages) return "<span class='webix_icon fas fa-tags'></span>";
                      if (obj.page) return "<span class='webix_icon fas fa-columns'></span>";
                      if (obj.oper) return "<span class='webix_icon fas fa-dot-circle'></span>";
                      return "<span class='webix_icon wxi-angle-double-right'></span>";
                    },
                  },
                  scheme: {
                    $init: function (obj) {
                      if (isNullOrEmpty(obj.desc)) obj.desc = obj.name;
  
                      if (obj.type != null) {
                        obj.eq = true;
                        obj.desc = obj.name;
                      }
  
                      // pages
                      if (obj.pages && obj.pages.length > 0) {
                        if (!obj.data) obj.data = [];
                        var pagesRoot = { desc: 'Страницы параметров', pages: true, data: [] };
  
                        for (let i = 0; i < obj.pages.length; i++) {
                          var page = obj.pages[i];
                          if (page && page.params && page.params.length > 0) pagesRoot.data.push({ desc: page.hdr, path: true, page: true, data: page.params });
                        }
  
                        if (pagesRoot.data.length > 0) obj.data.unshift(pagesRoot);
                      }
                      // oper info
                      if (obj.oper && obj.oper.length > 0) {
                        if (!obj.data) obj.data = [];
                        obj.data.unshift({ desc: 'Оперативная информация', path: true, oper: true, data: obj.oper });
                      }
                      // commands
                      if (obj.commands && obj.commands.length > 0) {
                        if (!obj.data) obj.data = [];
  
                        for (let i = 0; i < obj.commands.length; i++) obj.commands[i].cmd = true;
  
                        obj.data.unshift({ desc: 'Команды', path: true, commands: true, data: obj.commands });
                      }
                      // states
                      if (obj.states && obj.states.length > 0) {
                        if (!obj.data) obj.data = [];
  
                        for (let i = 0; i < obj.states.length; i++) obj.states[i].state = true;
  
                        obj.data.unshift({ desc: 'Состояния', path: true, states: true, data: obj.states });
                      }
                      // maintenance
                      if (obj.maintenance?.parameters && obj.maintenance.parameters.length > 0) {
                        if (!obj.data) obj.data = [];
  
                        obj.maintenance.parameters.forEach((p) => (p.state = true));
  
                        obj.data.unshift({ desc: 'Признаки обслуживания', path: true, states: true, data: obj.maintenance.parameters });
                      }
                    },
                  },
                  data: [],
                },
                //---fix---//
                // paramsView,
                 //---fix---//
              ],
            },
          ],
        };
  
        let elements = [
          {
            view: 'scrollview',
            gravity: 1,
            scroll: 'y',
            body: properties,
          },
          // resizer, // resizer works bad
          params,
        ];
        // @if !LINKMT
        resizer.hidden = false;
        params.hidden = false;
        // @endif
        this.layout = webix.ui({
          type: 'form',
          container: this.container,
          cols: elements,
        });
  
        // @if LINKMT
        // strange bug with modality fix
        this.layout.getNode().style['z-index'] = 10000;
        // @endif
  
        this.adjust = mxUtils.bind(this, function () {
          this.layout.adjust();
        });
        this.update = mxUtils.bind(this, function (sender, evt) {
          this.refresh();
        });
  
        this.graph.getModel().addListener(mxEvent.CHANGE, this.update);
        this.graph.getSelectionModel().addListener(mxEvent.CHANGE, this.update);
  
        this.showItem = mxUtils.bind(this, function (id) {
          if (isNullOrEmpty(id)) return;
  
          var isGuid = GUID.isValid(id);
          if (isGuid) {
            this.paramsTab.setValue('eqTree');
            if (this.eqTree.exists(id)) {
              this.eqTree.select(id);
              let parent = this.eqTree.getParentId(id);
              if (parent != null) this.eqTree.open(parent, true);
              this.eqTree.showItem(id);
            } else this.eqTree.unselectAll();
          } else {
            this.paramsTab.setValue('params_tree_list');
            var targetItem = this.paramsList.find(function (item) {
              return item.n == id;
            }, true);
            if (targetItem != null) {
              this.paramsList.select(targetItem.id);
              this.paramsList.showItem(targetItem.id);
            } else this.paramsList.unselectAll();
          }
        });
  
        this.properties = $$('properties');
        if (this.properties) this.properties.context = this;
  
        this.paramsList = $$('params_tree_list');
        if (this.paramsList) this.paramsList.context = this;
  
        this.paramsTab = $$('paramsTab');
        if (this.paramsTab) this.paramsTab.context = this;
  
        this.eqTree = $$('eqTree');
        if (this.eqTree) {
          this.eqTree.context = this;
          this.eqTree.findParentEquipment = mxUtils.bind(this.eqTree, function (id) {
            let self = this.getItem(id);
            if (self == null) return null;
            if (self.eq) return self;
            let parentID = this.getParentId(id);
            if (!isDefined(parentID)) return null;
            let parent = this.getItem(parentID);
            if (!parent) return null;
            if (parent.eq) return parent;
            return this.findParentEquipment(parent.id);
          });
          this.eqTree.buildPath = mxUtils.bind(this.eqTree, function (id) {
            let item = this.getItem(id);
            if (item == null) return null;
  
            var path = [item.desc];
            let parent = this.getItem(this.getParentId(item.id));
            while (parent) {
              if (parent.eq || parent.path) path.push(parent.desc);
              parent = this.getItem(this.getParentId(parent.id));
            }
            return path.reverse().join('\\');
          });
        }
  
        AJAX.get(
          API.FUNC.schemeEquipments,
          null,
          mxUtils.bind(this, function (xhr, resp) {
            this.equipments = resp;
          }),
          function (xhr, err) {
            console.log('Ошибка загрузки списка оборудования')
           // messageError('Ошибка загрузки списка оборудования');
          },
          mxUtils.bind(this, function (xhr, status) {
            if (!this.eqTree || !this.paramsTab) return;
  
            if (this.equipments == null) this.paramsTab.hideOption('eqTree');
            else {
              this.eqTree.parse(this.equipments);
              if (this.eqTree.count() == 1) this.eqTree.open(this.eqTree.getFirstId());
            }
  
            if (this.paramsList) {
              this.paramsList.complete = this.update;
              this.paramsList.callEvent('onViewShow');
            }
          })
        );
  
        webix.attachEvent(
          'onFocusChange',
          mxUtils.bind(this, function (current, prev) {
            if (current && current.getFormView) {
              let element = current.$view;
              if (element && $(element).attr('drop_target')) this.currentView = current;
            }
          })
        );
  
        this.dropLogic = {
          $drop: mxUtils.bind(this, function (source, target, e) {
            if (source !== target) {
              var context = webix.DragControl.getContext();
              for (let i = 0; i < context.source.length; i++) {
                let item = context.from.getItem(context.source[i]);
                if (item) {
                  // only single tag or equipment item is accepted
                  if (item.$count === 0 || item.eq) {
                    let element = $(target); //$(e.target || e.srcElement);
                    if (element && element.attr('drop_target')) {
                      let focusedView = this.currentView; //webix.UIManager.getFocus();
                      if (focusedView) {
                        let setValueAction = focusedView.config.setValue || focusedView.setValue;
                        if (setValueAction) setValueAction.call(focusedView, item);
                      }
                    }
                  }
                }
              }
            }
          }),
          $dragIn: mxUtils.bind(this, function (source, target, e) {
            if (source != target) {
              let element = $(target);
              if (element && element.attr('drop_target')) {
                if (element.select) element.select();
                if (element.focus) element.focus();
                // find webix UI element
                let viewID = $(element).attr('view_id');
                if (!isNullOrEmpty(viewID)) {
                  let view = $$(viewID);
                  if (view && this.currentView != view) {
                    if (view.focus) view.focus();
                    webix.UIManager.setFocus(view);
                    this.currentView = view;
                  }
                }
              }
              return source;
            }
          }),
        };
      };
      Bindings.prototype.validate = function () {
        return this.properties != null ? this.properties.validate() : false;
      };
      Bindings.prototype.refresh = function () {
        if (!this.window.isVisible() || this.properties == null) return;
  
        var cells = this.graph.getSelectionCells();
        if (cells.length != 1) {
          // reset title & properties
          this.properties.define('elements', []);
          this.properties.reconstruct();
          this.window.setTitle(this.titleBase);
          this.properties.targetCell = null;
          //webix.DragControl.unlink(this.properties);
          return;
        }
  
        var selectedCell = cells[0];
        if (this.properties.targetCell != selectedCell) {
          //webix.DragControl.unlink(this.properties);
  
          // reset title & properties
          this.properties.define('elements', []);
          this.properties.reconstruct();
          this.window.setTitle(this.titleBase);
  
          // update title
          var name = this.graph.getAttributeForCell(selectedCell, 'name', null);
          if (name != null) {
            // @if LINKMT
            let cellValue = selectedCell.getValue();
            if (cellValue != null && mxUtils.isNode(cellValue) && cellValue.nodeName.toLowerCase() == 'bmrz') name = 'IED';
            // @endif
            this.window.setTitle(this.titleBase + ' - ' + name);
          }
  
          if (this.container.clientHeight > 0) {
            var bindings = this.getForCell(selectedCell);
            if (bindings != null) {
              this.properties.targetCell = selectedCell;
  
              this.properties.define('elements', bindings);
              this.properties.reconstruct();
  
              for (let id in this.properties.elements) {
                let el = this.properties.elements[id];
                el.context = this;
                webix.DragControl.addDrop(el.$view, this.dropLogic);
              }
  
              this.properties.blockEvent();
  
              // read & apply element config
              if (selectedCell.bindings != null) {
                for (var i = 0; i < selectedCell.bindings.length; i++) {
                  var item = selectedCell.bindings[i];
                  if (item) {
                    // read & apply all attributes
                    let attrName = item.name;
                    if (!isNullOrEmpty(attrName)) {
                      let attrValue = item.value;
                      if (!isNullOrEmpty(attrValue)) {
                        var prop = this.properties.elements[attrName];
                        if (prop) {
                          let applyAction = prop.config.bind || prop.config.setValue || prop.setValue;
                          if (applyAction != null) {
                            // block events
                            if (prop.blockEvent) prop.blockEvent();
                            // apply value
                            applyAction.call(prop, JSON.parse(attrValue));
                            // restore events
                            if (prop.unblockEvent) prop.unblockEvent();
                          }
                        }
                      }
                    }
                  }
                }
              }
  
              // custom ready event
              for (let id in this.properties.elements) {
                let el = this.properties.elements[id];
                if (el != null && el.callEvent) el.callEvent('onReady', []);
              }
  
              this.properties.unblockEvent();
            }
          }
        }
      };
      Bindings.prototype.getForCell = function (cell) {
        var bindings = [];
  
        var style = this.graph.getCellStyle(cell);
        if (style == null || style.shape == null) return bindings;
  
        var cellValue = cell.getValue();
        if (cellValue == null || !mxUtils.isNode(cellValue)) return bindings;
  
        //let cellType = style.shape.toLowerCase();
        let cellType = cellValue.nodeName.toLowerCase();
        let cellGeom = this.graph.getCellGeometry(cell);
  
        var context = this;
        var onHandler = {
          onFocus: function (current_view, prev_view) {
            if (context.currentView != current_view) {
              context.currentView = current_view;
              if (context.currentView.focus) context.currentView.focus();
              webix.UIManager.setFocus(context.currentView);
            }
          },
        };
        var onColorPickerHandler = {
          onFocus: function (current_view, prev_view) {
            if (context.currentView != current_view) {
              context.currentView = current_view;
              if (context.currentView.focus) context.currentView.focus();
              webix.UIManager.setFocus(context.currentView);
            }
          },
          onChange: function (val, prev) {},
        };
  
        var state = {
          cols: [
            { view: 'label', label: 'Состояние:', width: 110 },
            { view: 'link', name: 'state' },
          ],
        };
        var vclass = {
          cols: [
            { view: 'label', label: 'Класс напр-я:', width: 110 },
            {
              view: 'richselect',
              name: 'vclass',
              default: 'V0',
              value: 'V0',
              on: onHandler,
              options: {
                data: VCLASS.getOptions(),
                body: {
                  template: function (obj, common) {
                    let result = '<span>' + obj.value + '</span>';
                    if (obj.id != 'V0') {
                      let color = VCLASS.getColor(obj.id);
                      result += '<span style="float:right;width:100px;text-align:center;color:#ffffff;background:' + color + '">' + color + '<span/>';
                    }
                    return result;
                  },
                },
              },
            },
          ],
        };
        var script = {
          cols: [
            { view: 'label', label: 'Скрипт:', width: 110 },
            { view: 'richselect', /*name: "script", */ options: [cellType], value: cellType, on: onHandler, disabled: true },
          ],
        };
  
        var colors = {
          view: 'accordion',
          multi: true,
          type: 'clean',
          margin: 2,
          rows: [],
        };
        var fillColor = {
          view: 'accordionitem',
          header: 'Цвет заливки:',
          headerHeight: 22,
          headerAltHeight: 22,
          collapsed: true,
          body: {
            rows: [
              {
                cols: [
                  { view: 'colorpicker', name: 'color.fill.$1.val', link: 'color.fill.$1', width: 100, editable: true, value: '#FF0000', on: onColorPickerHandler },
                  { view: 'link', name: 'color.fill.$1' },
                ],
              },
              {
                cols: [
                  { view: 'colorpicker', name: 'color.fill.$2.val', link: 'color.fill.$2', width: 100, editable: true, value: '#FFFF00', on: onColorPickerHandler },
                  { view: 'link', name: 'color.fill.$2' },
                ],
              },
              {
                cols: [
                  { view: 'colorpicker', name: 'color.fill.$3.val', link: 'color.fill.$3', width: 100, editable: true, value: '#00FF00', on: onColorPickerHandler },
                  { view: 'link', name: 'color.fill.$3' },
                ],
              },
              {
                cols: [
                  { view: 'colorpicker', name: 'color.fill.$4.val', link: 'color.fill.$4', width: 100, editable: true, value: '#CCCCCC', on: onColorPickerHandler },
                  { view: 'link', name: 'color.fill.$4' },
                ],
              },
              {
                cols: [
                  { view: 'colorpicker', name: 'color.fill.$5.val', link: 'color.fill.$5', width: 100, editable: true, value: '#0000FF', on: onColorPickerHandler },
                  { view: 'link', name: 'color.fill.$5' },
                ],
              },
            ],
          },
        };
        var borderColor = {
          view: 'accordionitem',
          header: 'Цвет контура:',
          headerHeight: 22,
          headerAltHeight: 22,
          collapsed: true,
          body: {
            rows: [
              {
                cols: [
                  { view: 'colorpicker', name: 'color.brd.$1.val', link: 'color.brd.$1', width: 100, editable: true, value: '#FF0000', on: onColorPickerHandler },
                  { view: 'link', name: 'color.brd.$1' },
                ],
              },
              {
                cols: [
                  { view: 'colorpicker', name: 'color.brd.$2.val', link: 'color.brd.$2', width: 100, editable: true, value: '#FFFF00', on: onColorPickerHandler },
                  { view: 'link', name: 'color.brd.$2' },
                ],
              },
              {
                cols: [
                  { view: 'colorpicker', name: 'color.brd.$3.val', link: 'color.brd.$3', width: 100, editable: true, value: '#00FF00', on: onColorPickerHandler },
                  { view: 'link', name: 'color.brd.$3' },
                ],
              },
              {
                cols: [
                  { view: 'colorpicker', name: 'color.brd.$4.val', link: 'color.brd.$4', width: 100, editable: true, value: '#CCCCCC', on: onColorPickerHandler },
                  { view: 'link', name: 'color.brd.$4' },
                ],
              },
              {
                cols: [
                  { view: 'colorpicker', name: 'color.brd.$5.val', link: 'color.brd.$5', width: 100, editable: true, value: '#0000FF', on: onColorPickerHandler },
                  { view: 'link', name: 'color.brd.$5' },
                ],
              },
            ],
          },
        };
        var fontColor = {
          view: 'accordionitem',
          header: 'Цвет шрифта:',
          headerHeight: 22,
          headerAltHeight: 22,
          collapsed: true,
          body: {
            rows: [
              {
                cols: [
                  { view: 'colorpicker', name: 'color.font.$1.val', link: 'color.font.$1', width: 100, editable: true, value: '#FF0000', on: onColorPickerHandler },
                  { view: 'link', name: 'color.font.$1' },
                ],
              },
              {
                cols: [
                  { view: 'colorpicker', name: 'color.font.$2.val', link: 'color.font.$2', width: 100, editable: true, value: '#FFFF00', on: onColorPickerHandler },
                  { view: 'link', name: 'color.font.$2' },
                ],
              },
              {
                cols: [
                  { view: 'colorpicker', name: 'color.font.$3.val', link: 'color.font.$3', width: 100, editable: true, value: '#00FF00', on: onColorPickerHandler },
                  { view: 'link', name: 'color.font.$3' },
                ],
              },
              {
                cols: [
                  { view: 'colorpicker', name: 'color.font.$4.val', link: 'color.font.$4', width: 100, editable: true, value: '#CCCCCC', on: onColorPickerHandler },
                  { view: 'link', name: 'color.font.$4' },
                ],
              },
              {
                cols: [
                  { view: 'colorpicker', name: 'color.font.$5.val', link: 'color.font.$5', width: 100, editable: true, value: '#0000FF', on: onColorPickerHandler },
                  { view: 'link', name: 'color.font.$5' },
                ],
              },
            ],
          },
        };
  
        var visibility = {
          cols: [
            { view: 'label', label: 'Видимость:', width: 110 },
            { view: 'link', name: 'visibility' },
          ],
        };
        var label = {
          cols: [
            { view: 'label', label: 'Надпись:', width: 110 },
            { view: 'link', name: 'label' },
          ],
        };
        var header = {
          cols: [
            { view: 'label', label: 'Заголовок:', width: 110 },
            { view: 'param', name: 'header' },
          ],
        };
        var blinking = {
          rows: [
            {
              cols: [
                { view: 'label', label: 'Мигание:', width: 110 },
                { view: 'link', name: 'blink' },
              ],
            },
            {
              cols: [{}, { view: 'label', label: 'мс:', align: 'right' }, { view: 'text', name: 'blink.speed', link: 'blink', value: 500, width: 80, type: 'number' }],
            },
          ],
        };
        var rotation = {
          rows: [
            {
              cols: [
                { view: 'label', label: 'Вращение:', width: 110 },
                { view: 'link', name: 'rotation' },
              ],
            },
            {
              cols: [{}, { view: 'label', label: 'мс:', align: 'right' }, { view: 'text', name: 'rotation.speed', link: 'rotation', value: 100, width: 80, type: 'number' }],
            },
          ],
        };
        var turning = {
          rows: [
            {
              cols: [
                { view: 'label', label: 'Поворот:', width: 110 },
                { view: 'link', name: 'turn' },
              ],
            },
            {
              cols: [{}, { view: 'label', label: 'град (0-360):', align: 'right' }, { view: 'text', name: 'turn.angle', link: 'turn', value: 90, width: 80, type: 'number' }],
            },
          ],
        };
        var shifting = {
          rows: [
            {
              cols: [
                { view: 'label', label: 'Сдвиг:', width: 110 },
                { view: 'link', name: 'shift' },
              ],
            },
            {
              cols: [{}, { view: 'label', label: '∆x:', align: 'right', width: 25 }, { view: 'text', name: 'shift.dx', link: 'shift', value: 0, width: 80, type: 'number' }, { view: 'label', label: '∆y:', align: 'right', width: 25 }, { view: 'text', name: 'shift.dy', link: 'shift', value: 0, width: 80, type: 'number' }],
            },
          ],
        };
        var moving = {
          rows: [
            {
              cols: [
                { view: 'label', label: 'Перемещение:', width: 110 },
                { view: 'link', name: 'move' },
              ],
            },
            {
              cols: [{}, { view: 'label', label: 'x:', align: 'right', width: 25 }, { view: 'text', name: 'move.x', link: 'move', value: cellGeom.x, width: 80, type: 'number' }, { view: 'label', label: 'y:', align: 'right', width: 25 }, { view: 'text', name: 'move.y', link: 'move', value: cellGeom.y, width: 80, type: 'number' }],
            },
          ],
        };
        var sound = {
          cols: [
            { view: 'label', label: 'Источник:', width: 110 },
            {
              cols: [
                {
                  view: 'label',
                  id: 'play.name',
                  name: 'play.name',
                },
                {
                  view: 'text',
                  id: 'play.data',
                  name: 'play.data',
                  hidden: true,
                },
                {
                  view: 'uploader',
                  value: 'Выбрать',
                  apiOnly: true,
                  width: 100,
                  multiple: false,
                  autosend: false, //!important
                  accept: '.mp3,.ogg,.wav',
                  on: {
                    onBeforeFileAdd: function (item) {
                      if (this.config.accept && this.config.accept !== '*') {
                        let acceptedTypes = this.config.accept.split(',').map(function (x) {
                          return x.trimFromStart('.');
                        });
                        if (acceptedTypes.indexOf(item.type.toLowerCase()) < 0) {
                          console.log('common.errors.support_only_files' + ': ' + acceptedTypes.join(','))
                         // messageError(translate('common.errors.support_only_files') + ': ' + acceptedTypes.join(','));
                          this.files.clearAll();
                          return false;
                        }
                      }
                    },
                    onAfterFileAdd: function (item) {
                      var inputs = this.$view.getElementsByTagName('INPUT');
                      var fileList = inputs[inputs.length - 1].files;
                      if (fileList && fileList.length > 0) {
                        // last file is loaded by client
                        if (this.files.count() === fileList.length) {
                          var self = this;
                          HELP.readBinaryFile(item.file, function (data) {
                            let srcData = window.btoa ? window.btoa(data) : Base64.encode(data, true);
                            $$('play.name').setValue(item.name);
                            $$('play.data').setValue('data:' + item.file.type + ';base64,' + srcData);
                            self.files.clearAll();
                          });
                        }
                      }
                    },
                  },
                },
              ],
            },
          ],
        };
        var commands = {
          view: 'accordion',
          multi: true,
          type: 'clean',
          margin: 2,
          rows: [
            {
              view: 'accordionitem',
              header: 'Команды:',
              headerHeight: 22,
              headerAltHeight: 22,
              collapsed: true,
              body: {
                view: 'forminput',
                name: 'commands',
                bind: function (data) {
                  if (data == null || data.length == 0) return;
  
                  let list = this.queryView('editlist');
                  list.blockEvent();
  
                  data.forEach(function (x) {
                    let item = GUID.isValid(x.id)
                      ? context.eqTree.getItem(x.id)
                      : context.paramsList.find(function (item) {
                          return item.n == x.id;
                        }, true);
                    if (item != null) {
                      item = mxUtils.clone(item);
                      // restore user description
                      item.d = x.d;
                      list.config.bind.call(list, item);
                    }
                  });
  
                  list.refresh();
                  list.unblockEvent();
                },
                getValue: function () {
                  let list = this.queryView('editlist');
                  return list.config.getValue.call(list);
                },
                body: {
                  view: 'editlist',
                  select: true,
                  navigation: true,
                  drag: 'order',
                  dragScroll: true,
                  editable: true,
                  editor: 'text',
                  editValue: 'd',
                  minHeight: 150,
                  data: [],
                  ready: function () {
                    $(this.$view).attr('drop_target', true);
                    webix.DragControl.addDrop(this.$view, context.dropLogic);
  
                    this.data.attachEvent(
                      'onStoreUpdated',
                      mxUtils.bind(this, function (id, obj, mode) {
                        context.properties.callEvent('onChange');
                      })
                    );
                  },
                  bind: function (item) {
                    this.data.blockEvent();
                    this.config.setValue.call(this, item);
                    this.data.unblockEvent();
                  },
                  setValue: function (item) {
                    if (item == null) return;
  
                    let index = this.getIndexById(this.getSelectedId());
  
                    // tag
                    if (item.mid) {
                      if (item.vtype == API.ENUMS.TagValueType.Boolean) this.add({ id: item.n, val: item.n, d: item.d || item.n, confirm: true }, index);
                      return;
                    }
                    // eq
                    if (item.$count == 0 && item.cmd) {
                      let path = context.eqTree.buildPath(item.id);
                      let value = { id: item.id, val: path, d: item.d || item.desc, confirm: item.cnf };
                      if (!item.eq) {
                        let parent = context.eqTree.findParentEquipment(item.id);
                        if (parent) value.parent = parent.id;
                      }
                      this.add(value, index);
                      return;
                    }
                  },
                  getValue: function () {
                    return this.data.serialize(true);
                  },
                  on: {
                    onFocus: onHandler.onFocus,
                    onBeforeAdd: function (id, obj, index) {
                      return !this.exists(id);
                    },
                    onSelectChange: function (ids) {
                      if (ids == null || ids.length != 1) return;
                      let item = this.getSelectedItem();
                      if (item == null) return;
                      context.showItem(item.id);
                    },
                  },
                  onClick: {
                    'wxi-close': function (evt, id) {
                      this.remove(id);
                    },
                  },
                  template: function (obj, common) {
                    return obj.d + "<span class='webix_icon wxi-close' style='float:right;margin-top:5px' title='Удалить'></span>";
                  },
                },
              },
            },
          ],
        };
        var action = {
          rows: [
            {
              cols: [
                { view: 'label', label: 'Действие:', width: 110 },
                {
                  view: 'richselect',
                  id: 'action',
                  name: 'action',
                  value: 'none',
                  default: 'none',
                  options: [
                    { id: 'none', value: 'Нет' },
                    { id: 'exec', value: 'Выполнить' },
                    { id: 'open', value: 'Открыть' },
                    { id: 'goto', value: 'Переход' },
                    { id: 'camera', value: 'IP-камера' },
                    { id: 'eq', value: 'Оборудование' },
                  ],
                  on: {
                    onReady: function () {
                      let args = $$('action.args');
                      let trigger = $$('action.trigger');
                      if (args != null && trigger != null) {
                        // reset
                        args.enable();
                        trigger.disable();
                        args.define('readonly', false);
                        $(args.$view).attr('drop_target', null);
                        // apply
                        switch (this.getValue()) {
                          case 'none':
                            args.disable();
                            break;
                          case 'eq':
                            {
                              args.define('readonly', true);
                              $(args.$view).attr('drop_target', true);
                              trigger.enable();
                            }
                            break;
                          case 'exec':
                            {
                              args.define('readonly', true);
                              $(args.$view).attr('drop_target', true);
                            }
                            break;
                          case 'camera':
                            {
                              trigger.enable();
                            }
                            break;
                          default:
                            break;
                        }
                        args.refresh();
                      }
                    },
                    onChange: function (newv, oldv) {
                      this.callEvent('onReady', []);
                      let args = $$('action.args');
                      let trigger = $$('action.trigger');
                      if (args != null && trigger != null) {
                        args.config.setValue(null);
                        trigger.config.setValue(null);
                      }
                    },
                  },
                },
              ],
            },
            {
              cols: [
                { view: 'label', label: 'Аргумент:', width: 110 },
                { view: 'param', id: 'action.args', name: 'action.args', on: onHandler },
              ],
            },
            {
              cols: [
                { view: 'label', label: 'Триггер:', width: 110 },
                { view: 'link', id: 'action.trigger', name: 'action.trigger', on: onHandler },
              ],
            },
          ],
        };
  
        switch (cellType) {
          case 'switch':
          case 'rollswitch':
            {
              bindings.push(script);
              bindings.push(visibility);
              bindings.push(label);
              bindings.push(state);
              bindings.push(vclass);
              bindings.push({
                cols: [
                  { view: 'label', label: 'Положение:', width: 110 },
                  { view: 'checkbox', name: 'position', value: 1, default: 1, on: onHandler, tooltip: 'Отображать положение выключателя' },
                ],
              });
              bindings.push(blinking);
              bindings.push(rotation);
              bindings.push(turning);
              bindings.push(shifting);
              bindings.push(moving);
              bindings.push(action);
              bindings.push(commands);
  
              colors.rows.push(fillColor);
              colors.rows.push(borderColor);
              colors.rows.push(fontColor);
            }
            break;
          case 'separator':
          case 'disconnector':
          case 'rolldisconnector':
          case 'ground':
          case 'contactor':
          case 'rollelement':
          case 'actuator':
          case 'simpleswitch':
            {
              bindings.push(script);
              bindings.push(visibility);
              bindings.push(label);
              bindings.push(state);
              bindings.push(vclass);
              bindings.push(blinking);
              bindings.push(rotation);
              bindings.push(turning);
              bindings.push(shifting);
              bindings.push(moving);
              bindings.push(action);
              bindings.push(commands);
  
              colors.rows.push(borderColor);
              colors.rows.push(fontColor);
            }
            break;
          case 'wstar':
          case 'wtriangle':
          case 'wtorn':
          case 'fuse':
          case 'current_transformer':
          case 'current_transformer_ru':
          case 'current_transformer_fsk':
          case 'reactor':
          case 'opn':
          case 'opn_nl':
          case 'rezistor':
          case 'condensator':
          case 'inductance':
          case 'ground1':
          case 'cable_cone':
          case 'ac':
          case 'load':
          case 'compensator':
            {
              bindings.push(visibility);
              bindings.push(label);
              bindings.push(vclass);
              bindings.push(blinking);
              bindings.push(rotation);
              bindings.push(turning);
              bindings.push(shifting);
              bindings.push(moving);
              bindings.push(action);
              bindings.push(commands);
  
              colors.rows.push(borderColor);
              colors.rows.push(fontColor);
            }
            break;
          case 'bus':
            {
              bindings.push(script);
              bindings.push(visibility);
              bindings.push(label);
              bindings.push(state);
              bindings.push(vclass);
              bindings.push(action);
  
              colors.rows.push(fillColor);
              colors.rows.push(borderColor);
              colors.rows.push(fontColor);
            }
            break;
          case 'link':
            {
              bindings.push(script);
              bindings.push(visibility);
              bindings.push(label);
              bindings.push(state);
              bindings.push(vclass);
  
              colors.rows.push(borderColor);
              colors.rows.push(fontColor);
            }
            break;
          case 'sound':
            {
              bindings.push(script);
              bindings.push(sound);
              bindings.push({
                cols: [
                  { view: 'label', label: 'Воспроизведение:', width: 145 },
                  { view: 'link', name: 'play', on: onHandler },
                ],
              });
              bindings.push({
                cols: [
                  { view: 'label', label: 'Циклически:', width: 145 },
                  { view: 'checkbox', name: 'play.cycle', link: 'play', value: 0, default: 0, on: onHandler, tooltip: 'Циклическое воспроизведение' },
                ],
              });
            }
            break;
          case 'table':
            {
              let table_items = {
                view: 'accordion',
                multi: true,
                type: 'clean',
                margin: 2,
                rows: [
                  {
                    view: 'accordionitem',
                    header: 'Список параметров:',
                    headerHeight: 22,
                    headerAltHeight: 22,
                    collapsed: false,
                    body: {
                      view: 'forminput',
                      name: 'items',
                      bind: function (data) {
                        if (data == null || data.length == 0) return;
  
                        let list = this.queryView('editlist');
                        list.blockEvent();
  
                        data.forEach(function (x) {
                          let item = GUID.isValid(x.id)
                            ? context.eqTree.getItem(x.id)
                            : context.paramsList.find(function (item) {
                                return item.n == x.id;
                              }, true);
                          if (item != null) {
                            item = mxUtils.clone(item);
                            // restore user description
                            item.d = x.d;
                            list.config.bind.call(list, item);
                          }
                        });
  
                        list.refresh();
                        list.unblockEvent();
                      },
                      getValue: function () {
                        let list = this.queryView('editlist');
                        return list.config.getValue.call(list);
                      },
                      body: {
                        view: 'editlist',
                        select: true,
                        navigation: true,
                        drag: 'order',
                        dragScroll: true,
                        editable: true,
                        editor: 'text',
                        editValue: 'd',
                        data: [],
                        ready: function () {
                          $(this.$view).attr('drop_target', true);
                          webix.DragControl.addDrop(this.$view, context.dropLogic);
  
                          this.data.attachEvent(
                            'onStoreUpdated',
                            mxUtils.bind(this, function (id, obj, mode) {
                              context.properties.callEvent('onChange');
                            })
                          );
                        },
                        bind: function (item) {
                          this.data.blockEvent();
                          this.config.setValue.call(this, item);
                          this.data.unblockEvent();
                        },
                        setValue: function (item) {
                          if (item == null) return;
  
                          let index = this.getIndexById(this.getSelectedId());
  
                          // tag
                          if (item.mid) {
                            this.add({ id: item.n, val: item.n, d: item.d || item.n }, index);
                            return;
                          }
                          // eq
                          if (item.$count == 0 || item.eq) {
                            let path = context.eqTree.buildPath(item.id);
                            let value = { id: item.id, val: path, d: item.d || item.desc };
                            if (!item.eq) {
                              let parent = context.eqTree.findParentEquipment(item.id);
                              if (parent) value.parent = parent.id;
                            }
                            this.add(value, index);
                            return;
                          }
                        },
                        getValue: function () {
                          return this.data.serialize(true);
                        },
                        on: {
                          onFocus: onHandler.onFocus,
                          onBeforeAdd: function (id, obj, index) {
                            return !this.exists(id);
                          },
                          onSelectChange: function (ids) {
                            if (ids == null || ids.length != 1) return;
                            let item = this.getSelectedItem();
                            if (item == null) return;
                            context.showItem(item.id);
                          },
                        },
                        onClick: {
                          'wxi-close': function (evt, id) {
                            this.remove(id);
                          },
                        },
                        template: function (obj, common) {
                          return obj.d + "<span class='webix_icon wxi-close' style='float:right;margin-top:5px;margin-right:-10px' title='Удалить'></span>";
                        },
                      },
                    },
                  },
                ],
              };
              bindings.push(script);
              bindings.push(visibility);
              bindings.push({
                cols: [
                  { view: 'label', label: 'Стиль:', width: 110 },
                  {
                    view: 'richselect',
                    name: 'style',
                    value: 'ptbl-default',
                    default: 'ptbl-default',
                    on: onHandler,
                    tooltip: 'Стиль оформления таблицы',
                    options: [
                      { id: 'ptbl-default', value: 'Обычный' },
                      { id: 'ptbl-borderless', value: 'Без сетки' },
                    ],
                  },
                ],
              });
              bindings.push({
                cols: [
                  { view: 'label', label: 'Ед. измерения:', width: 180 },
                  { view: 'checkbox', name: 'measure', value: 0, default: 0, on: onHandler, tooltip: 'Отображать единицы измерения' },
                ],
              });
              bindings.push({
                cols: [
                  { view: 'label', label: 'Ширина столбцов:', width: 180 },
                  {
                    view: 'text',
                    name: 'w1',
                    value: 0,
                    default: 0,
                    width: 80,
                    type: 'number',
                    attributes: { step: 5, min: 0 },
                    validate: function (obj) {
                      return webix.rules.isNumber(obj) && obj >= 0;
                    },
                  },
                  {
                    view: 'text',
                    name: 'w2',
                    value: 0,
                    default: 0,
                    width: 80,
                    type: 'number',
                    attributes: { step: 5, min: 0 },
                    validate: function (obj) {
                      return webix.rules.isNumber(obj) && obj >= 0;
                    },
                  },
                  {},
                ],
              });
              bindings.push({
                cols: [
                  { view: 'label', label: 'Размер шрифта ячеек:', width: 180 },
                  {
                    view: 'text',
                    name: 'fontSize',
                    value: 10,
                    default: 10,
                    width: 80,
                    type: 'number',
                    attributes: { step: 1, min: 1 },
                    validate: function (obj) {
                      return webix.rules.isNumber(obj) && obj > 0;
                    },
                  },
                ],
              });
              bindings.push({
                cols: [
                  { view: 'label', label: 'Длина дробной части:', width: 180 },
                  {
                    view: 'text',
                    name: 'fractionLength',
                    value: 6,
                    default: 6,
                    width: 80,
                    type: 'number',
                    attributes: { step: 1, min: 0, max: 99 },
                    validate: function (obj) {
                      return webix.rules.isNumber(obj) && obj >= 0 && obj < 100;
                    },
                  },
                ],
              });
              bindings.push(table_items);
  
              var names_font_colors = {
                view: 'accordion',
                multi: true,
                type: 'clean',
                margin: 2,
                rows: [
                  {
                    view: 'accordionitem',
                    header: 'Наименования:',
                    headerHeight: 22,
                    headerAltHeight: 22,
                    collapsed: true,
                    body: {
                      view: 'forminput',
                      body: {
                        rows: [
                          // font
                          {
                            cols: [
                              { view: 'label', label: 'Цвет шрифта (по умолчанию):', width: 220 },
                              { view: 'colorpicker', name: 'color.font.name', editable: true, value: '#000000', default: '#000000', on: onHandler },
                            ],
                          },
                          {
                            cols: [
                              { view: 'label', label: 'Плохое качество параметра:', width: 220 },
                              { view: 'colorpicker', name: 'color.font.name.bad', editable: true, value: '#000000', default: '#000000', on: onHandler },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.font.name.$1.val', link: 'color.font.name.$1', width: 100, editable: true, value: '#FF0000', on: onHandler },
                              { view: 'link', name: 'color.font.name.$1' },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.font.name.$2.val', link: 'color.font.name.$2', width: 100, editable: true, value: '#00FF00', on: onHandler },
                              { view: 'link', name: 'color.font.name.$2' },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.font.name.$3.val', link: 'color.font.name.$3', width: 100, editable: true, value: '#0000FF', on: onHandler },
                              { view: 'link', name: 'color.font.name.$3' },
                            ],
                          },
                          // fill
                          {
                            cols: [
                              { view: 'label', label: 'Цвет заливки (по умолчанию):', width: 220 },
                              { view: 'colorpicker', name: 'color.fill.name', editable: true, value: '', default: '', on: onHandler, point: true },
                            ],
                          },
                          {
                            cols: [
                              { view: 'label', label: 'Плохое качество параметра:', width: 220 },
                              { view: 'colorpicker', name: 'color.fill.name.bad', editable: true, value: '', default: '', on: onHandler },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.fill.name.$1.val', link: 'color.fill.name.$1', width: 100, editable: true, value: '#FF0000', on: onHandler },
                              { view: 'link', name: 'color.fill.name.$1' },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.fill.name.$2.val', link: 'color.fill.name.$2', width: 100, editable: true, value: '#00FF00', on: onHandler },
                              { view: 'link', name: 'color.fill.name.$2' },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.fill.name.$3.val', link: 'color.fill.name.$3', width: 100, editable: true, value: '#0000FF', on: onHandler },
                              { view: 'link', name: 'color.fill.name.$3' },
                            ],
                          },
                        ],
                      },
                    },
                  },
                ],
              };
              bindings.push(names_font_colors);
  
              var values_font_colors = {
                view: 'accordion',
                multi: true,
                type: 'clean',
                margin: 2,
                rows: [
                  {
                    view: 'accordionitem',
                    header: 'Значения:',
                    headerHeight: 22,
                    headerAltHeight: 22,
                    collapsed: true,
                    body: {
                      view: 'forminput',
                      body: {
                        rows: [
                          // font
                          {
                            cols: [
                              { view: 'label', label: 'Цвет шрифта (по умолчанию):', width: 220 },
                              { view: 'colorpicker', name: 'color.font.value', editable: true, value: '#90EE90', default: '#90EE90', on: onHandler },
                            ],
                          },
                          {
                            cols: [
                              { view: 'label', label: 'Плохое качество параметра:', width: 220 },
                              { view: 'colorpicker', name: 'color.font.value.bad', editable: true, value: VCLASS.UNRELIABLE_INFO, default: VCLASS.UNRELIABLE_INFO, on: onHandler },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.font.value.$1.val', link: 'color.font.value.$1', width: 100, editable: true, value: '#FF0000', on: onHandler },
                              { view: 'link', name: 'color.font.value.$1' },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.font.value.$2.val', link: 'color.font.value.$2', width: 100, editable: true, value: '#00FF00', on: onHandler },
                              { view: 'link', name: 'color.font.value.$2' },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.font.value.$3.val', link: 'color.font.value.$3', width: 100, editable: true, value: '#0000FF', on: onHandler },
                              { view: 'link', name: 'color.font.value.$3' },
                            ],
                          },
                          // fill
                          {
                            cols: [
                              { view: 'label', label: 'Цвет заливки (по умолчанию):', width: 220 },
                              { view: 'colorpicker', name: 'color.fill.value', editable: true, value: '#000000', default: '#000000', on: onHandler, point: true },
                            ],
                          },
                          {
                            cols: [
                              { view: 'label', label: 'Плохое качество параметра:', width: 220 },
                              { view: 'colorpicker', name: 'color.fill.value.bad', editable: true, value: '#808080', default: '#808080', on: onHandler },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.fill.value.$1.val', link: 'color.fill.value.$1', width: 100, editable: true, value: '#FF0000', on: onHandler },
                              { view: 'link', name: 'color.fill.value.$1' },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.fill.value.$2.val', link: 'color.fill.value.$2', width: 100, editable: true, value: '#00FF00', on: onHandler },
                              { view: 'link', name: 'color.fill.value.$2' },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.fill.value.$3.val', link: 'color.fill.value.$3', width: 100, editable: true, value: '#0000FF', on: onHandler },
                              { view: 'link', name: 'color.fill.value.$3' },
                            ],
                          },
                        ],
                      },
                    },
                  },
                ],
              };
              bindings.push(values_font_colors);
  
              var measures_font_colors = {
                view: 'accordion',
                multi: true,
                type: 'clean',
                margin: 2,
                rows: [
                  {
                    view: 'accordionitem',
                    header: 'Ед. измерения:',
                    headerHeight: 22,
                    headerAltHeight: 22,
                    collapsed: true,
                    body: {
                      view: 'forminput',
                      body: {
                        rows: [
                          // font
                          {
                            cols: [
                              { view: 'label', label: 'Цвет шрифта (по умолчанию):', width: 220 },
                              { view: 'colorpicker', name: 'color.font.measure', editable: true, value: '#000000', default: '#000000', on: onHandler },
                            ],
                          },
                          {
                            cols: [
                              { view: 'label', label: 'Плохое качество параметра:', width: 220 },
                              { view: 'colorpicker', name: 'color.font.measure.bad', editable: true, value: '#000000', default: '#000000', on: onHandler },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.font.measure.$1.val', link: 'color.font.measure.$1', width: 100, editable: true, value: '#FF0000', on: onHandler },
                              { view: 'link', name: 'color.font.measure.$1' },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.font.measure.$2.val', link: 'color.font.measure.$2', width: 100, editable: true, value: '#00FF00', on: onHandler },
                              { view: 'link', name: 'color.font.measure.$2' },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.font.measure.$3.val', link: 'color.font.measure.$3', width: 100, editable: true, value: '#0000FF', on: onHandler },
                              { view: 'link', name: 'color.font.measure.$3' },
                            ],
                          },
                          // fill
                          {
                            cols: [
                              { view: 'label', label: 'Цвет заливки (по умолчанию):', width: 220 },
                              { view: 'colorpicker', name: 'color.fill.measure', editable: true, value: '', default: '', on: onHandler, point: true },
                            ],
                          },
                          {
                            cols: [
                              { view: 'label', label: 'Плохое качество параметра:', width: 220 },
                              { view: 'colorpicker', name: 'color.fill.measure.bad', editable: true, value: '', default: '', on: onHandler },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.fill.measure.$1.val', link: 'color.fill.measure.$1', width: 100, editable: true, value: '#FF0000', on: onHandler },
                              { view: 'link', name: 'color.fill.measure.$1' },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.fill.measure.$2.val', link: 'color.fill.measure.$2', width: 100, editable: true, value: '#00FF00', on: onHandler },
                              { view: 'link', name: 'color.fill.measure.$2' },
                            ],
                          },
                          {
                            cols: [
                              { view: 'colorpicker', name: 'color.fill.measure.$3.val', link: 'color.fill.measure.$3', width: 100, editable: true, value: '#0000FF', on: onHandler },
                              { view: 'link', name: 'color.fill.measure.$3' },
                            ],
                          },
                        ],
                      },
                    },
                  },
                ],
              };
              bindings.push(measures_font_colors);
            }
            break;
          case 'group':
            {
              bindings.push(script);
              bindings.push(visibility);
            }
            break;
          case 'button':
            {
              bindings.push(script);
              bindings.push(visibility);
              bindings.push(label);
              bindings.push(blinking);
              bindings.push(rotation);
              bindings.push(turning);
              bindings.push(shifting);
              bindings.push(moving);
              bindings.push(action);
              bindings.push(commands);
  
              colors.rows.push(fillColor);
              colors.rows.push(borderColor);
              colors.rows.push(fontColor);
            }
            break;
          case 'chart':
            {
              let getRandomColor = function () {
                var letters = '0123456789ABCDEF'.split('');
                var color = '#';
                for (var i = 0; i < 6; i++) color += letters[Math.floor(Math.random() * 16)];
                return color;
              };
              let color_suggest = webix.ui({
                view: 'suggest',
                body: {
                  view: 'colorboard',
                  width: 235,
                  height: 200,
                  cols: 12,
                  rows: 10,
                },
              });
              let chart_items = {
                view: 'forminput',
                name: 'items',
                bind: function (data) {
                  if (data == null || data.length == 0) return;
  
                  let table = this.queryView('datatable');
                  table.blockEvent();
  
                  data.forEach(function (x) {
                    let item = GUID.isValid(x.id)
                      ? context.eqTree.getItem(x.id)
                      : context.paramsList.find(function (item) {
                          return item.n == x.id;
                        }, true);
                    if (item != null) {
                      item = mxUtils.clone(item);
                      // restore user description
                      $.extend(item, x);
                      //item.d = x.d;
                      table.config.bind.call(table, item);
                    }
                  });
  
                  table.refresh();
                  table.unblockEvent();
                },
                getValue: function () {
                  let table = this.queryView('datatable');
                  return table.config.getValue.call(table);
                },
                body: {
                  rows: [
                    { view: 'label', label: 'Список сигналов:' },
                    {
                      view: 'datatable',
                      resizeColumn: { size: 8 },
                      resizeRow: false,
                      editable: true,
                      headerRowHeight: 30,
                      navigation: true,
                      editaction: 'click',
                      select: 'cell',
                      rowHeight: 24,
                      scrollX: true,
                      drag: 'order',
                      dragColumn: 'order',
                      minHeight: 150,
                      data: [],
                      scheme: {
                        $init: function (obj) {
                          // default type
                          if (obj.view == null) obj.view = 2;
                          // random color
                          if (obj.color == null) obj.color = getRandomColor();
                        },
                        $serialize: function (obj) {
                          let result = {
                            id: obj.id,
                            d: obj.d,
                            view: obj.view,
                            color: obj.color,
                          };
                          if (obj.parent != null) result.parent = obj.parent;
                          return result;
                        },
                      },
                      columns: [
                        {
                          id: 'd',
                          header: 'Сигнал',
                          minWidth: 50,
                          fillspace: true,
                          editor: 'text',
                          sort: 'string',
                        },
                        {
                          id: 'view',
                          header: 'Тип',
                          minWidth: 60,
                          fillspace: true,
                          value: 2,
                          editor: 'select',
                          options: [
                            { id: 1, value: 'Точка' },
                            { id: 2, value: 'Линия' },
                            { id: 3, value: 'Линия с памятью' },
                            { id: 4, value: 'Столбцы' },
                          ],
                        },
                        {
                          id: 'color',
                          header: 'Цвет',
                          width: 95,
                          editor: 'text',
                          liveEdit: true,
                          tooltip: false,
                          suggest: color_suggest,
                          template: "<span style='background-color:#color#;border-style:solid;border-width:0.5px;border-color:#808080;border-radius:4px; padding-right:10px;cursor:pointer;'>&nbsp</span> #color#",
                        },
                        {
                          id: 'trash',
                          header: "<span class='webix_icon wxi-trash remove_all' title='" + 'common.delete_all' + "'></span>",
                          width: 35,
                          template: function (obj, common) {
                            let span = $(common.trashIcon(obj, common));
                            span.attr('title', 'common.delete');
                            return span[0].outerHTML;
                          },
                        },
                      ],
                      ready: function () {
                        $(this.$view).attr('drop_target', true);
                        webix.DragControl.addDrop(this.$view, context.dropLogic);
  
                        this.data.attachEvent(
                          'onStoreUpdated',
                          mxUtils.bind(this, function (id, obj, mode) {
                            context.properties.callEvent('onChange');
                          })
                        );
                      },
                      bind: function (item) {
                        this.data.blockEvent();
                        this.config.setValue.call(this, item);
                        this.data.unblockEvent();
                      },
                      setValue: function (item) {
                        if (item == null) return;
  
                        let value = {};
                        $.extend(value, item);
  
                        // tag
                        if (item.mid) {
                          value.id = item.n;
                          value.val = item.n;
                          value.d = item.d || item.desc || item.n;
                        }
                        // eq
                        else if (item.$count == 0 || item.eq) {
                          value.id = item.id;
                          value.val = context.eqTree.buildPath(item.id);
                          value.d = item.d || item.desc || item.n;
  
                          if (!item.eq) {
                            let parent = context.eqTree.findParentEquipment(item.id);
                            if (parent) value.parent = parent.id;
                          }
                        }
  
                        if (value != null && !$.isEmptyObject(value)) {
                          let index = this.getIndexById(this.getSelectedId());
                          this.add(value, index);
                        }
                      },
                      getValue: function () {
                        return this.serialize(true);
                      },
                      on: {
                        onFocus: onHandler.onFocus,
                        onAfterEditStart: function (cell) {
                          let item = this.getItem(cell.row);
                          if (!item) return false;
  
                          if (cell.column === 'color') {
                            var editor = this.getEditor(cell);
                            //show
                            $$(editor.config.suggest).linkInput(editor.node);
                            $$(editor.config.suggest).show(editor.node);
                            $$(editor.config.suggest).getBody().setValue(item.color);
                          }
                          return true;
                        },
                        onLiveEdit: function (state, editor, ignoreUpdate) {
                          let item = this.getItem(editor.row);
                          if (!item) return;
  
                          if (editor.column === 'color') {
                            item.color = state.value;
                            // update editor
                            editor.setValue(item.color);
                            // update suggest
                            var suggestView = $$(editor.config.suggest);
                            suggestView.getBody().setValue(item.color);
                          }
                          return true;
                        },
                        onBeforeEditStop: function (state, editor, ignoreUpdate) {
                          let item = this.getItem(editor.row);
                          if (!item) return;
  
                          if (editor.column === 'color') {
                            item.color = state.value;
                            var suggestView = $$(editor.config.suggest);
                            if (suggestView.isVisible()) {
                              var color = suggestView.getBody().getValue();
                              if (!isNullOrEmpty(color)) item.color = color;
                            }
                            state.value = item.color;
                          }
                        },
                        onBeforeAdd: function (id, obj, index) {
                          return !this.exists(id);
                        },
                        onSelectChange: function () {
                          let item = this.getSelectedItem();
                          if (item == null) return;
                          context.showItem(item.id);
                        },
                      },
                      onClick: {
                        'wxi-trash': function (evt, id) {
                          this.remove(id.row);
                          return false;
                        },
                        remove_all: function (evt, id, trg) {
                          let grid = this;
                          grid.editStop();
                          console.log('Удалить все сигналы', function (result) {
                            if (result === true) grid.clearAll();
                          })
                          // messageConfirm('Удалить все сигналы', function (result) {
                          //   if (result === true) grid.clearAll();
                          // });
                        },
                      },
                    },
                  ],
                },
              };
              let axisX = {
                view: 'accordion',
                multi: true,
                type: 'clean',
                margin: 2,
                rows: [
                  {
                    view: 'accordionitem',
                    header: 'Ось времени:',
                    headerHeight: 22,
                    headerAltHeight: 22,
                    collapsed: true,
                    body: {
                      rows: [
                        {
                          cols: [
                            { view: 'label', label: 'Ед. измерения:', width: 110 },
                            {
                              view: 'richselect',
                              name: 'axisX.measure',
                              value: 's',
                              options: [
                                { id: 'ms', value: 'Миллисекунды' },
                                { id: 's', value: 'Секунды' },
                                { id: 'mn', value: 'Минуты' },
                                { id: 'h', value: 'Часы' },
                                { id: 'd', value: 'Сутки' },
                                { id: 'w', value: 'Неделя' },
                                { id: 'm', value: 'Месяц' },
                                { id: 'y', value: 'Год' },
                              ],
                            },
                          ],
                        },
                        {
                          cols: [
                            { view: 'label', label: 'Ширина:', width: 110 },
                            { view: 'text', type: 'number', name: 'axisX.scale', value: 30 },
                          ],
                        },
                        {
                          cols: [
                            { view: 'label', label: 'Шаг сетки:', width: 110 },
                            { view: 'text', type: 'number', name: 'axisX.step', value: 5 },
                          ],
                        },
                        {
                          cols: [
                            { view: 'label', label: 'Надпись:', width: 110 },
                            { view: 'param', name: 'axisX.label' },
                          ],
                        },
                      ],
                    },
                  },
                ],
              };
              let axisY = {
                view: 'accordion',
                multi: true,
                type: 'clean',
                margin: 2,
                rows: [
                  {
                    view: 'accordionitem',
                    header: 'Ось значений:',
                    headerHeight: 22,
                    headerAltHeight: 22,
                    collapsed: true,
                    body: {
                      rows: [
                        {
                          cols: [
                            { view: 'label', label: 'Макс. значение:', width: 120 },
                            {
                              view: 'checkbox',
                              width: 30,
                              name: 'axisY.max.show',
                              value: 0,
                              default: 0,
                              tooltip: 'Отображать максимальное значение',
                              on: {
                                onFocus: onHandler.onFocus,
                                onChange: function () {
                                  this.callEvent('onReady', []);
                                },
                                onReady: function () {
                                  $$('maxVal').define('disabled', this.getValue() != 1);
                                  $$('maxVal').refresh();
                                },
                              },
                            },
                            { view: 'text', type: 'number', id: 'maxVal', name: 'axisY.max.value', value: 0, disabled: true },
                          ],
                        },
                        {
                          cols: [
                            { view: 'label', label: 'Мин. значение:', width: 120 },
                            {
                              view: 'checkbox',
                              width: 30,
                              name: 'axisY.min.show',
                              value: 0,
                              default: 0,
                              tooltip: 'Отображать минимальное значение',
                              on: {
                                onFocus: onHandler.onFocus,
                                onChange: function (newv) {
                                  this.callEvent('onReady', []);
                                },
                                onReady: function () {
                                  $$('minVal').define('disabled', this.getValue() != 1);
                                  $$('minVal').refresh();
                                },
                              },
                            },
                            { view: 'text', type: 'number', id: 'minVal', name: 'axisY.min.value', value: 0, disabled: true },
                          ],
                        },
                        {
                          cols: [
                            { view: 'label', label: 'Надпись:', width: 120 },
                            { view: 'param', name: 'axisY.label' },
                          ],
                        },
                      ],
                    },
                  },
                ],
              };
  
              bindings.push(script);
              bindings.push(visibility);
              bindings.push(header);
              bindings.push({
                cols: [
                  { view: 'label', label: 'Легенда:', width: 110 },
                  { view: 'checkbox', name: 'legend', default: 1, value: 1, on: onHandler },
                ],
              });
              bindings.push(chart_items);
              bindings.push(axisX);
              bindings.push(axisY);
              //bindings.push(action);
              colors.rows.push(fillColor);
              colors.rows.push(borderColor);
              colors.rows.push(fontColor);
            }
            break;
          case 'bmrz':
            {
              var settings = {
                view: 'accordion',
                multi: true,
                type: 'clean',
                margin: 2,
                rows: [
                  {
                    view: 'accordionitem',
                    header: 'Настройки подключения:',
                    headerHeight: 22,
                    headerAltHeight: 22,
                    collapsed: false,
                    body: {
                      id: 'settings',
                      visibleBatch: 'usb',
                      rows: [
                        {
                          cols: [
                            { view: 'label', label: 'Тип:', width: 110 },
                            {
                              view: 'select',
                              name: 'connection.type',
                              options: [
                                { id: 'usb', value: 'USB' },
                                { id: 'com', value: 'RS485(MODBUS-MT)' },
                                { id: 'eth', value: 'Ethernet(MODBUS-MT/TCP)' },
                              ],
                              on: {
                                onReady: function () {
                                  $$('settings').showBatch(this.getValue());
                                },
                                onChange: function (newv, oldv) {
                                  $$('settings').showBatch(newv);
                                },
                              },
                            },
                          ],
                        },
                        {
                          batch: 'usb',
                          height: 1,
                          template: '',
                        },
                        {
                          batch: 'com',
                          rows: [
                            {
                              cols: [
                                { view: 'label', label: 'Порт:', width: 110 },
                                { view: 'text', name: 'com.port', validate: API.SERIAL.validate_port, value: 'COM1', default: 'COM1' },
                              ],
                            },
                            {
                              cols: [
                                { view: 'label', label: 'Адрес:', width: 110 },
                                {
                                  view: 'text',
                                  name: 'com.address',
                                  validate: function (v) {
                                    return webix.rules.isNumber(v) && v > 0 && v < 248;
                                  },
                                  value: 55,
                                  default: 55,
                                },
                              ],
                            },
                            {
                              cols: [
                                { view: 'label', label: 'Скорость:', width: 110 },
                                { view: 'select', name: 'com.speed', options: API.SERIAL.baud_rates_array, value: 19200, default: 19200 },
                              ],
                            },
                            {
                              cols: [
                                { view: 'label', label: 'Чётность:', width: 110 },
                                { view: 'select', name: 'com.parity', options: API.SERIAL.parities_array, value: 0, default: 0 },
                              ],
                            },
                            {
                              cols: [
                                { view: 'label', label: 'Стоп. биты:', width: 110 },
                                { view: 'select', name: 'com.stop_bits', options: API.SERIAL.stop_bits_array, value: 1, default: 1 },
                              ],
                            },
                            {
                              cols: [
                                { view: 'label', label: 'Межпакетный интервал:', width: 180 },
                                {
                                  view: 'text',
                                  type: 'number',
                                  name: 'com.period',
                                  validate: function (v) {
                                    return webix.rules.isNumber(v) && v >= 0 && v <= 255;
                                  },
                                  value: 0,
                                  default: 0,
                                },
                              ],
                            },
                            {
                              cols: [
                                { view: 'label', label: 'Обмен с наличием эха:', width: 180 },
                                { view: 'checkbox', name: 'com.echo', value: 0, default: 0, on: onHandler },
                              ],
                            },
                          ],
                        },
                        {
                          batch: 'eth',
                          rows: [
                            {
                              cols: [
                                { view: 'label', label: 'IP-адрес:', width: 110 },
                                { view: 'text', name: 'eth.ip', validate: API.IPV4.validate, value: '1.1.1.1', default: '1.1.1.1' },
                              ],
                            },
                            {
                              cols: [
                                { view: 'label', label: 'Порт:', width: 110 },
                                {
                                  view: 'text',
                                  type: 'number',
                                  name: 'eth.port',
                                  validate: function (v) {
                                    return webix.rules.isNumber(v) && v > 0 && v < 65536;
                                  },
                                  value: 503,
                                  default: 503,
                                },
                              ],
                            },
                          ],
                        },
                      ],
                    },
                  },
                  {
                    view: 'accordionitem',
                    header: 'Файлы:',
                    headerHeight: 22,
                    headerAltHeight: 22,
                    collapsed: false,
                    body: {
                      rows: [
                        {
                          cols: [
                            { view: 'label', label: 'Путь к БФПО:', width: 110 },
                            {
                              view: 'path',
                              name: 'path.bfpo',
                              ext: 'sth',
                              id: 'path.bfpo',
                              validate: function (v) {
                                return isNullOrEmpty(v) || getExtension(v.trim()).toLowerCase() === 'sth';
                              },
                            },
                          ],
                        },
                        {
                          cols: [
                            { view: 'label', label: 'Путь к ПМК:', width: 110 },
                            {
                              view: 'path',
                              name: 'path.pmk',
                              ext: 'sth_a',
                              id: 'path.pmk',
                              validate: function (v) {
                                let result = false;
                                if (isNullOrEmpty(v)) {
                                  let bfpo = $$('path.bfpo').getValue();
                                  let readpmk = $$('read_pmk').getValue();
                                  result = isNullOrEmpty(bfpo) || readpmk == '1';
                                } else {
                                  result = getExtension(v.trim()).toLowerCase() === 'sth_a';
                                }
                                return result;
                              },
                            },
                          ],
                        },
                      ],
                    },
                  },
                  {
                    cols: [
                      { view: 'label', label: 'Подключиться к блоку:', width: 180 },
                      {
                        view: 'checkbox',
                        name: 'options.connect',
                        value: 0,
                        default: 0,
                        on: {
                          onFocus: onHandler.onFocus,
                          onChange: function () {
                            let pmk = $$('pmk');
                            if (this.getValue() == 1) pmk.show();
                            else {
                              $$('read_pmk').setValue(0);
                              pmk.hide();
                            }
                          },
                          onReady: function () {
                            this.callEvent('onChange');
                          },
                        },
                      },
                    ],
                  },
                  {
                    id: 'pmk',
                    hidden: true,
                    cols: [
                      { view: 'label', label: 'Вычитать ПМК:', width: 180 },
                      { view: 'checkbox', name: 'options.read_pmk', id: 'read_pmk', value: 0, default: 0, on: onHandler },
                    ],
                  },
                ],
              };
              bindings.push(settings);
            }
            break;
          default:
            {
              bindings.push(script);
              bindings.push(visibility);
              bindings.push(label);
              bindings.push(blinking);
              bindings.push(rotation);
              bindings.push(turning);
              bindings.push(shifting);
              bindings.push(moving);
              bindings.push(action);
  
              colors.rows.push(fillColor);
              colors.rows.push(borderColor);
              colors.rows.push(fontColor);
            }
            break;
        }
  
        // add colors section to binding
        if (colors.rows.length > 0) bindings.push(colors);
  
        return bindings;
      };
      Bindings.prototype.destroy = function () {
        if (this.eqTree) this.eqTree.destructor();
        if (this.paramsList) this.paramsList.destructor();
        if (this.properties) this.properties.destructor();
        if (this.paramsTab) this.paramsTab.destructor();
      };
      editorUi.Bindings = Bindings;
    })(window);
  
    this.initialize();
  };
  BindingsHandler.prototype.initialize = function () {
    let context = this;
  
    // Ignores canvas in codecs
    mxCell.prototype.mxTransient.push('chart', 'canvas', 'onBindingsUpdated');
    mxCodecRegistry.getCodec(mxCell).exclude.push('chart', 'canvas', 'onBindingsUpdated');
    mxCodecRegistry.getCodec(mxGraphModel).exclude.push('chart', 'canvas', 'onBindingsUpdated');
  
    // charts
    Chart.defaults.global.tooltips.enabled = false;
  
    let chartColors = {
      red: 'rgb(255, 99, 132)',
      blue: 'rgb(54, 162, 235)',
      max: 'rgb(255, 0, 255)',
      min: 'rgb(0, 255, 000)',
    };
    let randomData = function (unit, add, min, max) {
      if (min == null) min = -100;
      if (max == null) max = +100;
      if (unit == null) unit = 'second';
  
      let randomTime = function () {
        switch (unit) {
          case 'millisecond':
            return new Date().addMilliseconds(add || 0);
          case 'second':
            return new Date().addSeconds(add || 0);
          case 'minute':
            return new Date().addMinutes(add || 0);
          case 'hour':
            return new Date().addHours(add || 0);
          case 'day':
            return new Date().addDays(add || 0);
          case 'week':
            return new Date().addWeeks(add || 0);
          case 'month':
            return new Date().addMonths(add || 0);
          case 'year':
            return new Date().addWeeks(add || 0);
          default:
            return new Date().addSeconds(add || 0);
        }
      };
  
      return {
        x: randomTime(),
        y: Math.random() * (max - min) + min,
      };
    };
    var createMaxAnnotation = function (value) {
      return {
        id: 'y-max',
        type: 'line',
        mode: 'horizontal',
        scaleID: 'y-axis-1',
        value: value,
        borderColor: 'rgba(255, 0, 0, 1)',
        borderWidth: 1.5,
        borderDash: [5, 5],
        label: {
          enabled: true,
          backgroundColor: 'transparent',
          fontColor: '#ff0000',
          content: 'Макс.',
          position: 'right',
          fontSize: 10,
          yAdjust: +8,
          cornerRadius: 3,
        },
      };
    };
    var createMinAnnotation = function (value) {
      return {
        id: 'y-min',
        type: 'line',
        mode: 'horizontal',
        scaleID: 'y-axis-1',
        value: value,
        borderColor: 'rgba(0, 0, 255, 1)',
        borderWidth: 1.5,
        borderDash: [5, 5],
        label: {
          enabled: true,
          backgroundColor: 'transparent',
          fontColor: '#0000ff',
          content: 'Мин.',
          position: 'right',
          fontSize: 10,
          yAdjust: -8,
          cornerRadius: 3,
        },
      };
    };
    let getChartConfig = function () {
      return {
        type: 'scatter',
        data: {
          datasets: [
            {
              label: 'Тренд 1',
              fill: false,
              showLine: true,
              lineTension: 0,
              backgroundColor: chartColors.red,
              borderColor: chartColors.red,
              data: [],
            },
            {
              label: 'Тренд 2',
              fill: false,
              showLine: true,
              lineTension: 0,
              backgroundColor: chartColors.blue,
              borderColor: chartColors.blue,
              data: [],
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: {
            duration: 300,
          },
          title: {
            display: true,
            text: 'График',
          },
          legend: {
            display: true,
            position: 'top',
            onClick: function () {},
            labels: {
              boxWidth: 15,
              fontFamily: 'Arial',
              fontSize: 8,
              padding: 5,
              usePointStyle: false,
            },
          },
          scales: {
            xAxes: [
              {
                display: true,
                type: 'time',
                autoSkip: false,
                position: 'bottom',
                distribution: 'linear',
                bounds: 'ticks',
                time: {
                  isoWeekday: true,
                  unit: 'second',
                  //unitStepSize: 10,
                  //stepSize: 1,
                  //precision: 1,
                  //round: true,
                  //minUnit: 'hour',
                  displayFormats: {
                    millisecond: 'ss.SSS',
                    second: 'mm:ss.SSS',
                    minute: 'HH:mm:ss',
                    hour: 'DD.MM HH:mm',
                    day: 'DD.MM',
                    week: 'WW.YYYY',
                    month: 'DD.MM.YYYY',
                    quarter: 'Q YYYY',
                    year: 'YYYY',
                  },
                },
                scaleLabel: {
                  display: true,
                  labelString: 'Время',
                  lineHeight: 1,
                  fontFamily: 'Arial',
                  fontSize: 10,
                  padding: { bootom: 5 },
                },
                //ticks:
                //{
                //    source: "auto",
                //    //maxTicksLimit: 10,
                //    //autoSkip: true,
                //    stepSize: 5,
                //    //precision: 1,
  
                //    lineHeight: 1,
                //    fontFamily: 'Arial',
                //    fontSize: 10,
                //    padding: 0,
                //    maxRotation: 45,
                //    //callback: function (value, index, values)
                //    //{
                //    //    //return API.FORMAT.getDateTimeString(value);
                //    //    return moment(value).format('HH:mm:ss');
                //    //}
                //}
              },
            ],
            yAxes: [
              {
                display: true,
                scaleLabel: {
                  display: true,
                  labelString: 'Значение',
                  lineHeight: 1,
                  fontFamily: 'Arial',
                  fontSize: 10,
                  padding: { top: 5 },
                },
                ticks: {
                  source: 'data',
                  maxTicksLimit: 10,
                  //stepSize: 1,
                  precision: 3,
                  lineHeight: 1,
                  fontFamily: 'Arial',
                  fontSize: 10,
                },
              },
            ],
          },
          layout: {
            padding: 0,
          },
          annotation: {
            drawTime: 'afterDraw',
            annotations: [createMaxAnnotation(90), createMinAnnotation(-90)],
          },
        },
      };
    };
  
    let graphModelSetValue = this.graph.model.setValue;
    this.graph.model.setValue = function (cell, value) {
      cell.canvas = null;
      cell.chart = null;
      cell.table = null;
      cell.onBindingsUpdated = null;
      graphModelSetValue.apply(this, arguments);
    };
  
    let graphFireMouseEvent = this.graph.fireMouseEvent;
    this.graph.fireMouseEvent = function (evtName, me, sender) {
      if (evtName == mxEvent.MOUSE_DOWN || evtName == mxEvent.MOUSE_UP) {
        if (me.state?.cell.isTable) {
          // get parent cell for inner table
          const parent = context.graph.model.getParent(me.state.cell);
          // change event target cell
          me.state = this.view.getState(parent);
        }
        if (me.state?.cell.isPoster) {
          // get parent cell for inner table
          const parent = context.graph.model.getParent(me.state.cell);
          // change event target cell
          me.state = this.view.getState(parent);
        }
      }
      if (evtName == mxEvent.MOUSE_MOVE) {
        if (me.state?.cell.isPoster) {
          // get parent cell for inner table
          const parent = context.graph.model.getParent(me.state.cell);
          // change event target cell
          me.state = this.view.getState(parent);
        }
      }
      graphFireMouseEvent.apply(this, arguments);
    };
  
    let mxGraphViewValidatePosterState = mxGraphView.prototype.validateCellState;
    mxGraphView.prototype.validatePosterState = function (cell, recurse) {
    
      let context = this.graph;
      let state = this.getState(cell);
      if (state != null && context.model.isVertex(cell)) {
        let geom = context.getCellGeometry(cell);
        cell.onBindingsUpdated = mxUtils.bind(cell, function () {
          // check content cell
          let posterCell = this.getChildAt(0);
          if (posterCell == null) {
            // build cell
            posterCell = new mxCell('', new mxGeometry(0, 0, geom.width, geom.height), 'text;html=1;overflow=fill;connectable=0;resizable=0;deletable=0;selectable=0;rotatable=0;editable=0;pointerEvents=0;'); //movable=0;
            posterCell.vertex = true;
            posterCell.isPoster = 1;
            posterCell.isTable = true;
            if (!this.children) {
              posterCell = context.model.add(this, posterCell);
            }
          }
          let styleBinding = this.getBinding('style');
          let style = styleBinding != null ? JSON.parse($(styleBinding).attr('value')) : 'ptbl-default';
  
          // get bindings from default cell style
          const parentStyles = (cell.style || '').split(';');
          const getStyleByKey = (key) => {
            const style = parentStyles.find((x) => x.startsWith(key));
            return style?.includes('=') ? style.split('=')[1] : '';
          };
  
          //get background image
          let image = null;
          API.POSTERS.metadata.forEach((el) => {
            var pattern = /\b[a-zA-Z]+\b/;
            if (cell._model) {
              if (cell._model.data.type) {
                const type = cell._model.data.type.match(pattern)[0];
                if (el.key === type) {
                  image = `url(${el.src})`;
                }
              }
            }
          });
  
          // get stroke width
          let strokeWidth = (+getStyleByKey('strokeWidth') || 0) + 1; // min 1 px
          if (strokeWidth % 2 !== 0) strokeWidth++; // should be even
  
          context.model.beginUpdate();
  
          // update content
          let poster = '<div class="poster-block {S}" style="width:{TW};height:{TH}; background-image:{IMG}; background-size:{IMG_SZ}; background-position:{IMG_POS}; background-repeat:{IMG_RE}"></div>';
  
          poster = poster
            .replace('{ID}', this.id)
            .replace('{S}', style)
            .replace('{TW}', `calc(100% - ${strokeWidth}px)`) // fix table position
            .replace('{TH}', `calc(100% - ${strokeWidth}px)`) // fix table position
            .replace('{IMG}', `${image}`)
            .replace('{IMG_SZ}', 'cover')
            .replace('{IMG_POS}', 'center')
            .replace('{IMG_RE}', 'no-repeat');
  
          context.model.setValue(posterCell, poster);
  
          context.model.endUpdate();
        });
        cell.onBindingsUpdated();
      }
      return mxGraphViewValidatePosterState.apply(this, arguments);
    };
  
    let mxGraphViewValidateCellState = mxGraphView.prototype.validateCellState;
    mxGraphView.prototype.validateCellState = function (cell, recurse) {
      let context = this.graph;
      let state = this.getState(cell);
  
      if (state != null && context.model.isVertex(cell)) {
        let shape = state.style[mxConstants.STYLE_SHAPE];
        let geom = context.getCellGeometry(cell);
  
        switch (shape) {
          case 'chart':
            {
              if (cell.canvas == null) {
                // build chart
                var node = document.createElement('canvas');
                node.setAttribute('id', cell.mxObjectId);
                node.setAttribute('class', 'chart');
                node.setAttribute('width', geom.width);
                node.setAttribute('height', geom.height);
                // Document for empty output if not in DOM
                //document.body.appendChild(node);
                cell.canvas = node;
                cell.chart = new Chart.Scatter(node.getContext('2d'), getChartConfig());
  
                if (cell.onBindingsUpdated == null) {
                  cell.onBindingsUpdated = mxUtils.bind(cell, function () {
                    if (this.chart != null) {
                      // header
                      this.chart.options.title.display = false;
                      let hdrBinding = this.getBinding('header');
                      if (hdrBinding != null) {
                        let hdr = JSON.parse(hdrBinding.value);
                        if (hdr != null && hdr.text != null) {
                          this.chart.options.title.text = hdr.text;
                          this.chart.options.title.display = true;
                        }
                      }
                      // legend
                      let legendBinding = this.getBinding('legend');
                      this.chart.options.legend.display = legendBinding == null || JSON.parse(legendBinding.value) != '0';
  
                      // axisX.label
                      this.chart.options.scales.xAxes[0].scaleLabel.display = false;
                      let axisXLabelBinding = this.getBinding('axisX.label');
                      if (axisXLabelBinding != null) {
                        let axisXLabel = JSON.parse(axisXLabelBinding.value);
                        if (axisXLabel != null && axisXLabel.text != null) {
                          this.chart.options.scales.xAxes[0].scaleLabel.labelString = axisXLabel.text;
                          this.chart.options.scales.xAxes[0].scaleLabel.display = true;
                        }
                      }
  
                      // axisX.measure
                      let xUnit = 'second';
                      let axisXMeasureBinding = this.getBinding('axisX.measure');
                      if (axisXMeasureBinding != null) {
                        let axisXMeasure = JSON.parse(axisXMeasureBinding.value);
                        switch (axisXMeasure) {
                          case 'ms':
                            xUnit = 'millisecond';
                            break;
                          case 's':
                            xUnit = 'second';
                            break;
                          case 'mn':
                            xUnit = 'minute';
                            break;
                          case 'h':
                            xUnit = 'hour';
                            break;
                          case 'd':
                            xUnit = 'day';
                            break;
                          case 'w':
                            xUnit = 'week';
                            break;
                          case 'm':
                            xUnit = 'month';
                            break;
                          case 'y':
                            xUnit = 'year';
                            break;
                          default:
                            xUnit = 'second';
                            break;
                        }
                      }
                      this.chart.options.scales.xAxes[0].time.unit = xUnit;
  
                      // axisX.step
                      let xStep = 1;
                      this.chart.options.scales.xAxes[0].time.stepSize = xStep;
                      let axisXStepBinding = this.getBinding('axisX.step');
                      if (axisXStepBinding != null) {
                        let axisXStep = JSON.parse(axisXStepBinding.value);
                        xStep = parseNumber(axisXStep) || 1;
                        this.chart.options.scales.xAxes[0].time.stepSize = xStep;
                      }
  
                      // axisX.scale
                      let xScale = 30;
                      let axisXScaleBinding = this.getBinding('axisX.scale');
                      if (axisXScaleBinding != null) {
                        let axisXScale = JSON.parse(axisXScaleBinding.value);
                        xScale = parseNumber(axisXScale) || 30;
                      }
  
                      // axisY.label
                      this.chart.options.scales.yAxes[0].scaleLabel.display = false;
                      let axisYLabelBinding = this.getBinding('axisY.label');
                      if (axisYLabelBinding != null) {
                        let axisYLabel = JSON.parse(axisYLabelBinding.value);
                        if (axisYLabel != null && axisYLabel.text != null) {
                          this.chart.options.scales.yAxes[0].scaleLabel.labelString = axisYLabel.text;
                          this.chart.options.scales.yAxes[0].scaleLabel.display = true;
                        }
                      }
  
                      // clear axisY annotations
                      this.chart.options.annotation.annotations.length = 0;
                      this.chart.annotation.elements = {};
                      this.chart.annotation.options.annotations.length = 0;
  
                      // axisY.max
                      let maxValue = null;
                      let axisYMaxBinding = this.getBinding('axisY.max.show');
                      if (axisYMaxBinding != null) {
                        let axisYMaxShow = JSON.parse(axisYMaxBinding.value);
                        if (axisYMaxShow != null && axisYMaxShow != '0') {
                          let axisYMaxValueBinding = this.getBinding('axisY.max.value');
                          if (axisYMaxValueBinding != null) {
                            let axisYMaxValue = JSON.parse(axisYMaxValueBinding.value);
                            if (axisYMaxValue != null) maxValue = parseNumber(axisYMaxValue, 0, 3);
                          }
                          let annotation = createMaxAnnotation(maxValue);
                          this.chart.options.annotation.annotations.push(annotation); // show
                        }
                      }
                      // axisY.min
                      let minValue = null;
                      let axisYMinBinding = this.getBinding('axisY.min.show');
                      if (axisYMinBinding != null) {
                        let axisYMinShow = JSON.parse(axisYMinBinding.value);
                        if (axisYMinShow != null && axisYMinShow != '0') {
                          let axisYMinValueBinding = this.getBinding('axisY.min.value');
                          if (axisYMinValueBinding != null) {
                            let axisYMinValue = JSON.parse(axisYMinValueBinding.value);
                            if (axisYMinValue != null) minValue = parseNumber(axisYMinValue, 0, 3);
                          }
                          let annotation = createMinAnnotation(minValue);
                          this.chart.options.annotation.annotations.push(annotation); // show
                        }
                      }
  
                      // items
                      this.chart.data.datasets = [];
                      let itemsBinding = this.getBinding('items');
                      if (itemsBinding != null) {
                        let getType = function (item) {
                          switch (item.view) {
                            case '4': // bars
                              return 'bar';
                            default:
                              return 'scatter';
                          }
                        };
                        let getShowLine = function (item) {
                          switch (item.view) {
                            case '1': // points
                              return false;
                            default:
                              return true;
                          }
                        };
  
                        let items = JSON.parse(itemsBinding.value);
                        if (items != null && items.length > 0) {
                          for (let i = 0; i < items.length; i++) {
                            let item = items[i];
                            if (item != null) {
                              this.chart.data.datasets.push({
                                label: item.d,
                                fill: false,
                                showLine: getShowLine(item),
                                lineTension: 0,
                                backgroundColor: item.color,
                                borderColor: item.color,
                                type: getType(item),
                                steppedLine: item.view == '3' ? 'before' : false, // stepped line
                                data: [randomData(xUnit, +0, minValue, maxValue), randomData(xUnit, +10, minValue, maxValue), randomData(xUnit, +20, minValue, maxValue)],
                              });
                            }
                          }
                        }
                      }
  
                      // update x-axis width
                      if (xScale > 0 && xStep > 0) {
                        let xAxis = this.chart.scales['x-axis-1'];
                        let minDate = moment(xAxis.min).toDate();
                        let maxDate = moment(xAxis.max).toDate();
  
                        switch (xUnit) {
                          case 'millisecond':
                            minDate = maxDate.addMilliseconds(-xScale || 0);
                            break;
                          case 'second':
                            minDate = maxDate.addSeconds(-xScale || 0);
                            break;
                          case 'minute':
                            minDate = maxDate.addMinutes(-xScale || 0);
                            break;
                          case 'hour':
                            minDate = maxDate.addHours(-xScale || 0);
                            break;
                          case 'day':
                            minDate = maxDate.addDays(-xScale || 0);
                            break;
                          case 'week':
                            minDate = maxDate.addWeeks(-xScale || 0);
                            break;
                          case 'month':
                            minDate = maxDate.addMonths(-xScale || 0);
                            break;
                          case 'year':
                            minDate = maxDate.addWeeks(-xScale || 0);
                            break;
                          default:
                            break;
                        }
  
                        if (minDate != null) this.chart.options.scales.xAxes[0].ticks.min = moment(minDate);
                      }
  
                      this.chart.update();
                    }
                  });
                  cell.onBindingsUpdated();
                }
              }
            }
            break;
          case 'table':
            {
              if (cell.onBindingsUpdated == null) {
                cell.onBindingsUpdated = mxUtils.bind(cell, function () {
                  // check content cell
                  let tableCell = this.getChildAt(0);
                  if (tableCell == null) {
                    // build cell
                    tableCell = new mxCell('Параметры', new mxGeometry(0, 0, geom.width, geom.height), 'text;html=1;overflow=fill;connectable=0;resizable=0;deletable=0;selectable=0;rotatable=0;editable=0;pointerEvents=0;'); //movable=0;
                    tableCell.vertex = true;
                    tableCell.connectable = false;
                    tableCell.isTable = true;
                    tableCell = context.model.add(this, tableCell);
                  }
  
                  let itemsBinding = this.getBinding('items');
                  let items = itemsBinding != null ? JSON.parse($(itemsBinding).attr('value')) : [];
  
                  let styleBinding = this.getBinding('style');
                  let style = styleBinding != null ? JSON.parse($(styleBinding).attr('value')) : 'ptbl-default';
  
                  let measureBinding = this.getBinding('measure');
                  let showMeasure = measureBinding != null ? JSON.parse($(measureBinding).attr('value')) == 1 : false;
  
                  let w1Binding = this.getBinding('w1');
                  let w1 = w1Binding != null ? JSON.parse($(w1Binding).attr('value')) + 'px' : '40%';
                  let w2Binding = this.getBinding('w2');
                  let w2 = w2Binding != null ? JSON.parse($(w2Binding).attr('value')) + 'px' : '40%';
  
                  const fontSizeBinding = this.getBinding('fontSize');
                  const fontSize = fontSizeBinding != null ? JSON.parse($(fontSizeBinding).attr('value')) + 'px' : '10px';
  
                  // get bindings from default cell style
                  const parentStyles = (cell.style || '').split(';');
                  const getStyleByKey = (key) => {
                    const style = parentStyles.find((x) => x.startsWith(key));
                    return style?.includes('=') ? style.split('=')[1] : '';
                  };
  
                  // get stroke color
                  const strokeColor = getStyleByKey('strokeColor') || 'grey';
  
                  // get stroke width
                  let strokeWidth = (+getStyleByKey('strokeWidth') || 0) + 1; // min 1 px
                  if (strokeWidth % 2 !== 0) strokeWidth++; // should be even
  
                  context.model.beginUpdate();
  
                  // update content
                  let table = '<table class="tbl{ID} {S}" style="width:{TW};height:{TH};margin-top:{TM};font-size:{FS}"><tbody>{B}</tbody></table>';
  
                  let rows = [];
                  for (let i = 0; i < items.length; i++) {
                    let item = items[i];
                    let ncell = '<td class="c-name"  style="width:{w1}; border-color:{BC}">{N}</td>'.replace('{N}', item.d || '&nbsp;').replace('{BC}', strokeColor);
                    let vcell = '<td class="c-value" style="width:{w2}; border-color:{BC}">{V}</td>'.replace('{V}', item.v || '&nbsp;').replace('{BC}', strokeColor);
                    // build row
                    let row = '<tr id="{ID}">'.replace('{ID}', item.id);
                    row += ncell;
                    row += vcell;
                    if (showMeasure) {
                      let mcell = '<td class="c-measure" style="border-color:{BC}">{M}</td>'.replace('{M}', item.m || '&nbsp;').replace('{BC}', strokeColor);
                      row += mcell;
                    }
                    row += '</tr>';
                    // column width
                    row = row.replace('{w1}', w1);
                    row = row.replace('{w2}', w2);
                    rows.push(row);
                  }
  
                  table = table
                    .replace('{ID}', this.id)
                    .replace('{S}', style)
                    .replace('{FS}', fontSize)
                    .replace('{TW}', `calc(100% - ${strokeWidth}px)`) // fix table position
                    .replace('{TH}', `calc(100% - ${strokeWidth}px)`) // fix table position
                    .replace('{TM}', `${Math.ceil(strokeWidth / 2)}px`) // fix table position
                    .replace('{B}', rows.join(''));
                  context.model.setValue(tableCell, table);
  
                  context.model.endUpdate();
                });
                cell.onBindingsUpdated();
              }
            }
            break;
        }
      }
      return mxGraphViewValidateCellState.apply(this, arguments);
    };
  
    let graphConvertValueToString = this.graph.convertValueToString;
    this.graph.convertValueToString = function (cell) {
      if (this.model.isVertex(cell)) {
        let state = this.view.getState(cell);
        if (state != null) {
          switch (state.style[mxConstants.STYLE_SHAPE]) {
            case 'chart': {
              // remove image
              if (state.shape.image != null) {
                delete state.shape.image;
                this.cellRenderer.doRedrawShape(state);
              }
              return cell.canvas;
            }
          }
        }
      }
      return graphConvertValueToString.apply(this, arguments);
    };
  };
  BindingsHandler.prototype.ready = function () {
    // rebuild(update) all cells view
    var filter = mxUtils.bind(this.graph, function (cell) {
      return !this.model.isLayer(cell) && !this.model.isRoot(cell) && cell.bindings != null;
    });
    this.graph.model.filterDescendants(filter).forEach(function (cell) {
      if (cell.onBindingsUpdated != null) cell.onBindingsUpdated();
    });
  };

  //Actions.js

  // import * as mxgraph from 'mxgraph';
// import Editor, {PrintDialog, PageSetupDialog } from './Editor'
// import { 
//     ExportDialog, 
//     EditDiagramDialog, 
//     TextareaDialog, 
//     FilenameDialog, 
//     LayersWindow, 
//     SidebarWindow,
//     FormatWindow,
//     OutlineWindow,
//     BindingsWindow, 
// } from './Dialogs'
// import { ChangePageSetup } from './EditorUi'

// let { 
//     mxClient, 
//     mxUtils, 
//     mxResources, 
//     mxRectangle,
//     mxConstants,
//     mxEvent,
//     mxEdgeHandler,
//     mxEventObject,
//     mxCell,
//     mxGeometry,
//     mxClipboard,
//     mxEventSource,
// } = mxgraph();

//export default function Actions(editorUi)

function Actions(editorUi)
{
    this.editorUi = editorUi;
    this.actions = new Object();
    this.init();
}
/**
 * Adds the default actions.
 */
Actions.prototype.init = function()
{
    var ui = this.editorUi;
    var editor = ui.editor;
    var graph = editor.graph;
    var isGraphEnabled = function()
    {
        return Action.prototype.isEnabled.apply(this, arguments) && graph.isEnabled();
    };
    var action = null;

    // File actions
    this.addAction('new...', function ()
    {
        graph.model.clear();
        editor.setModified(false);
    }, null, null, 'Shift+N');
    //this.addAction('open...', function()
    //{
    //    window.openNew = true;
    //    window.openKey = 'open';
        
    //    ui.openFile();
    //}, null, null, 'Shift+O');
    //this.addAction('import...', function()
    //{
    //    window.openNew = false;
    //    window.openKey = 'import';
        
    //    // Closes dialog after open
    //    window.openFile = new OpenFile(mxUtils.bind(this, function()
    //    {
    //        ui.hideDialog();
    //    }));
        
    //    window.openFile.setConsumer(mxUtils.bind(this, function(xml, filename)
    //    {
    //        try
    //        {
    //            var doc = mxUtils.parseXml(xml);
    //            editor.graph.setSelectionCells(editor.graph.importGraphModel(doc.documentElement));
    //        }
    //        catch (e)
    //        {
    //            messageError(mxResources.get('invalidOrMissingFile') + ': ' + e.message);
    //        }
    //    }));

    //    // Removes openFile if dialog is closed
    //    ui.showDialog(new OpenDialog(this).container, 320, 220, true, true, function()
    //    {
    //        window.openFile = null;
    //    });
    //}).isEnabled = isGraphEnabled;
    this.addAction('save', function() { ui.saveFile(false); }, null, null, Editor.ctrlKey + '+S').isEnabled = isGraphEnabled;
    this.addAction('saveAs...', function () { ui.saveFile(true); }, null, null, Editor.ctrlKey + '+Shift+S').isEnabled = isGraphEnabled;
    action = this.addAction('export...', function () { ui.showDialog(new ExportDialog(ui).container, 300, 230, true, true); });
    action.setEnabled(false);
    this.addAction('editDiagram...', function()
    {
        var dlg = new EditDiagramDialog(ui);
        ui.showDialog(dlg.container, 600, 400, true, true);
        dlg.init();
    });
    this.addAction('pageSetup...', function() { ui.showDialog(new PageSetupDialog(ui).container, 300, 180, true, true); }).isEnabled = isGraphEnabled;
    this.addAction('print...', function() { ui.showDialog(new PrintDialog(ui).container, 300, 180, true, true); }, null, 'sprite-print', Editor.ctrlKey + '+P');
    this.addAction('preview', function() { mxUtils.show(graph, null, 10, 10); });
    
    // Edit actions
    this.addAction('undo', function() { ui.undo(); }, null, 'sprite-undo', Editor.ctrlKey + '+Z');
    this.addAction('redo', function() { ui.redo(); }, null, 'sprite-redo', (!mxClient.IS_WIN) ? Editor.ctrlKey + '+Shift+Z' : Editor.ctrlKey + '+Y');
    this.addAction('cut', function() { mxClipboard.cut(graph); }, null, 'sprite-cut', Editor.ctrlKey + '+X');
    this.addAction('copy', function() { mxClipboard.copy(graph); }, null, 'sprite-copy', Editor.ctrlKey + '+C');
    this.addAction('paste', function(evt)
    {
        if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent()))
        {
            graph.setEventSource(evt);
            mxClipboard.paste(graph);
        }
    }, false, 'sprite-paste', Editor.ctrlKey + '+V');
    this.addAction('pasteHere', function(evt)
    {
        if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent()))
        {
            graph.getModel().beginUpdate();
            try
            {
                graph.setEventSource(evt);
                var cells = mxClipboard.paste(graph);
                
                if (cells != null)
                {
                    var includeEdges = true;
                    
                    for (var i = 0; i < cells.length && includeEdges; i++)
                    {
                        includeEdges = includeEdges && graph.model.isEdge(cells[i]);
                    }

                    var t = graph.view.translate;
                    var s = graph.view.scale;
                    var dx = t.x;
                    var dy = t.y;
                    var bb = null;
                    
                    if (cells.length == 1 && includeEdges)
                    {
                        var geo = graph.getCellGeometry(cells[0]);
                        
                        if (geo != null)
                        {
                            bb = geo.getTerminalPoint(true);
                        }
                    }

                    bb = (bb != null) ? bb : graph.getBoundingBoxFromGeometry(cells, includeEdges);
                    
                    if (bb != null)
                    {
                        var x = Math.round(graph.snap(graph.popupMenuHandler.triggerX / s - dx));
                        var y = Math.round(graph.snap(graph.popupMenuHandler.triggerY / s - dy));
                        
                        graph.cellsMoved(cells, x - bb.x, y - bb.y);
                    }
                }
            }
            finally
            {
                graph.getModel().endUpdate();
            }
        }
    });
    
    this.addAction('copySize', function(evt)
    {
        var cell = graph.getSelectionCell();
        
        if (graph.isEnabled() && cell != null && graph.getModel().isVertex(cell))
        {
            var geo = graph.getCellGeometry(cell);
            
            if (geo != null)
            {
                ui.copiedSize = new mxRectangle(geo.x, geo.y, geo.width, geo.height);
            }
        }
    }, null, null, 'Alt+Shit+X');
    this.addAction('pasteSize', function(evt)
    {
        if (graph.isEnabled() && !graph.isSelectionEmpty() && ui.copiedSize != null)
        {
            graph.getModel().beginUpdate();
            
            try
            {
                var cells = graph.getSelectionCells();
                
                for (var i = 0; i < cells.length; i++)
                {
                    if (graph.getModel().isVertex(cells[i]))
                    {
                        var geo = graph.getCellGeometry(cells[i]);
                        
                        if (geo != null)
                        {
                            geo = geo.clone();
                            geo.width = ui.copiedSize.width;
                            geo.height = ui.copiedSize.height;
                            
                            graph.getModel().setGeometry(cells[i], geo);
                        }
                    }
                }
            }
            finally
            {
                graph.getModel().endUpdate();
            }
        }
    }, null, null, 'Alt+Shit+V');
    
    function deleteCells(includeEdges)
    {
        // Cancels interactive operations
        graph.escape();
        var cells = graph.getDeletableCells(graph.getSelectionCells());
        
        if (cells != null && cells.length > 0)
        {
            var parents = (graph.selectParentAfterDelete) ? graph.model.getParents(cells) : null;
            graph.removeCells(cells, includeEdges);
            
            // Selects parents for easier editing of groups
            if (parents != null)
            {
                var select = [];
                
                for (var i = 0; i < parents.length; i++)
                {
                    if (graph.model.contains(parents[i]) &&
                        (graph.model.isVertex(parents[i]) ||
                        graph.model.isEdge(parents[i])))
                    {
                        select.push(parents[i]);
                    }
                }
                
                graph.setSelectionCells(select);
            }
        }
    };
    
    this.addAction('delete', function(evt)
    {
        deleteCells(evt != null && mxEvent.isShiftDown(evt));
    }, null, null, 'Delete');
    this.addAction('deleteAll', function()
    {
        deleteCells(true);
    }, null, null, Editor.ctrlKey + '+Delete');
    this.addAction('duplicate', function()
    {
        graph.setSelectionCells(graph.duplicateCells());
    }, null, null, Editor.ctrlKey + '+D');
    this.put('turn', new Action(mxResources.get('turn') + ' / ' + mxResources.get('reverse'), function()
    {
        graph.turnShapes(graph.getSelectionCells());
    }, null, null, Editor.ctrlKey + '+R'));
    this.addAction('selectVertices', function() { graph.selectVertices(); }, null, null, Editor.ctrlKey + '+Shift+I');
    this.addAction('selectEdges', function() { graph.selectEdges(); }, null, null, Editor.ctrlKey + '+Shift+E');
    this.addAction('selectAll', function() { graph.selectAll(null, true); }, null, null, Editor.ctrlKey + '+A');
    this.addAction('selectNone', function() { graph.clearSelection(); }, null, null, Editor.ctrlKey + '+Shift+A');
    this.addAction('lockUnlock', function()
    {
        if (!graph.isSelectionEmpty())
        {
            graph.getModel().beginUpdate();
            try
            {
                var defaultValue = graph.isCellMovable(graph.getSelectionCell()) ? 1 : 0;
                graph.toggleCellStyles(mxConstants.STYLE_MOVABLE, defaultValue);
                graph.toggleCellStyles(mxConstants.STYLE_RESIZABLE, defaultValue);
                graph.toggleCellStyles(mxConstants.STYLE_ROTATABLE, defaultValue);
                graph.toggleCellStyles(mxConstants.STYLE_DELETABLE, defaultValue);
                graph.toggleCellStyles(mxConstants.STYLE_EDITABLE, defaultValue);
                graph.toggleCellStyles(mxConstants.STYLE_CONNECTABLE, defaultValue);
            }
            finally
            {
                graph.getModel().endUpdate();
            }
        }
    }, null, null, Editor.ctrlKey + '+L');

    // Navigation actions
    //this.addAction('home', function() { graph.home(); }, null, null, 'Home');
    //this.addAction('exitGroup', function() { graph.exitGroup(); }, null, null, Editor.ctrlKey + '+Shift+Home');
    //this.addAction('enterGroup', function() { graph.enterGroup(); }, null, null, Editor.ctrlKey + '+Shift+End');
    this.addAction('collapse', function() { graph.foldCells(true); }, null, null, Editor.ctrlKey + '+Home');
    this.addAction('expand', function() { graph.foldCells(false); }, null, null, Editor.ctrlKey + '+End');
    
    // Arrange actions
    this.addAction('toFront', function() { graph.orderCells(false); }, null, null, Editor.ctrlKey + '+Shift+F');
    this.addAction('toBack', function() { graph.orderCells(true); }, null, null, Editor.ctrlKey + '+Shift+B');
    this.addAction('group', function()
    {
        if (graph.getSelectionCount() == 1)
        {
            graph.setCellStyles('container', '1');
        }
        else
        {
            graph.setSelectionCell(graph.groupCells(null, 0));
        }
    }, null, null, Editor.ctrlKey + '+G');
    this.addAction('ungroup', function()
    {
        if (graph.getSelectionCount() == 1 && graph.getModel().getChildCount(graph.getSelectionCell()) == 0)
        {
            graph.setCellStyles('container', '0');
        }
        else
        {
            graph.setSelectionCells(graph.ungroupCells());
        }
    }, null, null, Editor.ctrlKey + '+Shift+U');
    this.addAction('removeFromGroup', function () { graph.removeCellsFromParent(); });

    // Adds action
    this.addAction('edit', function()
    {
        if (graph.isEnabled())
        {
            graph.startEditingAtCell();
        }
    }, null, null, 'F2/Enter');
    this.addAction('editData...', function()
    {
        var cell = graph.getSelectionCell() || graph.getModel().getRoot();
        ui.showDataDialog(cell);
    }, null, null, Editor.ctrlKey + '+M');
    this.addAction('editTooltip...', function()
    {
        var graph = ui.editor.graph;
        
        if (graph.isEnabled() && !graph.isSelectionEmpty())
        {
            var cell = graph.getSelectionCell();
            var tooltip = '';
            
            if (mxUtils.isNode(cell.value))
            {
                var tmp = cell.value.getAttribute('tooltip');
                
                if (tmp != null)
                {
                    tooltip = tmp;
                }
            }
            
            var dlg = new TextareaDialog(ui, mxResources.get('editTooltip') + ':', tooltip, function(newValue)
            {
                graph.setTooltipForCell(cell, newValue);
            });
            ui.showDialog(dlg.container, 320, 200, true, true);
            dlg.init();
        }
    }, null, null, 'Alt+Shift+T');
    this.addAction('openLink', function()
    {
        var link = graph.getLinkForCell(graph.getSelectionCell());
        
        if (link != null)
        {
            graph.openLink(link);
        }
    });
    this.addAction('editLink...', function()
    {
        var graph = ui.editor.graph;
        
        if (graph.isEnabled() && !graph.isSelectionEmpty())
        {
            var cell = graph.getSelectionCell();
            var value = graph.getLinkForCell(cell) || '';
            
            ui.showLinkDialog(value, mxResources.get('apply'), function(link)
            {
                link = mxUtils.trim(link);
                graph.setLinkForCell(cell, (link.length > 0) ? link : null);
            });
        }
    }, null, null, 'Alt+Shift+L');
    this.put('insertImage', new Action(mxResources.get('insertImage') + '...', function()
    {
        if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent()))
        {
            graph.clearSelection();
            ui.actions.get('image').funct();
        }
    })).isEnabled = isGraphEnabled;
    this.put('insertLink', new Action(mxResources.get('insertLink') + '...', function()
    {
        if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent()))
        {
            ui.showLinkDialog('', mxResources.get('insert'), function(link, docs)
            {
                link = mxUtils.trim(link);
                
                if (link.length > 0)
                {
                    var icon = null;
                    var title = graph.getLinkTitle(link);
                    
                    if (docs != null && docs.length > 0)
                    {
                        icon = docs[0].iconUrl;
                        title = docs[0].name || docs[0].type;
                        title = title.charAt(0).toUpperCase() + title.substring(1);
                        
                        if (title.length > 30)
                        {
                            title = title.substring(0, 30) + '...';
                        }
                    }
                    
                    var pt = graph.getFreeInsertPoint();
                    var linkCell = new mxCell(title, new mxGeometry(pt.x, pt.y, 100, 40),
                            'fontColor=#0000EE;fontStyle=4;rounded=1;overflow=hidden;' + ((icon != null) ?
                            'shape=label;imageWidth=16;imageHeight=16;spacingLeft=26;align=left;image=' + icon :
                            'spacing=10;'));
                    linkCell.vertex = true;

                    graph.setLinkForCell(linkCell, link);
                    graph.cellSizeUpdated(linkCell, true);

                    graph.getModel().beginUpdate();
                    try
                    {
                        linkCell = graph.addCell(linkCell);
                        graph.fireEvent(new mxEventObject('cellsInserted', 'cells', [linkCell]));
                    }
                    finally
                    {
                        graph.getModel().endUpdate();
                    }
                    
                    graph.setSelectionCell(linkCell);
                    graph.scrollCellToVisible(graph.getSelectionCell());
                }
            });
        }
    })).isEnabled = isGraphEnabled;
    this.addAction('link...', mxUtils.bind(this, function()
    {
        var graph = ui.editor.graph;
        
        if (graph.isEnabled())
        {
            if (graph.cellEditor.isContentEditing())
            {
                var elt = graph.getSelectedElement();
                var link = graph.getParentByName(elt, 'A', graph.cellEditor.textarea);
                var oldValue = '';
                
                // Workaround for FF returning the outermost selected element after double
                // click on a DOM hierarchy with a link inside (but not as topmost element)
                if (link == null && elt != null && elt.getElementsByTagName != null)
                {
                    // Finds all links in the selected DOM and uses the link
                    // where the selection text matches its text content
                    var links = elt.getElementsByTagName('a');
                    
                    for (var i = 0; i < links.length && link == null; i++)
                    {
                        if (links[i].textContent == elt.textContent)
                        {
                            link = links[i];
                        }
                    }
                }

                if (link != null && link.nodeName == 'A')
                {
                    oldValue = link.getAttribute('href') || '';
                    graph.selectNode(link);
                }
                
                var selState = graph.cellEditor.saveSelection();
                
                ui.showLinkDialog(oldValue, mxResources.get('apply'), mxUtils.bind(this, function(value)
                {
                    graph.cellEditor.restoreSelection(selState);

                    if (value != null)
                    {
                        graph.insertLink(value);
                    }
                }));
            }
            else if (graph.isSelectionEmpty())
            {
                this.get('insertLink').funct();
            }
            else
            {
                this.get('editLink').funct();
            }
        }
    })).isEnabled = isGraphEnabled;
    this.addAction('autosize', function()
    {
        var cells = graph.getSelectionCells();
        
        if (cells != null)
        {
            graph.getModel().beginUpdate();
            try
            {
                for (var i = 0; i < cells.length; i++)
                {
                    var cell = cells[i];
                    
                    if (graph.getModel().getChildCount(cell))
                    {
                        graph.updateGroupBounds([cell], 20);
                    }
                    else
                    {
                        var state = graph.view.getState(cell);
                        var geo = graph.getCellGeometry(cell);

                        if (graph.getModel().isVertex(cell) && state != null && state.text != null &&
                            geo != null && graph.isWrapping(cell))
                        {
                            geo = geo.clone();
                            geo.height = state.text.boundingBox.height / graph.view.scale;
                            graph.getModel().setGeometry(cell, geo);
                        }
                        else
                        {
                            graph.updateCellSize(cell);
                        }
                    }
                }
            }
            finally
            {
                graph.getModel().endUpdate();
            }
        }
    }, null, null, Editor.ctrlKey + '+Shift+Y');
    this.addAction('formattedText', function()
    {
        var state = graph.getView().getState(graph.getSelectionCell());
        
        if (state != null)
        {
            var value = '1';
            graph.stopEditing();
            
            graph.getModel().beginUpdate();
            try
            {
                if (state.style['html'] == '1')
                {
                    value = null;
                    let label = graph.convertValueToString(state.cell);
                    
                    if (mxUtils.getValue(state.style, 'nl2Br', '1') != '0')
                    {
                        // Removes newlines from HTML and converts breaks to newlines
                        // to match the HTML output in plain text
                        label = label.replace(/\n/g, '').replace(/<br\s*.?>/g, '\n');
                    }
                    
                    // Removes HTML tags
                    var temp = document.createElement('div');
                    temp.innerHTML = label;
                    label = mxUtils.extractTextWithWhitespace(temp.childNodes);
                    
                    graph.cellLabelChanged(state.cell, label);
                }
                else
                {
                    // Converts HTML tags to text
                    var label = mxUtils.htmlEntities(graph.convertValueToString(state.cell), false);
                    
                    if (mxUtils.getValue(state.style, 'nl2Br', '1') != '0')
                    {
                        // Converts newlines in plain text to breaks in HTML
                        // to match the plain text output
                        label = label.replace(/\n/g, '<br/>');
                    }
                    
                    graph.cellLabelChanged(state.cell, graph.sanitizeHtml(label));
                }
        
                graph.setCellStyles('html', value);
                ui.fireEvent(new mxEventObject('styleChanged', 'keys', ['html'],
                        'values', [(value != null) ? value : '0'], 'cells',
                        graph.getSelectionCells()));
            }
            finally
            {
                graph.getModel().endUpdate();
            }
        }
    });
    this.addAction('wordWrap', function()
    {
        var state = graph.getView().getState(graph.getSelectionCell());
        var value = 'wrap';
        
        graph.stopEditing();
        
        if (state != null && state.style[mxConstants.STYLE_WHITE_SPACE] == 'wrap')
        {
            value = null;
        }

        graph.setCellStyles(mxConstants.STYLE_WHITE_SPACE, value);
    });
    this.addAction('rotation', function()
    {
        var value = '0';
        var state = graph.getView().getState(graph.getSelectionCell());
        
        if (state != null)
        {
            value = state.style[mxConstants.STYLE_ROTATION] || value;
        }

        var dlg = new FilenameDialog(ui, value, mxResources.get('apply'), function(newValue)
        {
            if (newValue != null && newValue.length > 0)
            {
                graph.setCellStyles(mxConstants.STYLE_ROTATION, newValue);
            }
        }, mxResources.get('enterValue') + ' (0-360)');
        
        ui.showDialog(dlg.container, 375, 80, true, true);
        dlg.init();
    });
    // View actions
    this.addAction('resetView', function()
    {
        graph.zoomTo(1);
        ui.resetScrollbars();
    }, null, null, Editor.ctrlKey + '+H');
    this.addAction('zoomIn', function(evt) { graph.zoomIn(); }, null, null, Editor.ctrlKey + ' + (Numpad) / Alt+Mousewheel');
    this.addAction('zoomOut', function(evt) { graph.zoomOut(); }, null, null, Editor.ctrlKey + ' - (Numpad) / Alt+Mousewheel');
    this.addAction('fitWindow', function ()
    {
        //graph.fit();
        var bounds = (graph.isSelectionEmpty()) ? graph.getGraphBounds() : graph.getBoundingBox(graph.getSelectionCells());
        var t = graph.view.translate;
        var s = graph.view.scale;
        bounds.width /= s;
        bounds.height /= s;
        bounds.x = bounds.x / s - t.x;
        bounds.y = bounds.y / s - t.y;

        var cw = graph.container.clientWidth - 10;
        var ch = graph.container.clientHeight - 10;
        var scale = Math.floor(20 * Math.min(cw / bounds.width, ch / bounds.height)) / 20;
        graph.zoomTo(scale);

        if (mxUtils.hasScrollbars(graph.container))
        {
            graph.container.scrollTop = (bounds.y + t.y) * scale -
                Math.max((ch - bounds.height * scale) / 2 + 5, 0);
            graph.container.scrollLeft = (bounds.x + t.x) * scale -
                Math.max((cw - bounds.width * scale) / 2 + 5, 0);
        }
    }, null, null, Editor.ctrlKey + '+Shift+H');
    this.addAction('fitPage', mxUtils.bind(this, function()
    {
        if (!graph.pageVisible)
        {
            this.get('pageView').funct();
        }
        
        var fmt = graph.pageFormat;
        var ps = graph.pageScale;
        var cw = graph.container.clientWidth - 10;
        var ch = graph.container.clientHeight - 10;
        var scale = Math.floor(20 * Math.min(cw / fmt.width / ps, ch / fmt.height / ps)) / 20;
        graph.zoomTo(scale);
        
        if (mxUtils.hasScrollbars(graph.container))
        {
            var pad = graph.getPagePadding();
            graph.container.scrollTop = pad.y * graph.view.scale - 1;
            graph.container.scrollLeft = Math.min(pad.x * graph.view.scale, (graph.container.scrollWidth - graph.container.clientWidth) / 2) - 1;
        }
    }), null, null, Editor.ctrlKey + '+J');
    this.addAction('fitTwoPages', mxUtils.bind(this, function()
    {
        if (!graph.pageVisible)
        {
            this.get('pageView').funct();
        }
        
        var fmt = graph.pageFormat;
        var ps = graph.pageScale;
        var cw = graph.container.clientWidth - 10;
        var ch = graph.container.clientHeight - 10;
        
        var scale = Math.floor(20 * Math.min(cw / (2 * fmt.width) / ps, ch / fmt.height / ps)) / 20;
        graph.zoomTo(scale);
        
        if (mxUtils.hasScrollbars(graph.container))
        {
            var pad = graph.getPagePadding();
            graph.container.scrollTop = Math.min(pad.y, (graph.container.scrollHeight - graph.container.clientHeight) / 2);
            graph.container.scrollLeft = Math.min(pad.x, (graph.container.scrollWidth - graph.container.clientWidth) / 2);
        }
    }), null, null, Editor.ctrlKey + '+Shift+J');
    this.addAction('fitPageWidth', mxUtils.bind(this, function()
    {
        if (!graph.pageVisible)
        {
            this.get('pageView').funct();
        }
        
        var fmt = graph.pageFormat;
        var ps = graph.pageScale;
        var cw = graph.container.clientWidth - 10;

        var scale = Math.floor(20 * cw / fmt.width / ps) / 20;
        graph.zoomTo(scale);
        
        if (mxUtils.hasScrollbars(graph.container))
        {
            var pad = graph.getPagePadding();
            graph.container.scrollLeft = Math.min(pad.x * graph.view.scale,
                (graph.container.scrollWidth - graph.container.clientWidth) / 2);
        }
    }));
    this.put('customZoom', new Action(mxResources.get('custom') + '...', mxUtils.bind(this, function()
    {
        var dlg = new FilenameDialog(this.editorUi, parseInt(graph.getView().getScale() * 100), mxResources.get('apply'),
            mxUtils.bind(this, function (newValue)
        {
            var val = parseInt(newValue);
            
            if (!isNaN(val) && val > 0)
            {
                graph.zoomTo(val / 100);
            }
        }), mxResources.get('zoom') + ' (%)');
        this.editorUi.showDialog(dlg.container, 300, 80, true, true);
        dlg.init();
    }), null, null, Editor.ctrlKey + '+0'));
    this.addAction('pageScale...', mxUtils.bind(this, function()
    {
        var dlg = new FilenameDialog(this.editorUi, parseInt(graph.pageScale * 100), mxResources.get('apply'),
            mxUtils.bind(this, function (newValue)
        {
            var val = parseInt(newValue);
            if (!isNaN(val) && val > 0)
                ui.setPageScale(val / 100);
        }), mxResources.get('pageScale') + ' (%)');
        this.editorUi.showDialog(dlg.container, 350, 80, true, true);
        dlg.init();
    }));

    // Option actions
    action = this.addAction('grid', function()
    {
        graph.setGridEnabled(!graph.isGridEnabled());
        ui.fireEvent(new mxEventObject('gridEnabledChanged'));
    }, null, null, Editor.ctrlKey + '+Shift+G');
    action.setToggleAction(true);
    action.setSelectedCallback(function() { return graph.isGridEnabled(); });
    action.setEnabled(false);
    
    action = this.addAction('guides', function()
    {
        graph.graphHandler.guidesEnabled = !graph.graphHandler.guidesEnabled;
        ui.fireEvent(new mxEventObject('guidesEnabledChanged'));
    });
    action.setToggleAction(true);
    action.setSelectedCallback(function() { return graph.graphHandler.guidesEnabled; });
    action.setEnabled(false);
    
    action = this.addAction('tooltips', function()
    {
        graph.tooltipHandler.setEnabled(!graph.tooltipHandler.isEnabled());
    });
    action.setToggleAction(true);
    action.setSelectedCallback(function() { return graph.tooltipHandler.isEnabled(); });
    
    action = this.addAction('collapseExpand', function()
    {
        var change = new ChangePageSetup(ui);
        change.ignoreColor = true;
        change.ignoreImage = true;
        change.foldingEnabled = !graph.foldingEnabled;
        
        graph.model.execute(change);
    });
    action.setToggleAction(true);
    action.setSelectedCallback(function() { return graph.foldingEnabled; });
    action.isEnabled = isGraphEnabled;

    action = this.addAction('scrollbars', function ()
    {
        ui.setScrollbars(!ui.hasScrollbars());
    });
    action.setToggleAction(true);
    action.setSelectedCallback(function() { return graph.scrollbars; });

    action = this.addAction('pageView', mxUtils.bind(this, function ()
    {
        ui.setPageVisible(!graph.pageVisible);
    }));
    action.setToggleAction(true);
    action.setSelectedCallback(function() { return graph.pageVisible; });

    action = this.addAction('connectionArrows', function ()
    {
        graph.connectionArrowsEnabled = !graph.connectionArrowsEnabled;
        ui.fireEvent(new mxEventObject('connectionArrowsChanged'));
    }, null, null, 'Alt+Shift+A');
    action.setToggleAction(true);
    action.setSelectedCallback(function() { return graph.connectionArrowsEnabled; });

    action = this.addAction('connectionPoints', function ()
    {
        graph.setConnectable(!graph.connectionHandler.isEnabled());
        ui.fireEvent(new mxEventObject('connectionPointsChanged'));
    }, null, null, 'Alt+Shift+P');
    action.setToggleAction(true);
    action.setSelectedCallback(function() { return graph.connectionHandler.isEnabled(); });

    action = this.addAction('copyConnect', function ()
    {
        graph.connectionHandler.setCreateTarget(!graph.connectionHandler.isCreateTarget());
        ui.fireEvent(new mxEventObject('copyConnectChanged'));
    });
    action.setToggleAction(true);
    action.setSelectedCallback(function() { return graph.connectionHandler.isCreateTarget(); });
    action.isEnabled = isGraphEnabled;

    action = this.addAction('autosave', function ()
    {
        ui.editor.setAutosave(!ui.editor.autosave);
    });
    action.setToggleAction(false);
    action.setSelectedCallback(function() { return ui.editor.autosave; });
    //action.isEnabled = isGraphEnabled;
    action.setEnabled(false);
    action.visible = true;
            
    // Font style actions
    var toggleFontStyle = mxUtils.bind(this, function(key, style, fn, shortcut)
    {
        return this.addAction(key, function()
        {
            if (fn != null && graph.cellEditor.isContentEditing())
            {
                fn();
            }
            else
            {
                graph.stopEditing(false);
                
                graph.getModel().beginUpdate();
                try
                {
                    graph.toggleCellStyleFlags(mxConstants.STYLE_FONTSTYLE, style);
                    
                    // Removes bold and italic tags and CSS styles inside labels
                    if ((style & mxConstants.FONT_BOLD) == mxConstants.FONT_BOLD)
                    {
                        graph.updateLabelElements(graph.getSelectionCells(), function(elt)
                        {
                            elt.style.fontWeight = null;
                            
                            if (elt.nodeName == 'B')
                            {
                                graph.replaceElement(elt);
                            }
                        });
                    }
                    else if ((style & mxConstants.FONT_ITALIC) == mxConstants.FONT_ITALIC)
                    {
                        graph.updateLabelElements(graph.getSelectionCells(), function(elt)
                        {
                            elt.style.fontStyle = null;
                            
                            if (elt.nodeName == 'I')
                            {
                                graph.replaceElement(elt);
                            }
                        });
                    }
                    else if ((style & mxConstants.FONT_UNDERLINE) == mxConstants.FONT_UNDERLINE)
                    {
                        graph.updateLabelElements(graph.getSelectionCells(), function(elt)
                        {
                            elt.style.textDecoration = null;
                            
                            if (elt.nodeName == 'U')
                            {
                                graph.replaceElement(elt);
                            }
                        });
                    }
                }
                finally
                {
                    graph.getModel().endUpdate();
                }
            }
        }, null, null, shortcut);
    });
    
    toggleFontStyle('bold', mxConstants.FONT_BOLD, function() { document.execCommand('bold', false, null); }, Editor.ctrlKey + '+B');
    toggleFontStyle('italic', mxConstants.FONT_ITALIC, function() { document.execCommand('italic', false, null); }, Editor.ctrlKey + '+I');
    toggleFontStyle('underline', mxConstants.FONT_UNDERLINE, function() { document.execCommand('underline', false, null); }, Editor.ctrlKey + '+U');
    
    // Color actions
    this.addAction('fontColor...', function() { ui.menus.pickColor(mxConstants.STYLE_FONTCOLOR, 'forecolor', '000000'); });
    this.addAction('strokeColor...', function() { ui.menus.pickColor(mxConstants.STYLE_STROKECOLOR); });
    this.addAction('fillColor...', function() { ui.menus.pickColor(mxConstants.STYLE_FILLCOLOR); });
    this.addAction('gradientColor...', function() { ui.menus.pickColor(mxConstants.STYLE_GRADIENTCOLOR); });
    this.addAction('backgroundColor...', function() { ui.menus.pickColor(mxConstants.STYLE_LABEL_BACKGROUNDCOLOR, 'backcolor'); });
    this.addAction('borderColor...', function() { ui.menus.pickColor(mxConstants.STYLE_LABEL_BORDERCOLOR); });
    
    // Format actions
    this.addAction('vertical', function() { ui.menus.toggleStyle(mxConstants.STYLE_HORIZONTAL, true); });
    this.addAction('shadow', function() { ui.menus.toggleStyle(mxConstants.STYLE_SHADOW); });
    this.addAction('solid', function()
    {
        graph.getModel().beginUpdate();
        try
        {
            graph.setCellStyles(mxConstants.STYLE_DASHED, null);
            graph.setCellStyles(mxConstants.STYLE_DASH_PATTERN, null);
            ui.fireEvent(new mxEventObject('styleChanged', 'keys', [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN],
                'values', [null, null], 'cells', graph.getSelectionCells()));
        }
        finally
        {
            graph.getModel().endUpdate();
        }
    });
    this.addAction('dashed', function()
    {
        graph.getModel().beginUpdate();
        try
        {
            graph.setCellStyles(mxConstants.STYLE_DASHED, '1');
            graph.setCellStyles(mxConstants.STYLE_DASH_PATTERN, null);
            ui.fireEvent(new mxEventObject('styleChanged', 'keys', [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN],
                'values', ['1', null], 'cells', graph.getSelectionCells()));
        }
        finally
        {
            graph.getModel().endUpdate();
        }
    });
    this.addAction('dotted', function()
    {
        graph.getModel().beginUpdate();
        try
        {
            graph.setCellStyles(mxConstants.STYLE_DASHED, '1');
            graph.setCellStyles(mxConstants.STYLE_DASH_PATTERN, '1 4');
            ui.fireEvent(new mxEventObject('styleChanged', 'keys', [mxConstants.STYLE_DASHED, mxConstants.STYLE_DASH_PATTERN],
                'values', ['1', '1 4'], 'cells', graph.getSelectionCells()));
        }
        finally
        {
            graph.getModel().endUpdate();
        }
    });
    this.addAction('sharp', function()
    {
        graph.getModel().beginUpdate();
        try
        {
            graph.setCellStyles(mxConstants.STYLE_ROUNDED, '0');
            graph.setCellStyles(mxConstants.STYLE_CURVED, '0');
            ui.fireEvent(new mxEventObject('styleChanged', 'keys', [mxConstants.STYLE_ROUNDED, mxConstants.STYLE_CURVED],
                    'values', ['0', '0'], 'cells', graph.getSelectionCells()));
        }
        finally
        {
            graph.getModel().endUpdate();
        }
    });
    this.addAction('rounded', function()
    {
        graph.getModel().beginUpdate();
        try
        {
            graph.setCellStyles(mxConstants.STYLE_ROUNDED, '1');
            graph.setCellStyles(mxConstants.STYLE_CURVED, '0');
            ui.fireEvent(new mxEventObject('styleChanged', 'keys', [mxConstants.STYLE_ROUNDED, mxConstants.STYLE_CURVED],
                    'values', ['1', '0'], 'cells', graph.getSelectionCells()));
        }
        finally
        {
            graph.getModel().endUpdate();
        }
    });
    this.addAction('toggleRounded', function()
    {
        if (!graph.isSelectionEmpty() && graph.isEnabled())
        {
            graph.getModel().beginUpdate();
            try
            {
                var cells = graph.getSelectionCells();
                var state = graph.view.getState(cells[0]);
                var style = (state != null) ? state.style : graph.getCellStyle(cells[0]);
                var value = (mxUtils.getValue(style, mxConstants.STYLE_ROUNDED, '0') == '1') ? '0' : '1';
                
                graph.setCellStyles(mxConstants.STYLE_ROUNDED, value);
                graph.setCellStyles(mxConstants.STYLE_CURVED, null);
                ui.fireEvent(new mxEventObject('styleChanged', 'keys', [mxConstants.STYLE_ROUNDED, mxConstants.STYLE_CURVED],
                        'values', [value, '0'], 'cells', graph.getSelectionCells()));
            }
            finally
            {
                graph.getModel().endUpdate();
            }
        }
    });
    this.addAction('curved', function()
    {
        graph.getModel().beginUpdate();
        try
        {
            graph.setCellStyles(mxConstants.STYLE_ROUNDED, '0');
            graph.setCellStyles(mxConstants.STYLE_CURVED, '1');
            ui.fireEvent(new mxEventObject('styleChanged', 'keys', [mxConstants.STYLE_ROUNDED, mxConstants.STYLE_CURVED],
                    'values', ['0', '1'], 'cells', graph.getSelectionCells()));
        }
        finally
        {
            graph.getModel().endUpdate();
        }
    });
    this.addAction('collapsible', function()
    {
        var state = graph.view.getState(graph.getSelectionCell());
        var value = '1';
        
        if (state != null && graph.getFoldingImage(state) != null)
        {
            value = '0';	
        }
        
        graph.setCellStyles('collapsible', value);
        ui.fireEvent(new mxEventObject('styleChanged', 'keys', ['collapsible'],
                'values', [value], 'cells', graph.getSelectionCells()));
    });
    this.addAction('editStyle...', mxUtils.bind(this, function()
    {
        var cells = graph.getSelectionCells();
        
        if (cells != null && cells.length > 0)
        {
            var model = graph.getModel();
            
            var dlg = new TextareaDialog(this.editorUi, mxResources.get('editStyle') + ':',
                model.getStyle(cells[0]) || '', function(newValue)
            {
                if (newValue != null)
                {
                    graph.setCellStyle(mxUtils.trim(newValue), cells);
                }
            }, null, null, 400, 220);
            this.editorUi.showDialog(dlg.container, 420, 300, true, true);
            dlg.init();
        }
    }), null, null, Editor.ctrlKey + '+E');
    this.addAction('setAsDefaultStyle', function()
    {
        if (graph.isEnabled() && !graph.isSelectionEmpty())
        {
            ui.setDefaultStyle(graph.getSelectionCell());
        }
    }, null, null, Editor.ctrlKey + '+Shift+D');
    this.addAction('clearDefaultStyle', function()
    {
        if (graph.isEnabled())
        {
            ui.clearDefaultStyle();
        }
    }, null, null, Editor.ctrlKey + '+Shift+R');
    this.addAction('addWaypoint', function()
    {
        var cell = graph.getSelectionCell();
        
        if (cell != null && graph.getModel().isEdge(cell))
        {
            var handler = editor.graph.selectionCellsHandler.getHandler(cell);
            
            if (handler instanceof mxEdgeHandler)
            {
                var t = graph.view.translate;
                var s = graph.view.scale;
                var dx = t.x;
                var dy = t.y;
                
                var parent = graph.getModel().getParent(cell);
                var pgeo = graph.getCellGeometry(parent);
                
                while (graph.getModel().isVertex(parent) && pgeo != null)
                {
                    dx += pgeo.x;
                    dy += pgeo.y;
                    
                    parent = graph.getModel().getParent(parent);
                    pgeo = graph.getCellGeometry(parent);
                }
                
                var x = Math.round(graph.snap(graph.popupMenuHandler.triggerX / s - dx));
                var y = Math.round(graph.snap(graph.popupMenuHandler.triggerY / s - dy));
                
                handler.addPointAt(handler.state, x, y);
            }
        }
    });
    this.addAction('removeWaypoint', function()
    {
        // TODO: Action should run with "this" set to action
        var rmWaypointAction = ui.actions.get('removeWaypoint');
        if (rmWaypointAction.handler != null)
        {
            // NOTE: Popupevent handled and action updated in Menus.createPopupMenu
            rmWaypointAction.handler.removePoint(rmWaypointAction.handler.state, rmWaypointAction.index);
        }
    });
    this.addAction('clearWaypoints', function()
    {
        var cells = graph.getSelectionCells();
        
        if (cells != null)
        {
            cells = graph.addAllEdges(cells);
            
            graph.getModel().beginUpdate();
            try
            {
                for (var i = 0; i < cells.length; i++)
                {
                    var cell = cells[i];
                    
                    if (graph.getModel().isEdge(cell))
                    {
                        var geo = graph.getCellGeometry(cell);
            
                        if (geo != null)
                        {
                            geo = geo.clone();
                            geo.points = null;
                            graph.getModel().setGeometry(cell, geo);
                        }
                    }
                }
            }
            finally
            {
                graph.getModel().endUpdate();
            }
        }
    }, null, null, 'Alt+Shift+C');

    action = this.addAction('subscript', mxUtils.bind(this, function()
    {
        if (graph.cellEditor.isContentEditing())
        {
            document.execCommand('subscript', false, null);
        }
    }), null, null, Editor.ctrlKey + '+,');
    action = this.addAction('superscript', mxUtils.bind(this, function()
    {
        if (graph.cellEditor.isContentEditing())
        {
            document.execCommand('superscript', false, null);
        }
    }), null, null, Editor.ctrlKey + '+.');

    this.addAction('image...', function()
    {
        if (graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent()))
        {
            var title = mxResources.get('image') + ' (' + mxResources.get('url') + '):';
            var state = graph.getView().getState(graph.getSelectionCell());
            var value = '';
            
            if (state != null)
            {
                value = state.style[mxConstants.STYLE_IMAGE] || value;
            }
            
            var selectionState = graph.cellEditor.saveSelection();
            
            ui.showImageDialog(title, value, function(newValue, w, h)
            {
                // Inserts image into HTML text
                if (graph.cellEditor.isContentEditing())
                {
                    graph.cellEditor.restoreSelection(selectionState);
                    graph.insertImage(newValue, w, h);
                }
                else
                {
                    var cells = graph.getSelectionCells();
                    
                    if (newValue != null && (newValue.length > 0 || cells.length > 0))
                    {
                        var select = null;
                        
                        graph.getModel().beginUpdate();
                        try
                        {
                            // Inserts new cell if no cell is selected
                            if (cells.length == 0)
                            {
                                var pt = graph.getFreeInsertPoint();
                                cells = [graph.insertVertex(graph.getDefaultParent(), null, '', pt.x, pt.y, w, h,
                                        'shape=image;imageAspect=0;aspect=fixed;verticalLabelPosition=bottom;verticalAlign=top;')];
                                select = cells;
                                    graph.fireEvent(new mxEventObject('cellsInserted', 'cells', select));
                            }
                            
                            graph.setCellStyles(mxConstants.STYLE_IMAGE, (newValue.length > 0) ? newValue : null, cells);
                            
                            // Sets shape only if not already shape with image (label or image)
                            var state = graph.view.getState(cells[0]);
                            var style = (state != null) ? state.style : graph.getCellStyle(cells[0]);
                            
                            if (style[mxConstants.STYLE_SHAPE] != 'image' && style[mxConstants.STYLE_SHAPE] != 'label')
                            {
                                graph.setCellStyles(mxConstants.STYLE_SHAPE, 'image', cells);
                            }
                            else if (newValue.length == 0)
                            {
                                graph.setCellStyles(mxConstants.STYLE_SHAPE, null, cells);
                            }
                            
                            if (graph.getSelectionCount() == 1)
                            {
                                if (w != null && h != null)
                                {
                                    var cell = cells[0];
                                    var geo = graph.getModel().getGeometry(cell);
                                    
                                    if (geo != null)
                                    {
                                        geo = geo.clone();
                                        geo.width = w;
                                        geo.height = h;
                                        graph.getModel().setGeometry(cell, geo);
                                    }
                                }
                            }
                        }
                        finally
                        {
                            graph.getModel().endUpdate();
                        }
                        
                        if (select != null)
                        {
                            graph.setSelectionCells(select);
                            graph.scrollCellToVisible(select[0]);
                        }
                    }
                }
            }, graph.cellEditor.isContentEditing(), !graph.cellEditor.isContentEditing());
        }
    }).isEnabled = isGraphEnabled;

    action = this.addAction('layers', mxUtils.bind(this, function()
    {
        if (this.layersWindow == null)
        {
            // LATER: Check outline window for initial placement
            this.layersWindow = new LayersWindow(ui, document.body.offsetWidth - 280, 120, 220, 180);
            this.layersWindow.window.addListener('show', function()
            {
                ui.fireEvent(new mxEventObject('layers'));
            });
            this.layersWindow.window.addListener('hide', function()
            {
                ui.fireEvent(new mxEventObject('layers'));
            });
            this.layersWindow.window.setVisible(true);
            ui.fireEvent(new mxEventObject('layers'));
        }
        else
        {
            this.layersWindow.window.setVisible(!this.layersWindow.window.isVisible());
        }
    }), null, null, Editor.ctrlKey + '+Shift+L');
    action.setToggleAction(true);
    action.setSelectedCallback(mxUtils.bind(this, function() { return this.layersWindow != null && this.layersWindow.window.isVisible(); }));

    // count header height for windows yOffset
    let point = {
        x: 5,
        get y(){
                try {
                    var tmp = 0; 
                    tmp += ui.demobarContainer.$height || 0;
                    tmp += ui.menubarHeight;
                    tmp += ui.toolbarHeight;
        
                    return tmp;
                } catch (error) {
                    return 150;
                }
            }
    }
    
    action = new Action(mxResources.get('sidebarPanel'), mxUtils.bind(this, function ()
    {
        if (!this.sidebarWindow)
            this.sidebarWindow = new SidebarWindow(ui, point, 170, graph.container.clientHeight - 5);
        else
            this.sidebarWindow.window.setVisible(!this.sidebarWindow.window.isVisible());
    }), null, null, null);
    action.setToggleAction(true);
    action.setSelectedCallback(mxUtils.bind(this, function () { return this.sidebarWindow != null && this.sidebarWindow.window.isVisible(); }));
    this.put('sidebarPanel', action);

    action = this.addAction('formatPanel', mxUtils.bind(this, function ()
    {
        point.x = graph.container.clientWidth - 355;
        if (!this.formatWindow)
            this.formatWindow = new FormatWindow(ui, point, 350, graph.container.clientHeight - 5);
        else
            this.formatWindow.window.setVisible(!this.formatWindow.window.isVisible());

    }), null, null, Editor.ctrlKey + '+Shift+P');
    action.setToggleAction(true);
    action.setSelectedCallback(mxUtils.bind(this, function () { return this.formatWindow != null && this.formatWindow.window.isVisible(); }));

    action = this.addAction('outline', mxUtils.bind(this, function()
    {
        if (this.outlineWindow == null)
        {
            // LATER: Check layers window for initial placement
            this.outlineWindow = new OutlineWindow(ui, document.body.offsetWidth - 260, 100, 160, 160);
            this.outlineWindow.window.addListener('show', function()
            {
                ui.fireEvent(new mxEventObject('outline'));
            });
            this.outlineWindow.window.addListener('hide', function()
            {
                ui.fireEvent(new mxEventObject('outline'));
            });
            this.outlineWindow.window.setVisible(true);
            ui.fireEvent(new mxEventObject('outline'));
        }
        else
        {
            this.outlineWindow.window.setVisible(!this.outlineWindow.window.isVisible());
        }
    }), null, null, Editor.ctrlKey + '+Shift+O');
    action.setToggleAction(true);
    action.setSelectedCallback(mxUtils.bind(this, function () { return this.outlineWindow != null && this.outlineWindow.window.isVisible(); }));

    action = this.addAction('bindings', mxUtils.bind(this, function ()
    {
        if (this.bindingsWindow == null)
        {
            var modal = true;
// @if !LINKMT
            modal = false;
// @endif
            this.bindingsWindow = new BindingsWindow(ui, modal, 800, 500);
            this.bindingsWindow.toggle = mxUtils.bind(this.bindingsWindow, function ()
            {
                if (!this.isVisible())
                    this.show();
                else
                    this.hide();
            });
        }
        this.bindingsWindow.toggle();

    }), null, null, Editor.ctrlKey + '+Shift+X');
    action.setToggleAction(true);
    action.setSelectedCallback(mxUtils.bind(this, function () { return this.bindingsWindow != null && this.bindingsWindow.isVisible(); }));
};

/**
 * Registers the given action under the given name.
 */
Actions.prototype.addAction = function(key, funct, enabled, iconCls, shortcut)
{
    var title;
    
    if (key.substring(key.length - 3) == '...')
    {
        key = key.substring(0, key.length - 3);
        title = mxResources.get(key) + '...';
    }
    else
    {
        title = mxResources.get(key);
    }
    
    return this.put(key, new Action(title, funct, enabled, iconCls, shortcut));
};

/**
 * Registers the given action under the given name.
 */
Actions.prototype.put = function(name, action)
{
    this.actions[name] = action; 
    return action;
};

/**
 * Returns the action for the given name or null if no such action exists.
 */
Actions.prototype.get = function(name)
{
    return this.actions[name];
};

/**
 * Constructs a new action for the given parameters.
 */
function Action(label, funct, enabled, iconCls, shortcut)
{
    mxEventSource.call(this);
    this.label = label;
    this.funct = this.createFunction(funct);
    this.enabled = (enabled != null) ? enabled : true;
    this.iconCls = iconCls;
    this.shortcut = shortcut;
    this.visible = true;
}

// Action inherits from mxEventSource
mxUtils.extend(Action, mxEventSource);

/**
 * Sets the enabled state of the action and fires a stateChanged event.
 */
Action.prototype.createFunction = function(funct)
{
    return funct;
};

/**
 * Sets the enabled state of the action and fires a stateChanged event.
 */
Action.prototype.setEnabled = function(value)
{
    if (this.enabled != value)
    {
        this.enabled = value;
        this.fireEvent(new mxEventObject('stateChanged'));
    }
};

/**
 * Sets the enabled state of the action and fires a stateChanged event.
 */
Action.prototype.isEnabled = function()
{
    return this.enabled;
};

/**
 * Sets the enabled state of the action and fires a stateChanged event.
 */
Action.prototype.setToggleAction = function(value)
{
    this.toggleAction = value;
};

/**
 * Sets the enabled state of the action and fires a stateChanged event.
 */
Action.prototype.setSelectedCallback = function(funct)
{
    this.selectedCallback = funct;
};

/**
 * Sets the enabled state of the action and fires a stateChanged event.
 */
Action.prototype.isSelected = function()
{
    return this.selectedCallback();
};

//EditorUI.js

// import * as mxgraph from 'mxgraph';
// import { Base64 } from 'js-base64';
// import { API } from './scada'
// import { HELP, isNullOrEmpty, AJAX } from './client'
// import Editor, { ErrorDialog, OpenFile, Dialog } from './Editor'
// import Graph, { HoverIcons } from './Graph'
// import Actions from './Actions'
// import ViewModeHandler from './ViewMode'
// import { ColorDialog, OpenDialog, FilenameDialog, LinkDialog, EditDataDialog } from './Dialogs'
// import Menus from './Menus'
// import MarksService from './MarksService'
// import BindingsHandler from './Bindings'
// import Toolbar from './Toolbar';
// import * as webix from 'webix/webix.js';
// import $ from "jquery";
// let { 
//   mxGraphModel, 
//   mxClient, 
//   mxUtils, 
//   mxResources, 
//   mxRectangle,
//   mxConstants,
//   mxImage,
//   mxEvent,
//   mxPoint,
//   mxPopupMenu,
//   mxStackLayout,
//   mxEventObject,
//   mxCodec,
//   mxEventSource,
//   mxClipboard,
//   mxObjectCodec,
//   mxCodecRegistry,
//   mxMorphing,
//   mxKeyHandler,
// } = mxgraph();

/**
 * Constructs a new graph editor
 */

 //export default function EditorUi (editor, container, scheme) {

 function EditorUi (editor, container, scheme) {
    mxEventSource.call(this);
    
    this.destroyFunctions = [];
    
    this.scheme = scheme;
    this.container = container || document.body;
    this.editor = editor || new Editor();
    this.dialogs = [];
    
    var graph = this.editor.graph;
 
   // Faster scrollwheel zoom is possible with CSS transforms
   if (graph.useCssTransforms) this.lazyZoomDelay = 0;
 
   // Pre-fetches submenu image or replaces with embedded image if supported
   mxPopupMenu.prototype.submenuImage = 'data:image/gif;base64,R0lGODlhCQAJAIAAAP///zMzMyH5BAEAAAAALAAAAAAJAAkAAAIPhI8WebHsHopSOVgb26AAADs=';
 
   // Creates the user interface
   this.actions = new Actions(this);
   this.menus = this.createMenus();
  // this.menus = new Menus(this)
  
   this.createDivs();
   this.createUi();
   this.refresh();
 
   // Disables HTML and text selection
   var textEditing = mxUtils.bind(this, function (evt) {
     if (evt == null) evt = window.event;
     return graph.isEditing() || (evt != null && this.isSelectionAllowed(evt));
   });
 
   // Disables text selection while not editing and no dialog visible
   if (this.container == document.body) {
     this.menubarContainer.onselectstart = textEditing;
     this.menubarContainer.onmousedown = textEditing;
     this.toolbarContainer.onselectstart = textEditing;
     this.toolbarContainer.onmousedown = textEditing;
     this.diagramContainer.onselectstart = textEditing;
     this.diagramContainer.onmousedown = textEditing;
     //this.sidebarContainer.onselectstart = textEditing;
     //this.sidebarContainer.onmousedown = textEditing;
     //this.formatContainer.onselectstart = textEditing;
     //this.formatContainer.onmousedown = textEditing;
     //this.footerContainer.onselectstart = textEditing;
     //this.footerContainer.onmousedown = textEditing;
   }
 
   // And uses built-in context menu while editing
   if (!this.editor.isViewMode()) {
     // Allows context menu for links in hints
     var linkHandler = function (evt) {
       if (evt != null) {
         var source = mxEvent.getSource(evt);
         if (source.nodeName == 'A') {
           while (source != null) {
             if (source.className == 'geHint') return true;
             source = source.parentNode;
           }
         }
       }
       return textEditing(evt);
     };
 
     if (mxClient.IS_IE && (typeof document.documentMode === 'undefined' || document.documentMode < 9)) mxEvent.addListener(this.diagramContainer, 'contextmenu', linkHandler);
     else {
       // Allows browser context menu outside of diagram and sidebar
       this.diagramContainer.oncontextmenu = linkHandler;
     }
   }
 
   // Contains the main graph instance inside the given panel
   graph.init(this.diagramContainer);
 
   // Improves line wrapping for in-place editor
   if (graph.view.getDrawPane() != null) {
     var root = graph.view.getDrawPane().ownerSVGElement;
     if (root) root.style.position = 'absolute';
   }
 
   // Creates hover icons
   this.hoverIcons = this.createHoverIcons();
 
   // Adds tooltip when mouse is over scrollbars to show space-drag panning option
   mxEvent.addListener(
     this.diagramContainer,
     'mousemove',
     mxUtils.bind(this, function (evt) {
       var off = mxUtils.getOffset(this.diagramContainer);
 
       if (mxEvent.getClientX(evt) - off.x - this.diagramContainer.clientWidth > 0 || mxEvent.getClientY(evt) - off.y - this.diagramContainer.clientHeight > 0) {
         this.diagramContainer.setAttribute('title', mxResources.get('panTooltip'));
       } else {
         this.diagramContainer.removeAttribute('title');
       }
     })
   );
 
   // Escape key hides dialogs, adds space+drag panning
   var spaceKeyPressed = false;
 
   // Overrides hovericons to disable while space key is pressed
   var hoverIconsIsResetEvent = this.hoverIcons.isResetEvent;
   this.hoverIcons.isResetEvent = function (evt, allowShift) {
     return spaceKeyPressed || hoverIconsIsResetEvent.apply(this, arguments);
   };
 
   this.keydownHandler = mxUtils.bind(this, function (evt) {
     if (evt.which == 32 /* Space */ && !graph.isEditing()) {
       spaceKeyPressed = true;
       this.hoverIcons.reset();
       graph.container.style.cursor = 'move';
 
       // Disables scroll after space keystroke with scrollbars
       if (!graph.isEditing() && mxEvent.getSource(evt) == graph.container) {
         mxEvent.consume(evt);
       }
     } else if (!mxEvent.isConsumed(evt) && evt.keyCode == 27 /* Escape */) {
       this.hideDialog(null, true);
     }
   });
   mxEvent.addListener(document, 'keydown', this.keydownHandler);
 
   this.keyupHandler = mxUtils.bind(this, function (evt) {
     graph.container.style.cursor = '';
     spaceKeyPressed = false;
   });
   mxEvent.addListener(document, 'keyup', this.keyupHandler);
 
   // Forces panning for middle and right mouse buttons
   var panningHandlerIsForcePanningEvent = graph.panningHandler.isForcePanningEvent;
   graph.panningHandler.isForcePanningEvent = function (me) {
     // Ctrl+left button is reported as right button in FF on Mac
     return panningHandlerIsForcePanningEvent.apply(this, arguments) || spaceKeyPressed || (mxEvent.isMouseEvent(me.getEvent()) && (this.usePopupTrigger || !mxEvent.isPopupTrigger(me.getEvent())) && ((!mxEvent.isControlDown(me.getEvent()) && mxEvent.isRightMouseButton(me.getEvent())) || mxEvent.isMiddleMouseButton(me.getEvent())));
   };
 
   // Ctrl/Cmd+Enter applies editing value except in Safari where Ctrl+Enter creates
   // a new line (while Enter creates a new paragraph and Shift+Enter stops)
   var cellEditorIsStopEditingEvent = graph.cellEditor.isStopEditingEvent;
   graph.cellEditor.isStopEditingEvent = function (evt) {
     return cellEditorIsStopEditingEvent.apply(this, arguments) || (evt.keyCode == 13 && ((!mxClient.IS_SF && mxEvent.isControlDown(evt)) || (mxClient.IS_MAC && mxEvent.isMetaDown(evt)) || (mxClient.IS_SF && mxEvent.isShiftDown(evt))));
   };
 
   // Switches toolbar for text editing
   var textMode = false;
   var fontMenu = null;
   var sizeMenu = null;
   var nodes = null;
 
   var updateToolbar = mxUtils.bind(this, function () {
     if (this.toolbar != null && textMode != graph.cellEditor.isContentEditing()) {
       var node = this.toolbar.container.firstChild;
       var newNodes = [];
 
       while (node != null) {
         var tmp = node.nextSibling;
 
         if (mxUtils.indexOf(this.toolbar.staticElements, node) < 0) {
           node.parentNode.removeChild(node);
           newNodes.push(node);
         }
 
         node = tmp;
       }
 
       // Saves references to special items
       var tmp1 = this.toolbar.fontMenu;
       var tmp2 = this.toolbar.sizeMenu;
 
       if (nodes == null) {
         this.toolbar.createTextToolbar();
       } else {
         for (var i = 0; i < nodes.length; i++) {
           this.toolbar.container.appendChild(nodes[i]);
         }
 
         // Restores references to special items
         this.toolbar.fontMenu = fontMenu;
         this.toolbar.sizeMenu = sizeMenu;
       }
 
       textMode = graph.cellEditor.isContentEditing();
       fontMenu = tmp1;
       sizeMenu = tmp2;
       nodes = newNodes;
     }
   });
 
   var ui = this;
 
   // Overrides cell editor to update toolbar
   var cellEditorStartEditing = graph.cellEditor.startEditing;
   graph.cellEditor.startEditing = function () {
     cellEditorStartEditing.apply(this, arguments);
     updateToolbar();
 
     if (graph.cellEditor.isContentEditing()) {
       var updating = false;
 
       var updateCssHandler = function () {
         if (!updating) {
           updating = true;
 
           window.setTimeout(function () {
             var selectedElement = graph.getSelectedElement();
             var node = selectedElement;
 
             while (node != null && node.nodeType != mxConstants.NODETYPE_ELEMENT) {
               node = node.parentNode;
             }
 
             if (node != null) {
               var css = mxUtils.getCurrentStyle(node);
 
               if (css != null && ui.toolbar != null) {
                 // Strips leading and trailing quotes
                 var ff = css.fontFamily;
 
                 if (ff.charAt(0) == "'") {
                   ff = ff.substring(1);
                 }
 
                 if (ff.charAt(ff.length - 1) == "'") {
                   ff = ff.substring(0, ff.length - 1);
                 }
 
                 ui.toolbar.setFontName(ff);
                 ui.toolbar.setFontSize(parseInt(css.fontSize));
               }
             }
 
             updating = false;
           }, 0);
         }
       };
 
       mxEvent.addListener(graph.cellEditor.textarea, 'input', updateCssHandler);
       mxEvent.addListener(graph.cellEditor.textarea, 'touchend', updateCssHandler);
       mxEvent.addListener(graph.cellEditor.textarea, 'mouseup', updateCssHandler);
       mxEvent.addListener(graph.cellEditor.textarea, 'keyup', updateCssHandler);
       updateCssHandler();
     }
   };
 
   var cellEditorStopEditing = graph.cellEditor.stopEditing;
   graph.cellEditor.stopEditing = function (cell, trigger) {
     cellEditorStopEditing.apply(this, arguments);
     updateToolbar();
   };
 
   // Enables scrollbars and sets cursor style for the container
   graph.container.setAttribute('tabindex', '0');
   graph.container.style.cursor = 'default';
   graph.container.focus();
 
   // Keeps graph container focused on mouse down
   var graphFireMouseEvent = graph.fireMouseEvent;
   graph.fireMouseEvent = function (evtName, me, sender) {
     if (evtName == mxEvent.MOUSE_DOWN) {
       this.container.focus();
     }
 
     graphFireMouseEvent.apply(this, arguments);
   };
 
   // Configures automatic expand on mouseover
   graph.popupMenuHandler.autoExpand = true;
 
   // Installs context menu
   if (this.menus) {
     graph.popupMenuHandler.factoryMethod = mxUtils.bind(this, function (menu, cell, evt) {
       this.menus.createPopupMenu(menu, cell, evt);
     });
   }
 
   // Hides context menu
   mxEvent.addGestureListeners(
     document,
     mxUtils.bind(this, function (evt) {
       graph.popupMenuHandler.hideMenu();
     })
   );
 
   // Create handler for key events
   this.keyHandler = this.createKeyHandler(editor);
   // Getter for key handler
   this.getKeyHandler = function () {
     //---fix---//
     return this.keyHandler;
     //return keyHandler;
     //---fix---//
    
   };
 
   // Stores the current style and assigns it to new cells
   var styles = ['rounded', 'shadow', 'dashed', 'dashPattern', 'labelBackgroundColor'];
   var connectStyles = ['shape', 'edgeStyle', 'curved', 'rounded', 'elbow', 'jumpStyle', 'jumpSize'];
 
   // Note: Everything that is not in styles is ignored (styles is augmented below)
   this.setDefaultStyle = function (cell) {
     try {
       var state = graph.view.getState(cell);
 
       if (state != null) {
         // Ignores default styles
         var clone = cell.clone();
         clone.style = '';
         var defaultStyle = graph.getCellStyle(clone);
         var values = [];
         var keys = [];
 
         for (var key in state.style) {
           if (defaultStyle[key] != state.style[key]) {
             values.push(state.style[key]);
             keys.push(key);
           }
         }
 
         // Handles special case for value "none"
         var cellStyle = graph.getModel().getStyle(state.cell);
         var tokens = cellStyle != null ? cellStyle.split(';') : [];
 
         for (var i = 0; i < tokens.length; i++) {
           var tmp = tokens[i];
           var pos = tmp.indexOf('=');
 
           if (pos >= 0) {
             var key = tmp.substring(0, pos);
             var value = tmp.substring(pos + 1);
 
             if (defaultStyle[key] != null && value == 'none') {
               values.push(value);
               keys.push(key);
             }
           }
         }
 
         // Resets current style
         if (graph.getModel().isEdge(state.cell)) {
           graph.currentEdgeStyle = {};
         } else {
           graph.currentVertexStyle = {};
         }
 
         this.fireEvent(new mxEventObject('styleChanged', 'keys', keys, 'values', values, 'cells', [state.cell]));
       }
     } catch (e) {
       this.handleError(e);
     }
   };
   this.clearDefaultStyle = function () {
     graph.currentEdgeStyle = mxUtils.clone(graph.defaultEdgeStyle);
     graph.currentVertexStyle = mxUtils.clone(graph.defaultVertexStyle);
     // Updates UI
     this.fireEvent(new mxEventObject('styleChanged', 'keys', [], 'values', [], 'cells', []));
   };
 
   // Keys that should be ignored if the cell has a value (known: new default for all cells is html=1 so
   // for the html key this effecticely only works for edges inserted via the connection handler)
   var valueStyles = ['fontFamily', 'fontSize', 'fontColor'];
 
   // Keys that always update the current edge style regardless of selection
   var alwaysEdgeStyles = ['edgeStyle', 'startArrow', 'startFill', 'startSize', 'endArrow', 'endFill', 'endSize'];
 
   // Keys that are ignored together (if one appears all are ignored)
   var keyGroups = [['startArrow', 'startFill', 'startSize', 'sourcePerimeterSpacing', 'endArrow', 'endFill', 'endSize', 'targetPerimeterSpacing'], ['strokeColor', 'strokeWidth'], ['fillColor', 'gradientColor'], valueStyles, ['opacity'], ['align'], ['html']];
 
   // Adds all keys used above to the styles array
   for (var i = 0; i < keyGroups.length; i++) {
     for (var j = 0; j < keyGroups[i].length; j++) {
       styles.push(keyGroups[i][j]);
     }
   }
 
   for (var i = 0; i < connectStyles.length; i++) {
     if (mxUtils.indexOf(styles, connectStyles[i]) < 0) {
       styles.push(connectStyles[i]);
     }
   }
 
   // Implements a global current style for edges and vertices that is applied to new cells
   var insertHandler = function (cells, asText) {
     var model = graph.getModel();
 
     model.beginUpdate();
     try {
       // Converts the value to an XML node
       var convertToNode = function (cell) {
         if (cell) {
           //delete model.cells[cell.getId()];
           //cell.setId(model.nextId);
           //model.cells[cell.getId()] = cell;
 
           var cellValue = model.getValue(cell);
           if (!mxUtils.isNode(cellValue)) {
             var doc = mxUtils.createXmlDocument();
             var shape = cell.isVertex() ? graph.getCellStyle(cell)[mxConstants.STYLE_SHAPE] : cell.isEdge() ? 'link' : graph.getModel().isLayer(cell) ? 'layer' : 'mxCell';
 
             if (!isNullOrEmpty(shape)) {
               var obj = doc.createElement(shape);
               obj.setAttribute('label', cellValue || '');
               obj.setAttribute('name', shape + cell.getId());
               model.setValue(cell, obj);
             }
           }
         }
       };
 
       // Applies only basic text styles
       if (asText) {
         for (var i = 0; i < cells.length; i++) {
           let cell = cells[i];
           var edge = model.isEdge(cell);
           var current = edge ? graph.currentEdgeStyle : graph.currentVertexStyle;
           var textStyles = ['fontSize', 'fontFamily', 'fontColor'];
 
           for (var j = 0; j < textStyles.length; j++) {
             var value = current[textStyles[j]];
             if (value != null) graph.setCellStyles(textStyles[j], value, cells);
           }
           convertToNode(cell);
         }
       } else {
         for (var i = 0; i < cells.length; i++) {
           let cell = cells[i];
 
           // Removes styles defined in the cell style from the styles to be applied
           var cellStyle = model.getStyle(cell);
           var tokens = cellStyle != null ? cellStyle.split(';') : [];
           var appliedStyles = styles.slice();
 
           for (var j = 0; j < tokens.length; j++) {
             var tmp = tokens[j];
             var pos = tmp.indexOf('=');
 
             if (pos >= 0) {
               var key = tmp.substring(0, pos);
               var index = mxUtils.indexOf(appliedStyles, key);
 
               if (index >= 0) {
                 appliedStyles.splice(index, 1);
               }
 
               // Handles special cases where one defined style ignores other styles
               for (var k = 0; k < keyGroups.length; k++) {
                 var group = keyGroups[k];
 
                 if (mxUtils.indexOf(group, key) >= 0) {
                   for (var l = 0; l < group.length; l++) {
                     var index2 = mxUtils.indexOf(appliedStyles, group[l]);
 
                     if (index2 >= 0) {
                       appliedStyles.splice(index2, 1);
                     }
                   }
                 }
               }
             }
           }
 
           // Applies the current style to the cell
           var edge = model.isEdge(cell);
           var current = edge ? graph.currentEdgeStyle : graph.currentVertexStyle;
           var newStyle = model.getStyle(cell);
 
           for (var j = 0; j < appliedStyles.length; j++) {
             var key = appliedStyles[j];
             var styleValue = current[key];
 
             if (styleValue != null && (key != 'shape' || edge)) {
               // Special case: Connect styles are not applied here but in the connection handler
               if (!edge || mxUtils.indexOf(connectStyles, key) < 0) {
                 newStyle = mxUtils.setStyle(newStyle, key, styleValue);
               }
             }
           }
 
           model.setStyle(cell, newStyle);
           convertToNode(cell);
         }
       }
     } finally {
       model.endUpdate();
     }
   };
 
   graph.addListener(mxEvent.CELLS_ADDED, function (sender, evt) {
     insertHandler(evt.getProperty('cells'));
   });
   graph.addListener('cellsInserted', function (sender, evt) {
     insertHandler(evt.getProperty('cells'));
   });
   graph.addListener('textInserted', function (sender, evt) {
     insertHandler(evt.getProperty('cells'), true);
   });
   graph.connectionHandler.addListener(mxEvent.CONNECT, function (sender, evt) {
     var cells = [evt.getProperty('cell')];
     if (evt.getProperty('terminalInserted')) cells.push(evt.getProperty('terminal'));
 
     insertHandler(cells);
   });
 
   this.addListener(
     'styleChanged',
     mxUtils.bind(this, function (sender, evt) {
       // Checks if edges and/or vertices were modified
       var cells = evt.getProperty('cells');
       var vertex = false;
       var edge = false;
 
       if (cells.length > 0) {
         for (var i = 0; i < cells.length; i++) {
           vertex = graph.getModel().isVertex(cells[i]) || vertex;
           edge = graph.getModel().isEdge(cells[i]) || edge;
 
           if (edge && vertex) {
             break;
           }
         }
       } else {
         vertex = true;
         edge = true;
       }
 
       var keys = evt.getProperty('keys');
       var values = evt.getProperty('values');
 
       for (var i = 0; i < keys.length; i++) {
         var common = mxUtils.indexOf(valueStyles, keys[i]) >= 0;
 
         // Ignores transparent stroke colors
         if (keys[i] != 'strokeColor' || (values[i] != null && values[i] != 'none')) {
           // Special case: Edge style and shape
           if (mxUtils.indexOf(connectStyles, keys[i]) >= 0) {
             if (edge || mxUtils.indexOf(alwaysEdgeStyles, keys[i]) >= 0) {
               if (values[i] == null) {
                 delete graph.currentEdgeStyle[keys[i]];
               } else {
                 graph.currentEdgeStyle[keys[i]] = values[i];
               }
             }
             // Uses style for vertex if defined in styles
             else if (vertex && mxUtils.indexOf(styles, keys[i]) >= 0) {
               if (values[i] == null) {
                 delete graph.currentVertexStyle[keys[i]];
               } else {
                 graph.currentVertexStyle[keys[i]] = values[i];
               }
             }
           } else if (mxUtils.indexOf(styles, keys[i]) >= 0) {
             if (vertex || common) {
               if (values[i] == null) {
                 delete graph.currentVertexStyle[keys[i]];
               } else {
                 graph.currentVertexStyle[keys[i]] = values[i];
               }
             }
 
             if (edge || common || mxUtils.indexOf(alwaysEdgeStyles, keys[i]) >= 0) {
               if (values[i] == null) {
                 delete graph.currentEdgeStyle[keys[i]];
               } else {
                 graph.currentEdgeStyle[keys[i]] = values[i];
               }
             }
           }
         }
       }
 
       if (this.toolbar != null) {
         this.toolbar.setFontName(graph.currentVertexStyle['fontFamily'] || Menus.prototype.defaultFont);
         this.toolbar.setFontSize(graph.currentVertexStyle['fontSize'] || Menus.prototype.defaultFontSize);
 
         if (this.toolbar.edgeStyleMenu != null) {
           // Updates toolbar icon for edge style
           var edgeStyleDiv = this.toolbar.edgeStyleMenu.getElementsByTagName('div')[0];
 
           if (graph.currentEdgeStyle['edgeStyle'] == mxConstants.EDGESTYLE_ORTHOGONAL && graph.currentEdgeStyle['curved'] == '1') {
             edgeStyleDiv.className = 'geSprite geSprite-curved';
           } else if (graph.currentEdgeStyle['edgeStyle'] == 'straight' || graph.currentEdgeStyle['edgeStyle'] == 'none' || graph.currentEdgeStyle['edgeStyle'] == null) {
             edgeStyleDiv.className = 'geSprite geSprite-straight';
           } else if (graph.currentEdgeStyle['edgeStyle'] == mxConstants.EDGESTYLE_ENTITY_RELATION) {
             edgeStyleDiv.className = 'geSprite geSprite-entity';
           } else if (graph.currentEdgeStyle['edgeStyle'] == mxConstants.EDGESTYLE_ELBOW) {
             edgeStyleDiv.className = 'geSprite geSprite-' + (graph.currentEdgeStyle['elbow'] == 'vertical' ? 'verticalelbow' : 'horizontalelbow');
           } else if (graph.currentEdgeStyle['edgeStyle'] == mxConstants.EDGESTYLE_ISOMETRIC) {
             edgeStyleDiv.className = 'geSprite geSprite-' + (graph.currentEdgeStyle['elbow'] == 'vertical' ? 'verticalisometric' : 'horizontalisometric');
           } else {
             edgeStyleDiv.className = 'geSprite geSprite-orthogonal';
           }
         }
 
         if (this.toolbar.edgeShapeMenu != null) {
           // Updates icon for edge shape
           var edgeShapeDiv = this.toolbar.edgeShapeMenu.getElementsByTagName('div')[0];
 
           if (graph.currentEdgeStyle['shape'] == 'link') {
             edgeShapeDiv.className = 'geSprite geSprite-linkedge';
           } else if (graph.currentEdgeStyle['shape'] == 'flexArrow') {
             edgeShapeDiv.className = 'geSprite geSprite-arrow';
           } else if (graph.currentEdgeStyle['shape'] == 'arrow') {
             edgeShapeDiv.className = 'geSprite geSprite-simplearrow';
           } else {
             edgeShapeDiv.className = 'geSprite geSprite-noarrow';
           }
         }
 
         // Updates icon for optinal line start shape
         if (this.toolbar.lineStartMenu != null) {
           var lineStartDiv = this.toolbar.lineStartMenu.getElementsByTagName('div')[0];
 
           lineStartDiv.className = this.getCssClassForMarker('start', graph.currentEdgeStyle['shape'], graph.currentEdgeStyle[mxConstants.STYLE_STARTARROW], mxUtils.getValue(graph.currentEdgeStyle, 'startFill', '1'));
         }
 
         // Updates icon for optinal line end shape
         if (this.toolbar.lineEndMenu != null) {
           var lineEndDiv = this.toolbar.lineEndMenu.getElementsByTagName('div')[0];
 
           lineEndDiv.className = this.getCssClassForMarker('end', graph.currentEdgeStyle['shape'], graph.currentEdgeStyle[mxConstants.STYLE_ENDARROW], mxUtils.getValue(graph.currentEdgeStyle, 'endFill', '1'));
         }
       }
     })
   );
 
   // Update font size and font family labels
   if (this.toolbar) {
     var update = mxUtils.bind(this, function () {
       var ff = graph.currentVertexStyle['fontFamily'] || 'Tahoma';
       var fs = String(graph.currentVertexStyle['fontSize'] || '12');
 
       var state = graph.getView().getState(graph.getSelectionCell());
       if (state != null) {
         ff = state.style[mxConstants.STYLE_FONTFAMILY] || ff;
         fs = state.style[mxConstants.STYLE_FONTSIZE] || fs;
 
         if (ff.length > 10) {
           ff = ff.substring(0, 8) + '...';
         }
       }
 
       this.toolbar.setFontName(ff);
       this.toolbar.setFontSize(fs);
     });
 
     graph.getSelectionModel().addListener(mxEvent.CHANGE, update);
     graph.getModel().addListener(mxEvent.CHANGE, update);
   }
 
   // Makes sure the current layer is visible when cells are added
   graph.addListener(mxEvent.CELLS_ADDED, function (sender, evt) {
     var cells = evt.getProperty('cells');
     var parent = evt.getProperty('parent');
 
     if (graph.getModel().isLayer(parent) && !graph.isCellVisible(parent) && cells != null && cells.length > 0) {
       graph.getModel().setVisible(parent, true);
     }
   });
 
   // Global handler to hide the current menu
   this.gestureHandler = mxUtils.bind(this, function (evt) {
     if (this.currentMenu != null && mxEvent.getSource(evt) != this.currentMenu.div) {
       this.hideCurrentMenu();
     }
   });
   mxEvent.addGestureListeners(document, this.gestureHandler);
 
   // Updates the editor UI after the window has been resized or the orientation changes
   // Timeout is workaround for old IE versions which have a delay for DOM client sizes.
   // Should not use delay > 0 to avoid handle multiple repaints during window resize
   this.resizeHandler = mxUtils.bind(this, function () {
     window.setTimeout(
       mxUtils.bind(this, function () {
         if (this.editor.graph != null) {
           this.refresh();
         }
       }),
       0
     );
   });
   mxEvent.addListener(window, 'resize', this.resizeHandler);
 
   this.orientationChangeHandler = mxUtils.bind(this, function () {
     this.refresh();
   });
   mxEvent.addListener(window, 'orientationchange', this.orientationChangeHandler);
 
   // Workaround for bug on iOS see
   // http://stackoverflow.com/questions/19012135/ios-7-ipad-safari-landscape-innerheight-outerheight-layout-issue
   if (mxClient.IS_IOS && !window.navigator.standalone) {
     this.scrollHandler = mxUtils.bind(this, function () {
       window.scrollTo(0, 0);
     });
     mxEvent.addListener(window, 'scroll', this.scrollHandler);
   }
 
   /**
    * Sets the initial scrollbar locations after a file was loaded.
    */
   this.editor.addListener(
     'resetGraphView',
     mxUtils.bind(this, function () {
       this.resetScrollbars();
     })
   );
 
   /**
    * Repaints the grid.
    */
   this.addListener(
     'gridEnabledChanged',
     mxUtils.bind(this, function () {
       graph.view.validateBackground();
     })
   );
   this.addListener(
     'backgroundColorChanged',
     mxUtils.bind(this, function () {
       graph.view.validateBackground();
     })
   );
   /**
    * Repaints the grid.
    */
   graph.addListener(
     'gridSizeChanged',
     mxUtils.bind(this, function () {
       if (graph.isGridEnabled()) {
         graph.view.validateBackground();
       }
     })
   );
 
   // Resets UI, updates action and menu states
   this.editor.resetGraph();
 
   if (this.editor.isViewMode()) {
 
     this.init();
     this.open();
 
     this.marksService = new MarksService(this);
   
     this.viewHandler = new ViewModeHandler(this);
   
  
     this.marksService.modeEnabled = false;
   } else {
     // init bindings
     if (typeof BindingsHandler == 'function') this.bindingsHandler = new BindingsHandler(this);
 
     this.init();
     this.open();
 
     if (this.bindingsHandler != null) this.bindingsHandler.ready();
 
     // Open sidebar panel
     var sidebarAction = this.actions.get('sidebarPanel');
     if (sidebarAction) sidebarAction.funct();
 
     // Open format panel
     var formatAction = this.actions.get('formatPanel');
     if (formatAction) formatAction.funct();
 
     //var mgr = new mxAutoSaveManager(graph);
     //mgr.save = function()
     //{
     //   mxLog.show();
     //   mxLog.debug('save');
     //};
   }
 
   this.editor.setModified(false);
   this.editor.undoManager.clear();
 
 };
 mxUtils.extend(EditorUi, mxEventSource);
 
 
 
 /**
  * Specifies the height of the menubar.
  */
 EditorUi.prototype.menubarHeight = 40;
 /**
  * Specifies the height of the toolbar.
  */
 EditorUi.prototype.toolbarHeight = 30;
 /**
  * Specifies the height of the footer. Default is 20.
  */
 EditorUi.prototype.footerHeight = 20;
 
 /**
  * Installs the listeners to update the action states.
  */
 EditorUi.prototype.init = function () {
   /**
    * Keypress starts immediate editing on selection cell
    */
   var graph = this.editor.graph;
 
   //----> longTouch conextMenu
   let contextMenu = null;
   let bool = true;
   graph.addListener(
     mxEvent.TAP_AND_HOLD,
     function (sender, evt) {
       const cell = evt.getProperty('cell');
 
       //pick up active point
       graph.setSelectionCell(cell);
       if (!cell) {
         graph.clearSelection();
         }
 
       //create context menu
       contextMenu = new mxPopupMenu(document.createElement('div'));
       contextMenu.div.className = 'mxPopupMenu';
       this.menus.createPopupMenu(contextMenu, cell, evt, bool);
 
       //-------> fix bug with extra divs. case: touch by touch
       const divs = document.querySelectorAll('.mxPopupMenu');
       let num = divs.length;
       for (let i = 0; i < divs.length; i++) {
         num -= 1;
         if (num == 0) {
           break;
         } else {
           divs[i].remove();
         }
       }
       //<------- fix bug with extra divs. case: touch by touch
 
       //add position for context menu
       const x = evt.getProperty('event').clientX;
       const y = evt.getProperty('event').clientY;
       contextMenu.div.style.left = `${x}px`;
       contextMenu.div.style.top = `${y}px`;
 
       contextMenu.showMenu();
     }.bind(this)
   );
 
   //-------> fix bug with extra divs. case: touch switch mouse
   graph.addListener(mxEvent.CLICK, function (sender, evt) {
     const cell = evt.getProperty('cell');
     const menuContainer = document.querySelectorAll('div.mxPopupMenu');
 
     if (menuContainer && menuContainer.length > 1) {
       const divs = document.querySelectorAll('div.mxPopupMenu');
       divs[0].remove();
     }
   });
   //<------- fix bug with extra divs. case: touch switch mouse 
 
   //<---- longTouch conextMenu
 
   mxEvent.addGestureListeners(
     document,
     mxUtils.bind(this, function (evt) {
       if (contextMenu) contextMenu.hideMenu();
     })
   );
   mxEvent.addListener(
     graph.container,
     'keydown',
     mxUtils.bind(this, function (evt) {
       this.onKeyDown(evt);
     })
   );
   mxEvent.addListener(
     graph.container,
     'keypress',
     mxUtils.bind(this, function (evt) {
       this.onKeyPress(evt);
     })
   );
 
   // Updates action states
   this.addUndoListener();
   this.addBeforeUnloadListener();
 
   graph.getSelectionModel().addListener(
     mxEvent.CHANGE,
     mxUtils.bind(this, function () {
       this.updateActionStates();
     })
   );
   graph.getModel().addListener(
     mxEvent.CHANGE,
     mxUtils.bind(this, function () {
       this.updateActionStates();
     })
   );
 
   // Changes action states after change of default parent
   var graphSetDefaultParent = graph.setDefaultParent;
   var ui = this;
 
   this.editor.graph.setDefaultParent = function () {
     graphSetDefaultParent.apply(this, arguments);
     ui.updateActionStates();
   };
 
   // Hack to make editLink available in vertex handler
   graph.editLink = ui.actions.get('editLink').funct;
 
   this.updateActionStates();
   this.initClipboard();
   this.initCanvas();
 
   if (this.scheme.model != null) {
     var doc = mxUtils.parseXml(this.scheme.model);
     this.editor.setGraphXml(doc.documentElement);
   }
   this.editor.setFilename(this.scheme.name);
   this.editor.setModified(false);
 };
 
 /**
  * Returns true if the given event should start editing. This implementation returns true.
  */
 
 EditorUi.prototype.onKeyDown = function (evt) {
   var graph = this.editor.graph;
 
   // Tab selects next cell
   if (evt.which == 9 && graph.isEnabled() && !mxEvent.isAltDown(evt)) {
     if (graph.isEditing()) {
       graph.stopEditing(false);
     } else {
       graph.selectCell(!mxEvent.isShiftDown(evt));
     }
 
     mxEvent.consume(evt);
   }
 };
 
 /**
  * Returns true if the given event should start editing. This implementation returns true.
  */
 EditorUi.prototype.onKeyPress = function (evt) {
   var graph = this.editor.graph;
 
   if (this.isImmediateEditingEvent(evt) && !graph.isEditing() && !graph.isSelectionEmpty() && evt.which !== 0 && evt.which !== 27 && !mxEvent.isAltDown(evt) && !mxEvent.isControlDown(evt) && !mxEvent.isMetaDown(evt)) {
     graph.escape();
     graph.startEditing();
 
     // Workaround for FF where char is lost if cursor is placed before char
     if (mxClient.IS_FF) {
       var ce = graph.cellEditor;
       ce.textarea.innerHTML = String.fromCharCode(evt.which);
 
       // Moves cursor to end of textarea
       var range = document.createRange();
       range.selectNodeContents(ce.textarea);
       range.collapse(false);
       var sel = window.getSelection();
       sel.removeAllRanges();
       sel.addRange(range);
     }
   }
 };
 
 /**
  * Returns true if the given event should start editing. This implementation returns true.
  */
 EditorUi.prototype.isImmediateEditingEvent = function (evt) {
   return true;
 };
 
 /**
  * Private helper method.
  */
 EditorUi.prototype.getCssClassForMarker = function (prefix, shape, marker, fill) {
   var result = '';
 
   if (shape == 'flexArrow') {
     result = marker != null && marker != mxConstants.NONE ? 'geSprite geSprite-' + prefix + 'blocktrans' : 'geSprite geSprite-noarrow';
   } else {
     if (marker == mxConstants.ARROW_CLASSIC) {
       result = fill == '1' ? 'geSprite geSprite-' + prefix + 'classic' : 'geSprite geSprite-' + prefix + 'classictrans';
     } else if (marker == mxConstants.ARROW_CLASSIC_THIN) {
       result = fill == '1' ? 'geSprite geSprite-' + prefix + 'classicthin' : 'geSprite geSprite-' + prefix + 'classicthintrans';
     } else if (marker == mxConstants.ARROW_OPEN) {
       result = 'geSprite geSprite-' + prefix + 'open';
     } else if (marker == mxConstants.ARROW_OPEN_THIN) {
       result = 'geSprite geSprite-' + prefix + 'openthin';
     } else if (marker == mxConstants.ARROW_BLOCK) {
       result = fill == '1' ? 'geSprite geSprite-' + prefix + 'block' : 'geSprite geSprite-' + prefix + 'blocktrans';
     } else if (marker == mxConstants.ARROW_BLOCK_THIN) {
       result = fill == '1' ? 'geSprite geSprite-' + prefix + 'blockthin' : 'geSprite geSprite-' + prefix + 'blockthintrans';
     } else if (marker == mxConstants.ARROW_OVAL) {
       result = fill == '1' ? 'geSprite geSprite-' + prefix + 'oval' : 'geSprite geSprite-' + prefix + 'ovaltrans';
     } else if (marker == mxConstants.ARROW_DIAMOND) {
       result = fill == '1' ? 'geSprite geSprite-' + prefix + 'diamond' : 'geSprite geSprite-' + prefix + 'diamondtrans';
     } else if (marker == mxConstants.ARROW_DIAMOND_THIN) {
       result = fill == '1' ? 'geSprite geSprite-' + prefix + 'thindiamond' : 'geSprite geSprite-' + prefix + 'thindiamondtrans';
     } else if (marker == 'openAsync') {
       result = 'geSprite geSprite-' + prefix + 'openasync';
     } else if (marker == 'dash') {
       result = 'geSprite geSprite-' + prefix + 'dash';
     } else if (marker == 'cross') {
       result = 'geSprite geSprite-' + prefix + 'cross';
     } else if (marker == 'async') {
       result = fill == '1' ? 'geSprite geSprite-' + prefix + 'async' : 'geSprite geSprite-' + prefix + 'asynctrans';
     } else if (marker == 'circle' || marker == 'circlePlus') {
       result = fill == '1' || marker == 'circle' ? 'geSprite geSprite-' + prefix + 'circle' : 'geSprite geSprite-' + prefix + 'circleplus';
     } else if (marker == 'ERone') {
       result = 'geSprite geSprite-' + prefix + 'erone';
     } else if (marker == 'ERmandOne') {
       result = 'geSprite geSprite-' + prefix + 'eronetoone';
     } else if (marker == 'ERmany') {
       result = 'geSprite geSprite-' + prefix + 'ermany';
     } else if (marker == 'ERoneToMany') {
       result = 'geSprite geSprite-' + prefix + 'eronetomany';
     } else if (marker == 'ERzeroToOne') {
       result = 'geSprite geSprite-' + prefix + 'eroneopt';
     } else if (marker == 'ERzeroToMany') {
       result = 'geSprite geSprite-' + prefix + 'ermanyopt';
     } else {
       result = 'geSprite geSprite-noarrow';
     }
   }
 
   return result;
 };
 
 /**
  * Overridden in Menus.js
  */
 EditorUi.prototype.createMenus = function () {
   return null;
 };
 
 /**
  * Hook for allowing selection and context menu for certain events.
  */
 EditorUi.prototype.updatePasteActionStates = function () {
   var graph = this.editor.graph;
   var paste = this.actions.get('paste');
   var pasteHere = this.actions.get('pasteHere');
 
   paste.setEnabled(this.editor.graph.cellEditor.isContentEditing() || (!mxClipboard.isEmpty() && graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent())));
   pasteHere.setEnabled(paste.isEnabled());
 };
 
 /**
  * Hook for allowing selection and context menu for certain events.
  */
 EditorUi.prototype.initClipboard = function () {
   var ui = this;
 
   // Public helper method for shared clipboard.
   mxClipboard.cellsToString = function (cells) {
     var codec = new mxCodec();
     var model = new mxGraphModel();
     var parent = model.getChildAt(model.getRoot(), 0);
 
     for (var i = 0; i < cells.length; i++) {
       model.add(parent, cells[i]);
     }
 
     return mxUtils.getXml(codec.encode(model));
   };
 
   var mxClipboardIsEmpty = mxClipboard.isEmpty;
   mxClipboard.isEmpty = function () {
     return mxClipboardIsEmpty.apply(this, arguments) && webix.storage.local.get('scheme.clipboard') == null;
   };
 
   var mxClipboardCut = mxClipboard.cut;
   mxClipboard.cut = function (graph) {
     var result = null;
 
     if (graph.cellEditor.isContentEditing()) {
       document.execCommand('copy', false, null);
     } else {
       result = result || graph.getSelectionCells();
       result = graph.getExportableCells(graph.model.getTopmostCells(result));
 
       var cloneMap = new Object();
       var lookup = graph.createCellLookup(result);
       var clones = graph.cloneCells(result, null, cloneMap);
 
       // Uses temporary model to force new IDs to be assigned
       // to avoid having to carry over the mapping from object
       // ID to cell ID to the paste operation
       var model = new mxGraphModel();
       var parent = model.getChildAt(model.getRoot(), 0);
 
       for (var i = 0; i < clones.length; i++) {
         model.add(parent, clones[i]);
       }
 
       graph.updateCustomLinks(graph.createCellMapping(cloneMap, lookup), clones);
 
       mxClipboard.insertCount = 1;
       mxClipboard.setCells(clones);
       copyCells(graph, graph.removeCells());
     }
 
     ui.updatePasteActionStates();
 
     return result;
   };
 
   var mxClipboardCopy = mxClipboard.copy;
   mxClipboard.copy = function (graph) {
     if (graph.cellEditor.isContentEditing()) {
       document.execCommand('copy', false, null);
     } else {
       //mxClipboardCopy.apply(this, arguments);
       copyCells(graph, graph.getSelectionCells());
     }
 
     ui.updatePasteActionStates();
   };
 
   var mxClipboardPaste = mxClipboard.paste;
   mxClipboard.paste = function (graph) {
     var result = null;
 
     if (graph.cellEditor.isContentEditing()) {
       document.execCommand('paste', false, null);
     } else {
       //result = mxClipboardPaste.apply(this, arguments);
       result = pasteCells(graph);
     }
 
     ui.updatePasteActionStates();
 
     return result;
   };
 
   // Merges XML into existing graph and layers
   var importXml = function (graph, xml, dx, dy) {
     dx = dx != null ? dx : 0;
     dy = dy != null ? dy : 0;
     var cells = [];
 
     try {
       var doc = mxUtils.parseXml(xml);
       var node = doc.documentElement;
 
       if (node != null) {
         var model = new mxGraphModel();
         var codec = new mxCodec(node.ownerDocument);
         codec.decode(node, model);
 
         var childCount = model.getChildCount(model.getRoot());
         var targetChildCount = graph.model.getChildCount(graph.model.getRoot());
 
         // Merges existing layers and adds new layers
         graph.model.beginUpdate();
         try {
           for (var i = 0; i < childCount; i++) {
             var parent = model.getChildAt(model.getRoot(), i);
 
             // Adds cells to existing layers if not locked
             if (targetChildCount > i) {
               // Inserts into active layer if only one layer is being pasted
               var target = childCount == 1 ? graph.getDefaultParent() : graph.model.getChildAt(graph.model.getRoot(), i);
 
               if (!graph.isCellLocked(target)) {
                 var children = model.getChildren(parent);
                 cells = cells.concat(graph.importCells(children, dx, dy, target));
               }
             } else {
               // Delta is non cascading, needs separate move for layers
               parent = graph.importCells([parent], 0, 0, graph.model.getRoot())[0];
               var children = graph.model.getChildren(parent);
               graph.moveCells(children, dx, dy);
               cells = cells.concat(children);
             }
           }
         } finally {
           graph.model.endUpdate();
         }
       }
     } catch (e) {
       alert(e);
       throw e;
     }
 
     return cells;
   };
   // Parses and inserts XML into graph
   var pasteText = function (graph, text) {
     var xml = mxUtils.trim(text);
     var x = graph.container.scrollLeft / graph.view.scale - graph.view.translate.x;
     var y = graph.container.scrollTop / graph.view.scale - graph.view.translate.y;
 
     if (xml.length > 0) {
       let gs = graph.gridSize;
       let dx = gs;
       let dy = gs;
 
       // Standard paste via control-v
       if (xml.substring(0, 14) == '<mxGraphModel>') {
         let cells = importXml(graph, xml, dx, dy);
         graph.setSelectionCells(cells);
         graph.scrollCellToVisible(graph.getSelectionCell());
         return cells;
       }
     }
   };
 
   var copyCells = function (graph, cells) {
     if (cells.length > 0) {
       var clones = graph.cloneCells(cells);
 
       // Checks for orphaned relative children and makes absolute
       for (var i = 0; i < clones.length; i++) {
         var state = graph.view.getState(cells[i]);
 
         if (state != null) {
           var geo = graph.getCellGeometry(clones[i]);
 
           if (geo != null && geo.relative) {
             geo.relative = false;
             geo.x = state.x / state.view.scale - state.view.translate.x;
             geo.y = state.y / state.view.scale - state.view.translate.y;
           }
         }
       }
 
       webix.storage.local.put('scheme.clipboard', mxClipboard.cellsToString(clones));
     }
   };
   var pasteCells = function (graph) {
     if (graph.isEnabled()) {
       var xml = ui.extractGraphModelFromEvent(graph.getEventSource());
       let data = xml != null && xml.length > 0 ? xml : webix.storage.local.get('scheme.clipboard');
       return pasteText(graph, data);
     }
   };
 
   // Overrides cell editor to update paste action state
   var cellEditorStartEditing = this.editor.graph.cellEditor.startEditing;
 
   this.editor.graph.cellEditor.startEditing = function () {
     cellEditorStartEditing.apply(this, arguments);
     ui.updatePasteActionStates();
   };
 
   var cellEditorStopEditing = this.editor.graph.cellEditor.stopEditing;
 
   this.editor.graph.cellEditor.stopEditing = function (cell, trigger) {
     cellEditorStopEditing.apply(this, arguments);
     ui.updatePasteActionStates();
   };
 
   this.updatePasteActionStates();
 };
 
 /**
  * Initializes the infinite canvas.
  */
 EditorUi.prototype.lazyZoomDelay = 20;
 
 /**
  * Initializes the infinite canvas.
  */
 EditorUi.prototype.initCanvas = function () {
   // Initial page layout view, scrollBuffer and timer-based scrolling
   var graph = this.editor.graph;
   graph.timerAutoScroll = true;
 
   /**
    * Returns the padding for pages in page view with scrollbars.
    */
   graph.getPagePadding = function () {
     return new mxPoint(Math.max(0, Math.round((graph.container.offsetWidth - 34) / graph.view.scale)), Math.max(0, Math.round((graph.container.offsetHeight - 34) / graph.view.scale)));
   };
 
   // Fits the number of background pages to the graph
   graph.view.getBackgroundPageBounds = function () {
     var layout = this.graph.getPageLayout();
     var page = this.graph.getPageSize();
 
     return new mxRectangle(this.scale * (this.translate.x + layout.x * page.width), this.scale * (this.translate.y + layout.y * page.height), this.scale * layout.width * page.width, this.scale * layout.height * page.height);
   };
 
   graph.getPreferredPageSize = function (bounds, width, height) {
     var pages = this.getPageLayout();
     var size = this.getPageSize();
 
     return new mxRectangle(0, 0, pages.width * size.width, pages.height * size.height);
   };
 
   // Scales pages/graph to fit available size
   var resize = null;
   var ui = this;
 
   if (this.editor.isViewMode()) {
     resize = mxUtils.bind(this, function (autoscale, maxScale, cx, cy) {
       if (graph.container != null) {
         cx = cx != null ? cx : 0;
         cy = cy != null ? cy : 0;
 
         var bds = graph.pageVisible ? graph.view.getBackgroundPageBounds() : graph.getGraphBounds();
         var scroll = mxUtils.hasScrollbars(graph.container);
         var tr = graph.view.translate;
         var s = graph.view.scale;
 
         // Normalizes the bounds
         var b = mxRectangle.fromRectangle(bds);
         b.x = b.x / s - tr.x;
         b.y = b.y / s - tr.y;
         b.width /= s;
         b.height /= s;
 
         var st = graph.container.scrollTop;
         var sl = graph.container.scrollLeft;
         var sb = document.documentMode >= 8 ? 20 : 14;
 
         if (document.documentMode == 8 || document.documentMode == 9) {
           sb += 3;
         }
 
         var cw = graph.container.offsetWidth - sb;
         var ch = graph.container.offsetHeight - sb;
 
         var ns = autoscale ? Math.max(0.3, Math.min(maxScale || 1, cw / b.width)) : s;
         var dx = (cw - ns * b.width) / 2 / ns;
         var dy = (ch - ns * b.height) / 4 / ns;
 
         if (scroll) {
           dx = Math.max(dx, 0);
           dy = Math.max(dy, 0);
         }
 
         if (scroll || bds.width < cw || bds.height < ch) {
           graph.view.scaleAndTranslate(ns, Math.floor(dx - b.x), Math.floor(dy - b.y));
           graph.container.scrollTop = (st * ns) / s;
           graph.container.scrollLeft = (sl * ns) / s;
         } else if (cx != 0 || cy != 0) {
           var t = graph.view.translate;
           graph.view.setTranslate(Math.floor(t.x + cx / s), Math.floor(t.y + cy / s));
         }
       }
     });
 
     // Hack to make function available to subclassers
     this.viewModeResize = resize;
     this.viewModeWindowResize = mxUtils.bind(this, function () {
       this.viewModeResize(false);
     });
 
     // Removable resize listener
     var autoscaleResize = mxUtils.bind(this, function () {
       this.viewModeWindowResize(false);
     });
     mxEvent.addListener(window, 'resize', autoscaleResize);
 
     this.destroyFunctions.push(function () {
       mxEvent.removeListener(window, 'resize', autoscaleResize);
     });
 
     this.editor.addListener(
       'resetGraphView',
       mxUtils.bind(this, function () {
         this.viewModeResize(true);
       })
     );
 
     this.actions.get('zoomIn').funct = mxUtils.bind(this, function (evt) {
       graph.zoomIn();
         this.viewModeResize(false);
     });
     this.actions.get('zoomOut').funct = mxUtils.bind(this, function (evt) {
       graph.zoomOut();
         this.viewModeResize(false);
     });
 
     // Creates toolbar for viewer
     this.viewModeToolbar = document.createElement('div');
     this.viewModeToolbar.style.position = 'fixed';
     this.viewModeToolbar.style.overflow = 'hidden';
     this.viewModeToolbar.style.boxSizing = 'border-box';
     this.viewModeToolbar.style.whiteSpace = 'nowrap';
     this.viewModeToolbar.style.backgroundColor = '#000000';
     this.viewModeToolbar.style.padding = '6px';
     this.viewModeToolbar.style.right = '0px';
     this.viewModeToolbar.style.bottom = '0px';
     this.viewModeToolbar.className = 'toolbar';
 
     mxUtils.setPrefixedStyle(this.viewModeToolbar.style, 'borderRadius', '10px');
     mxUtils.setPrefixedStyle(this.viewModeToolbar.style, 'transition', 'opacity 600ms ease-in-out');
 
     var updateViewModeToolbarPosition = mxUtils.bind(this, function () {
       var css = mxUtils.getCurrentStyle(graph.container);
       this.viewModeToolbar.style.bottom = (css != null ? parseInt(css['margin-bottom'] || 0) : 0) + 20 + 'px';
     });
     this.editor.addListener('resetGraphView', updateViewModeToolbarPosition);
 
     updateViewModeToolbarPosition();
 
     var addButton = mxUtils.bind(this, function (fn, imgSrc, tip) {
       var a = document.createElement('span');
       a.style.paddingLeft = '8px';
       a.style.paddingRight = '8px';
       a.style.cursor = 'pointer';
       mxEvent.addListener(a, 'click', fn);
 
       if (tip != null) a.setAttribute('title', tip);
 
       var img = document.createElement('img');
       img.setAttribute('border', '0');
       img.setAttribute('src', imgSrc);
       img.setAttribute('width', 20);
       img.setAttribute('height', 20);
 
       a.appendChild(img);
       this.viewModeToolbar.appendChild(a);
 
       return a;
     });
 
     addButton(
       mxUtils.bind(this, function (evt) {
           this.actions.get('zoomOut').funct();
         mxEvent.consume(evt);
       }),
       Editor.zoomOutLargeImage,
       mxResources.get('zoomOut') + ' (Alt+Mousewheel)'
     );
     addButton(
       mxUtils.bind(this, function (evt) {
           this.actions.get('zoomIn').funct();
         mxEvent.consume(evt);
       }),
       Editor.zoomInLargeImage,
       mxResources.get('zoomIn') + ' (Alt+Mousewheel)'
     );
     addButton(
       mxUtils.bind(this, function (evt) {
         this.viewModeResize(true);
         mxEvent.consume(evt);
       }),
       Editor.actualSizeLargeImage,
       mxResources.get('fit')
     );
     // @if !LINKMT
     if (API.USER.hasPermission('scheme.exec_cmd')) {
       addButton(
         mxUtils.bind(this, function (evt) {
           this.marksService.onModeButtonClick();
         }),
         Editor.marksImage,
         'Редактировать пометки'
       );
     }
     // @endif
     // Changes toolbar opacity on hover
     var fadeThread = null;
     var fadeThread2 = null;
 
     var fadeOut = mxUtils.bind(this, function (delay) {
       //---fix---//
       // if (fadeThread != null) {
       //   window.clearTimeout(fadeThread);
       //   fadeThead = null;
       // }
       // if (fadeThread2 != null) {
       //   window.clearTimeout(fadeThread2);
       //   fadeThead2 = null;
       // }
 
       // fadeThread = window.setTimeout(
       //   mxUtils.bind(this, function () {
       //     mxUtils.setOpacity(this.viewModeToolbar, 0);
       //     fadeThread = null;
 
       //     fadeThread2 = window.setTimeout(
       //       mxUtils.bind(this, function () {
       //         this.viewModeToolbar.style.display = 'none';
       //         fadeThread2 = null;
       //       }),
       //       600
       //     );
       //   }),
       //   delay || 200
       // );
         //---fix---//
     });
     var fadeIn = mxUtils.bind(this, function (opacity) {
       //---fix---//
       // if (fadeThread != null) {
       //   window.clearTimeout(fadeThread);
       //   fadeThead = null;
       // }
       // if (fadeThread2 != null) {
       //   window.clearTimeout(fadeThread2);
       //   fadeThead2 = null;
       // }
 
       // this.viewModeToolbar.style.display = '';
       // mxUtils.setOpacity(this.viewModeToolbar, opacity || 30);
       //---fix---//
     });
 
     this.layersDialog = null;
     var layersButton = addButton(
       mxUtils.bind(this, function (evt) {
         if (this.layersDialog != null) {
           this.layersDialog.parentNode.removeChild(this.layersDialog);
           this.layersDialog = null;
         } else {
           this.layersDialog = graph.createLayersDialog();
           mxEvent.addListener(
             this.layersDialog,
             'mouseleave',
             mxUtils.bind(this, function () {
               this.layersDialog.parentNode.removeChild(this.layersDialog);
               this.layersDialog = null;
             })
           );
 
           var r = layersButton.getBoundingClientRect();
 
           mxUtils.setPrefixedStyle(this.layersDialog.style, 'borderRadius', '5px');
           this.layersDialog.style.position = 'fixed';
           this.layersDialog.style.fontFamily = mxConstants.DEFAULT_FONTFAMILY;
           this.layersDialog.style.backgroundColor = '#000000';
           this.layersDialog.style.width = '160px';
           this.layersDialog.style.padding = '4px 2px 4px 2px';
           this.layersDialog.style.color = '#ffffff';
           mxUtils.setOpacity(this.layersDialog, 70);
           this.layersDialog.style.right = 0;
           this.layersDialog.style.bottom = parseInt(this.viewModeToolbar.style.bottom) + this.viewModeToolbar.offsetHeight + 4 + 'px';
           this.layersDialog.className = 'layers';
           // Puts the dialog on top of the container z-index
           var style = mxUtils.getCurrentStyle(this.editor.graph.container);
           this.layersDialog.style.zIndex = 2;
 
           document.body.appendChild(this.layersDialog);
         }
         mxEvent.consume(evt);
       }),
       Editor.layersLargeImage,
       mxResources.get('layers')
     );
 
     // Shows/hides layers button depending on content
     var model = graph.getModel();
     model.addListener(mxEvent.CHANGE, function () {
       layersButton.style.display = model.getChildCount(model.root) > 1 ? '' : 'none';
     });
 
     // @if !LINKMT
     addButton(
       mxUtils.bind(this, function (evt) {
         this.actions.get('print').funct();
         mxEvent.consume(evt);
       }),
       Editor.printLargeImage,
       mxResources.get('print')
     );
     // @endif
     addButton(
       mxUtils.bind(this, function (evt) {
         window.location.reload();
         mxEvent.consume(evt);
       }),
       Editor.refreshLargeImage,
       mxResources.get('refresh')
     );
 
     // Initial state invisible
     this.viewModeToolbar.style.display = 'none';
     mxUtils.setPrefixedStyle(this.viewModeToolbar.style, 'transform', 'translate(0,0)');
     graph.container.appendChild(this.viewModeToolbar);
 
     mxEvent.addListener(
       graph.container,
       mxClient.IS_POINTER ? 'pointermove' : 'mousemove',
       mxUtils.bind(this, function (evt) {
         if (!mxEvent.isTouchEvent(evt)) {
           fadeIn(30);
           fadeOut();
         }
       })
     );
 
     mxEvent.addListener(this.viewModeToolbar, mxClient.IS_POINTER ? 'pointermove' : 'mousemove', function (evt) {
       mxEvent.consume(evt);
     });
     mxEvent.addListener(
       this.viewModeToolbar,
       'mouseenter',
       mxUtils.bind(this, function (evt) {
         fadeIn(100);
       })
     );
     mxEvent.addListener(
       this.viewModeToolbar,
       'mousemove',
       mxUtils.bind(this, function (evt) {
         fadeIn(100);
         mxEvent.consume(evt);
       })
     );
     mxEvent.addListener(
       this.viewModeToolbar,
       'mouseleave',
       mxUtils.bind(this, function (evt) {
         if (!mxEvent.isTouchEvent(evt)) fadeIn(30);
       })
     );
 
     // Shows/hides toolbar for touch devices
     var tol = graph.getTolerance();
     graph.addMouseListener({
       startX: 0,
       startY: 0,
       scrollLeft: 0,
       scrollTop: 0,
       mouseDown: function (sender, me) {
         this.startX = me.getGraphX();
         this.startY = me.getGraphY();
         this.scrollLeft = graph.container.scrollLeft;
         this.scrollTop = graph.container.scrollTop;
       },
       mouseMove: function (sender, me) {},
       mouseUp: function (sender, me) {
         if (mxEvent.isTouchEvent(me.getEvent())) {
           if (Math.abs(this.scrollLeft - graph.container.scrollLeft) < tol && Math.abs(this.scrollTop - graph.container.scrollTop) < tol && Math.abs(this.startX - me.getGraphX()) < tol && Math.abs(this.startY - me.getGraphY()) < tol) {
             if (parseFloat(ui.viewModeToolbar.style.opacity || 0) > 0) fadeOut();
             else fadeIn(30);
           }
         }
       },
     });
 
     // Installs handling of highlight and handling links to relative links and anchors
     graph.addClickHandler();
   } else if (this.editor.extendCanvas) {
     /**
      * Guesses autoTranslate to avoid another repaint (see below).
      * Works if only the scale of the graph changes or if pages
      * are visible and the visible pages do not change.
      */
     var graphViewValidate = graph.view.validate;
     graph.view.validate = function () {
       if (this.graph.container != null && mxUtils.hasScrollbars(this.graph.container)) {
         var pad = this.graph.getPagePadding();
         var size = this.graph.getPageSize();
 
         //var tx = this.translate.x;
         //var ty = this.translate.y;
         this.translate.x = pad.x - (this.x0 || 0) * size.width;
         this.translate.y = pad.y - (this.y0 || 0) * size.height;
       }
 
       graphViewValidate.apply(this, arguments);
     };
 
     var graphSizeDidChange = graph.sizeDidChange;
     graph.sizeDidChange = function () {
       if (this.container != null && mxUtils.hasScrollbars(this.container)) {
         var pages = this.getPageLayout();
         var pad = this.getPagePadding();
         var size = this.getPageSize();
 
         // Updates the minimum graph size
         var minw = Math.ceil(2 * pad.x + pages.width * size.width);
         var minh = Math.ceil(2 * pad.y + pages.height * size.height);
 
         var min = graph.minimumGraphSize;
         if (min == null || min.width != minw || min.height != minh) graph.minimumGraphSize = new mxRectangle(0, 0, minw, minh);
 
         // Updates auto-translate to include padding and graph size
         var dx = pad.x - pages.x * size.width;
         var dy = pad.y - pages.y * size.height;
 
         if (!this.autoTranslate && (this.view.translate.x != dx || this.view.translate.y != dy)) {
           this.autoTranslate = true;
           this.view.x0 = pages.x;
           this.view.y0 = pages.y;
 
           // NOTE: THIS INVOKES THIS METHOD AGAIN. UNFORTUNATELY THERE IS NO WAY AROUND THIS SINCE THE
           // BOUNDS ARE KNOWN AFTER THE VALIDATION AND SETTING THE TRANSLATE TRIGGERS A REVALIDATION.
           // SHOULD MOVE TRANSLATE/SCALE TO VIEW.
           var tx = graph.view.translate.x;
           var ty = graph.view.translate.y;
           graph.view.setTranslate(dx, dy);
 
           // LATER: Fix rounding errors for small zoom
           graph.container.scrollLeft += Math.round((dx - tx) * graph.view.scale);
           graph.container.scrollTop += Math.round((dy - ty) * graph.view.scale);
 
           this.autoTranslate = false;
 
           return;
         }
 
         graphSizeDidChange.apply(this, arguments);
       } else {
         // Fires event but does not invoke superclass
         this.fireEvent(new mxEventObject(mxEvent.SIZE, 'bounds', this.getGraphBounds()));
       }
     };
   }
 
   // Accumulates the zoom factor while the rendering is taking place
   // so that not the complete sequence of zoom steps must be painted
   graph.updateZoomTimeout = null;
   graph.cumulativeZoomFactor = 1;
 
   var cursorPosition = null;
 
   graph.lazyZoom = function (zoomIn) {
     if (this.updateZoomTimeout != null) window.clearTimeout(this.updateZoomTimeout);
 
     // Switches to 1% zoom steps below 15%. Lower bound depdends on rounding below
     if (zoomIn) {
       if (this.view.scale * this.cumulativeZoomFactor < 0.15) this.cumulativeZoomFactor = (this.view.scale + 0.01) / this.view.scale;
       else {
         // Uses to 5% zoom steps for better grid rendering in webkit and to avoid rounding errors for zoom steps
         this.cumulativeZoomFactor *= this.zoomFactor;
         this.cumulativeZoomFactor = Math.round(this.view.scale * this.cumulativeZoomFactor * 20) / 20 / this.view.scale;
       }
     } else {
       if (this.view.scale * this.cumulativeZoomFactor <= 0.15) this.cumulativeZoomFactor = (this.view.scale - 0.01) / this.view.scale;
       else {
         // Uses to 5% zoom steps for better grid rendering in webkit and to avoid rounding errors for zoom steps
         this.cumulativeZoomFactor /= this.zoomFactor;
         this.cumulativeZoomFactor = Math.round(this.view.scale * this.cumulativeZoomFactor * 20) / 20 / this.view.scale;
       }
     }
 
     this.cumulativeZoomFactor = Math.max(0.01, Math.min(this.view.scale * this.cumulativeZoomFactor, 160) / this.view.scale);
     this.updateZoomTimeout = window.setTimeout(
       mxUtils.bind(this, function () {
         var offset = mxUtils.getOffset(graph.container);
         var dx = 0;
         var dy = 0;
 
         if (cursorPosition != null) {
           dx = graph.container.offsetWidth / 2 - cursorPosition.x + offset.x;
           dy = graph.container.offsetHeight / 2 - cursorPosition.y + offset.y;
         }
 
         var prev = this.view.scale;
         this.zoom(this.cumulativeZoomFactor);
         var s = this.view.scale;
 
         if (s != prev) {
           if (resize != null) {
             ui.viewModeResize(false, null, dx * (this.cumulativeZoomFactor - 1), dy * (this.cumulativeZoomFactor - 1));
           }
 
           if (mxUtils.hasScrollbars(graph.container) && (dx != 0 || dy != 0)) {
             graph.container.scrollLeft -= dx * (this.cumulativeZoomFactor - 1);
             graph.container.scrollTop -= dy * (this.cumulativeZoomFactor - 1);
           }
         }
 
         this.cumulativeZoomFactor = 1;
         this.updateZoomTimeout = null;
       }),
       this.lazyZoomDelay
     );
   };
 
   mxEvent.addMouseWheelListener(
     mxUtils.bind(this, function (evt, up) {
       // Ctrl+wheel (or pinch on touchpad) is a native browser zoom event is OS X
       // LATER: Add support for zoom via pinch on trackpad for Chrome in OS X
       if ((this.dialogs == null || this.dialogs.length == 0) && graph.isZoomWheelEvent(evt)) {
         var source = mxEvent.getSource(evt);
         while (source != null) {
           if (source == graph.container) {
             cursorPosition = new mxPoint(mxEvent.getClientX(evt), mxEvent.getClientY(evt));
             graph.lazyZoom(up);
             mxEvent.consume(evt);
             return false;
           }
 
           source = source.parentNode;
         }
       }
     }),
     graph.container
   );
 };
 
 /**
  * Creates a temporary graph instance for rendering off-screen content.
  */
 EditorUi.prototype.createTemporaryGraph = function (stylesheet) {
   var graph = new Graph(document.createElement('div'), null, null, stylesheet);
  
   graph.resetViewOnRootChange = false;
   graph.setConnectable(false);
   graph.gridEnabled = false;
   graph.autoScroll = false;
   graph.setTooltips(false);
   graph.setEnabled(false);
 
   // Container must be in the DOM for correct HTML rendering
   graph.container.style.visibility = 'hidden';
   graph.container.style.position = 'absolute';
   graph.container.style.overflow = 'hidden';
   graph.container.style.height = '1px';
   graph.container.style.width = '1px';
 
   return graph;
 };
 
 EditorUi.prototype.isDiagramEmpty = function () {
   var model = this.editor.graph.getModel();
   return model.getChildCount(model.root) == 1 && model.getChildCount(model.getChildAt(model.root, 0)) == 0;
 };
 
 /**
  * Hook for allowing selection and context menu for certain events.
  */
 EditorUi.prototype.isSelectionAllowed = function (evt) {
   let src = mxEvent.getSource(evt);
   return (src && src.nodeName == 'SELECT') || (src.nodeName == 'INPUT' && mxUtils.isAncestorNode(this.formatContainer, src));
 };
 
 /**
  * Installs dialog if browser window is closed without saving
  * This must be disabled during save and image export.
  */
 EditorUi.prototype.addBeforeUnloadListener = function () {
   // Installs dialog if browser window is closed without saving (This must be disabled during save and image export)
   window.onbeforeunload = mxUtils.bind(this, function () {
     if (!this.editor.isViewMode()) return this.onBeforeUnload();
   });
 };
 
 /**
  * Sets the onbeforeunload for the application
  */
 EditorUi.prototype.onBeforeUnload = function () {
   if (this.editor.modified) return mxResources.get('allChangesLost');
 };
 
 /**
  * Opens the current diagram via the window.opener if one exists.
  */
 EditorUi.prototype.open = function () {
   // Cross-domain window access is not allowed in FF, so if we
   // were opened from another domain then this will fail.
   try {
     if (window.opener != null && window.opener.openFile != null) {
       window.opener.openFile.setConsumer(
         mxUtils.bind(this, function (xml, filename) {
           try {
             if (filename != null) {
               var doc = mxUtils.parseXml(xml);
               this.editor.setGraphXml(doc.documentElement);
               this.editor.setFilename(filename);
               this.editor.setModified(false);
               this.editor.undoManager.clear();
             }
             return;
           } catch (e) {
             console.log(mxResources.get('invalidOrMissingFile') + ': ' + e.message)
             // messageError(mxResources.get('invalidOrMissingFile') + ': ' + e.message);
           }
         })
       );
     }
   } catch (e) {
     // ignore
   }
 
   // Fires as the last step if no file was loaded
   this.editor.graph.view.validate();
 
   // Required only in special cases where an initial file is opened and the minimumGraphSize changes and CSS must be updated.
   this.editor.graph.sizeDidChange();
   this.editor.fireEvent(new mxEventObject('resetGraphView'));
 };
 
 /**
  * Sets the current menu and element.
  */
 EditorUi.prototype.setCurrentMenu = function (menu, elt) {
   this.currentMenuElt = elt;
   this.currentMenu = menu;
 };
 
 /**
  * Resets the current menu and element.
  */
 EditorUi.prototype.resetCurrentMenu = function () {
   this.currentMenuElt = null;
   this.currentMenu = null;
 };
 
 /**
  * Hides and destroys the current menu.
  */
 EditorUi.prototype.hideCurrentMenu = function () {
   if (this.currentMenu != null) {
     this.currentMenu.hideMenu();
     this.resetCurrentMenu();
   }
 };
 
 /**
  * Updates the document title.
  */
 EditorUi.prototype.createHoverIcons = function () {
   return new HoverIcons(this.editor.graph);
 };
 
 /**
  * Returns the URL for a copy of this editor with no state.
  */
 EditorUi.prototype.redo = function () {
   try {
     var graph = this.editor.graph;
 
     if (graph.isEditing()) {
       document.execCommand('redo', false, null);
     } else {
       this.editor.undoManager.redo();
     }
   } catch (e) {
     // ignore all errors
   }
 };
 
 /**
  * Returns the URL for a copy of this editor with no state.
  */
 EditorUi.prototype.undo = function () {
   try {
     var graph = this.editor.graph;
 
     if (graph.isEditing()) {
       // Stops editing and executes undo on graph if native undo
       // does not affect current editing value
       var value = graph.cellEditor.textarea.innerHTML;
       document.execCommand('undo', false, null);
 
       if (value == graph.cellEditor.textarea.innerHTML) {
         graph.stopEditing(true);
         this.editor.undoManager.undo();
       }
     } else {
       this.editor.undoManager.undo();
     }
   } catch (e) {
     // ignore all errors
   }
 };
 
 /**
  * Returns the URL for a copy of this editor with no state.
  */
 EditorUi.prototype.canRedo = function () {
   return this.editor.graph.isEditing() || this.editor.undoManager.canRedo();
 };
 
 /**
  * Returns the URL for a copy of this editor with no state.
  */
 EditorUi.prototype.canUndo = function () {
   return this.editor.graph.isEditing() || this.editor.undoManager.canUndo();
 };
 
 /**
  *
  */
 EditorUi.prototype.getEditBlankXml = function () {
   return mxUtils.getXml(this.editor.getGraphXml());
 };
 
 /**
  * Returns the URL for a copy of this editor with no state.
  */
 EditorUi.prototype.getUrl = function (pathname) {
   //---fix---//
   // var href = pathname != null ? pathname : window.location.pathname;
   // var parms = href.indexOf('?') > 0 ? 1 : 0;
 
   // // Removes template URL parameter for new blank diagram
   // for (var key in urlParams) {
   //   if (parms == 0) {
   //     href += '?';
   //   } else {
   //     href += '&';
   //   }
 
   //   href += key + '=' + urlParams[key];
   //   parms++;
   // }
 
   // return href;
    //---fix---//
 };
 
 /**
  * Specifies if the graph has scrollbars.
  */
 EditorUi.prototype.setScrollbars = function (value) {
   var graph = this.editor.graph;
   var prev = graph.container.style.overflow;
   graph.scrollbars = value;
   this.editor.updateGraphComponents();
 
   if (prev != graph.container.style.overflow) {
     if (graph.container.style.overflow == 'hidden') {
       var t = graph.view.translate;
       graph.view.setTranslate(t.x - graph.container.scrollLeft / graph.view.scale, t.y - graph.container.scrollTop / graph.view.scale);
       graph.container.scrollLeft = 0;
       graph.container.scrollTop = 0;
       graph.minimumGraphSize = null;
       graph.sizeDidChange();
     } else {
       var dx = graph.view.translate.x;
       var dy = graph.view.translate.y;
 
       graph.view.translate.x = 0;
       graph.view.translate.y = 0;
       graph.sizeDidChange();
       graph.container.scrollLeft -= Math.round(dx * graph.view.scale);
       graph.container.scrollTop -= Math.round(dy * graph.view.scale);
     }
   }
 
   this.fireEvent(new mxEventObject('scrollbarsChanged'));
 };
 
 /**
  * Returns true if the graph has scrollbars.
  */
 EditorUi.prototype.hasScrollbars = function () {
   return this.editor.graph.scrollbars;
 };
 
 /**
  * Resets the state of the scrollbars.
  */
 EditorUi.prototype.resetScrollbars = function () {
   var graph = this.editor.graph;
 
   if (!this.editor.extendCanvas) {
     graph.container.scrollTop = 0;
     graph.container.scrollLeft = 0;
 
     if (!mxUtils.hasScrollbars(graph.container)) {
       graph.view.setTranslate(0, 0);
     }
   } else if (!this.editor.isViewMode()) {
     if (mxUtils.hasScrollbars(graph.container)) {
       if (graph.pageVisible) {
         var pad = graph.getPagePadding();
         graph.container.scrollTop = Math.floor(pad.y - this.editor.initialTopSpacing) - 1;
         graph.container.scrollLeft = Math.floor(Math.min(pad.x, (graph.container.scrollWidth - graph.container.clientWidth) / 2)) - 1;
 
         // Scrolls graph to visible area
         var bounds = graph.getGraphBounds();
 
         if (bounds.width > 0 && bounds.height > 0) {
           if (bounds.x > graph.container.scrollLeft + graph.container.clientWidth * 0.9) {
             graph.container.scrollLeft = Math.min(bounds.x + bounds.width - graph.container.clientWidth, bounds.x - 10);
           }
 
           if (bounds.y > graph.container.scrollTop + graph.container.clientHeight * 0.9) {
             graph.container.scrollTop = Math.min(bounds.y + bounds.height - graph.container.clientHeight, bounds.y - 10);
           }
         }
       } else {
         var bounds = graph.getGraphBounds();
         var width = Math.max(bounds.width, graph.scrollTileSize.width * graph.view.scale);
         var height = Math.max(bounds.height, graph.scrollTileSize.height * graph.view.scale);
         graph.container.scrollTop = Math.floor(Math.max(0, bounds.y - Math.max(20, (graph.container.clientHeight - height) / 4)));
         graph.container.scrollLeft = Math.floor(Math.max(0, bounds.x - Math.max(0, (graph.container.clientWidth - width) / 2)));
       }
     } else {
       // This code is not actively used since the default for scrollbars is always true
       if (graph.pageVisible) {
         var b = graph.view.getBackgroundPageBounds();
         graph.view.setTranslate(Math.floor(Math.max(0, (graph.container.clientWidth - b.width) / 2) - b.x), Math.floor(Math.max(0, (graph.container.clientHeight - b.height) / 2) - b.y));
       } else {
         var bounds = graph.getGraphBounds();
         graph.view.setTranslate(Math.floor(Math.max(0, Math.max(0, (graph.container.clientWidth - bounds.width) / 2) - bounds.x)), Math.floor(Math.max(0, Math.max(20, (graph.container.clientHeight - bounds.height) / 4)) - bounds.y));
       }
     }
   }
 };
 
 /**
  * Loads the stylesheet for this graph.
  */
 EditorUi.prototype.setPageVisible = function (value) {
   var graph = this.editor.graph;
   var hasScrollbars = mxUtils.hasScrollbars(graph.container);
   var tx = 0;
   var ty = 0;
 
   if (hasScrollbars) {
     tx = graph.view.translate.x * graph.view.scale - graph.container.scrollLeft;
     ty = graph.view.translate.y * graph.view.scale - graph.container.scrollTop;
   }
 
   graph.pageVisible = value;
   graph.pageBreaksVisible = value;
   graph.preferPageSize = value;
   graph.view.validateBackground();
 
   // Workaround for possible handle offset
   if (hasScrollbars) {
     var cells = graph.getSelectionCells();
     graph.clearSelection();
     graph.setSelectionCells(cells);
   }
 
   // Calls updatePageBreaks
   graph.sizeDidChange();
 
   if (hasScrollbars) {
     graph.container.scrollLeft = graph.view.translate.x * graph.view.scale - tx;
     graph.container.scrollTop = graph.view.translate.y * graph.view.scale - ty;
   }
 
   this.fireEvent(new mxEventObject('pageViewChanged'));
 };
 
 /**
  * Change types
  */
 function ChangePageSetup(ui, color, image, format) {
   this.ui = ui;
   this.color = color;
   this.previousColor = color;
   this.image = image;
   this.previousImage = image;
   this.format = format;
   this.previousFormat = format;
 
   // Needed since null are valid values for color and image
   this.ignoreColor = false;
   this.ignoreImage = false;
 }
 /**
  * Implementation of the undoable page rename.
  */
 ChangePageSetup.prototype.execute = function () {
   var graph = this.ui.editor.graph;
 
   if (!this.ignoreColor) {
     this.color = this.previousColor;
     let tmp = graph.background;
     this.ui.setBackgroundColor(this.previousColor);
     this.previousColor = tmp;
   }
 
   if (!this.ignoreImage) {
     this.image = this.previousImage;
     let tmp = graph.backgroundImage;
     this.ui.setBackgroundImage(this.previousImage);
     this.previousImage = tmp;
   }
 
   if (this.previousFormat != null) {
     this.format = this.previousFormat;
     let tmp = graph.pageFormat;
 
     if (this.previousFormat.width != tmp.width || this.previousFormat.height != tmp.height) {
       this.ui.setPageFormat(this.previousFormat);
       this.previousFormat = tmp;
     }
   }
 
   if (this.foldingEnabled != null && this.foldingEnabled != this.ui.editor.graph.foldingEnabled) {
     this.ui.setFoldingEnabled(this.foldingEnabled);
     this.foldingEnabled = !this.foldingEnabled;
   }
 };
 
 // Registers codec for ChangePageSetup
 (function () {
   var codec = new mxObjectCodec(new ChangePageSetup(), ['ui', 'previousColor', 'previousImage', 'previousFormat']);
   codec.afterDecode = function (dec, node, obj) {
     obj.previousColor = obj.color;
     obj.previousImage = obj.image;
     obj.previousFormat = obj.format;
 
     if (obj.foldingEnabled != null) obj.foldingEnabled = !obj.foldingEnabled;
 
     return obj;
   };
   mxCodecRegistry.register(codec);
 })();
 
 /**
  * Loads the stylesheet for this graph.
  */
 EditorUi.prototype.setBackgroundColor = function (value) {
   this.editor.graph.background = value;
   this.editor.graph.view.validateBackground();
 
   this.fireEvent(new mxEventObject('backgroundColorChanged'));
 };
 
 /**
  * Loads the stylesheet for this graph.
  */
 EditorUi.prototype.setFoldingEnabled = function (value) {
   this.editor.graph.foldingEnabled = value;
   this.editor.graph.view.revalidate();
 
   this.fireEvent(new mxEventObject('foldingEnabledChanged'));
 };
 
 /**
  * Loads the stylesheet for this graph.
  */
 EditorUi.prototype.setPageFormat = function (value) {
   this.editor.graph.pageFormat = value;
 
   if (!this.editor.graph.pageVisible) this.actions.get('pageView').funct();
   else {
     this.editor.graph.view.validateBackground();
     this.editor.graph.sizeDidChange();
   }
   this.fireEvent(new mxEventObject('pageFormatChanged'));
 };
 
 /**
  * Loads the stylesheet for this graph.
  */
 EditorUi.prototype.setPageScale = function (value) {
   this.editor.graph.pageScale = value;
 
   if (!this.editor.graph.pageVisible) this.actions.get('pageView').funct();
   else {
     this.editor.graph.view.validateBackground();
     this.editor.graph.sizeDidChange();
   }
 
   this.fireEvent(new mxEventObject('pageScaleChanged'));
 };
 
 /**
  * Loads the stylesheet for this graph.
  */
 EditorUi.prototype.setGridColor = function (value) {
   this.editor.graph.view.gridColor = value;
   this.editor.graph.view.validateBackground();
   this.fireEvent(new mxEventObject('gridColorChanged'));
 };
 
 /**
  * Updates the states of the given undo/redo items.
  */
 EditorUi.prototype.addUndoListener = function () {
   var undo = this.actions.get('undo');
   var redo = this.actions.get('redo');
 
   var undoMgr = this.editor.undoManager;
   var undoListener = mxUtils.bind(this, function () {
     undo.setEnabled(this.canUndo());
     redo.setEnabled(this.canRedo());
   });
 
   undoMgr.addListener(mxEvent.ADD, undoListener);
   undoMgr.addListener(mxEvent.UNDO, undoListener);
   undoMgr.addListener(mxEvent.REDO, undoListener);
   undoMgr.addListener(mxEvent.CLEAR, undoListener);
 
   // Overrides cell editor to update action states
   var cellEditorStartEditing = this.editor.graph.cellEditor.startEditing;
   this.editor.graph.cellEditor.startEditing = function () {
     cellEditorStartEditing.apply(this, arguments);
     undoListener();
   };
 
   var cellEditorStopEditing = this.editor.graph.cellEditor.stopEditing;
   this.editor.graph.cellEditor.stopEditing = function (cell, trigger) {
     cellEditorStopEditing.apply(this, arguments);
     undoListener();
   };
 
   // Updates the button states once
   undoListener();
 };
 
 /**
  * Updates the states of the given toolbar items based on the selection.
  */
 EditorUi.prototype.updateActionStates = function () {
   var graph = this.editor.graph;
   var selected = !graph.isSelectionEmpty();
   var vertexSelected = false;
   var edgeSelected = false;
 
   var cells = graph.getSelectionCells();
 
   if (cells != null) {
     for (var i = 0; i < cells.length; i++) {
       var cell = cells[i];
 
       if (graph.getModel().isEdge(cell)) {
         edgeSelected = true;
       }
 
       if (graph.getModel().isVertex(cell)) {
         vertexSelected = true;
       }
 
       if (edgeSelected && vertexSelected) {
         break;
       }
     }
   }
 
   // Updates action states
   var actions = ['cut', 'copy', 'bold', 'italic', 'underline', 'delete', 'duplicate', 'editStyle', 'editTooltip', 'editLink', 'backgroundColor', 'borderColor', 'edit', 'toFront', 'toBack', 'lockUnlock', 'solid', 'dashed', 'pasteSize', 'dotted', 'fillColor', 'gradientColor', 'shadow', 'fontColor', 'formattedText', 'rounded', 'toggleRounded', 'sharp', 'strokeColor'];
 
   for (var i = 0; i < actions.length; i++) {
     this.actions.get(actions[i]).setEnabled(selected);
   }
 
   this.actions.get('setAsDefaultStyle').setEnabled(graph.getSelectionCount() == 1);
   this.actions.get('clearWaypoints').setEnabled(!graph.isSelectionEmpty());
   this.actions.get('copySize').setEnabled(graph.getSelectionCount() == 1);
   this.actions.get('turn').setEnabled(!graph.isSelectionEmpty());
   this.actions.get('curved').setEnabled(edgeSelected);
   this.actions.get('rotation').setEnabled(vertexSelected);
   this.actions.get('wordWrap').setEnabled(vertexSelected);
   this.actions.get('autosize').setEnabled(vertexSelected);
   var oneVertexSelected = vertexSelected && graph.getSelectionCount() == 1;
   this.actions.get('group').setEnabled(graph.getSelectionCount() > 1 || (oneVertexSelected && !graph.isContainer(graph.getSelectionCell())));
   this.actions.get('ungroup').setEnabled(graph.getSelectionCount() == 1 && (graph.getModel().getChildCount(graph.getSelectionCell()) > 0 || (oneVertexSelected && graph.isContainer(graph.getSelectionCell()))));
   this.actions.get('removeFromGroup').setEnabled(oneVertexSelected && graph.getModel().isVertex(graph.getModel().getParent(graph.getSelectionCell())));
 
   // Updates menu states
   var state = graph.view.getState(graph.getSelectionCell());
 
   this.menus.get('navigation').setEnabled(selected || graph.view.currentRoot != null);
   this.actions.get('collapsible').setEnabled(vertexSelected && (graph.isContainer(graph.getSelectionCell()) || graph.model.getChildCount(graph.getSelectionCell()) > 0));
   //this.actions.get('home').setEnabled(graph.view.currentRoot != null);
   //this.actions.get('exitGroup').setEnabled(graph.view.currentRoot != null);
   //this.actions.get('enterGroup').setEnabled(graph.getSelectionCount() == 1 && graph.isValidRoot(graph.getSelectionCell()));
   var foldable = graph.getSelectionCount() == 1 && graph.isCellFoldable(graph.getSelectionCell());
   this.actions.get('expand').setEnabled(foldable);
   this.actions.get('collapse').setEnabled(foldable);
 
   this.actions.get('editLink').setEnabled(graph.getSelectionCount() == 1);
   this.actions.get('openLink').setEnabled(graph.getSelectionCount() == 1 && graph.getLinkForCell(graph.getSelectionCell()) != null);
   this.actions.get('guides').setEnabled(graph.isEnabled());
   this.actions.get('grid').setEnabled(!this.editor.isViewMode());
 
   var unlocked = graph.isEnabled() && !graph.isCellLocked(graph.getDefaultParent());
   //this.menus.get('layout').setEnabled(unlocked);
   this.menus.get('insert').setEnabled(unlocked);
   this.menus.get('direction').setEnabled(unlocked && vertexSelected);
   this.menus.get('align').setEnabled(unlocked && vertexSelected && graph.getSelectionCount() > 1);
   this.menus.get('distribute').setEnabled(unlocked && vertexSelected && graph.getSelectionCount() > 1);
   this.actions.get('selectVertices').setEnabled(unlocked);
   this.actions.get('selectEdges').setEnabled(unlocked);
   this.actions.get('selectAll').setEnabled(unlocked);
   this.actions.get('selectNone').setEnabled(unlocked);
 
   this.updatePasteActionStates();
 };
 
 /**
  * Refreshes the viewport.
  */
 EditorUi.prototype.refresh = function (sizeDidChange) {
   sizeDidChange = sizeDidChange != null ? sizeDidChange : true;
 
   var w = this.container.clientWidth;
   var h = this.container.clientHeight;
 
   if (this.container == document.body) {
     w = document.body.clientWidth || document.documentElement.clientWidth;
     h = document.documentElement.clientHeight;
   }
 
   // Workaround for bug on iOS see
   // http://stackoverflow.com/questions/19012135/ios-7-ipad-safari-landscape-innerheight-outerheight-layout-issue
   // FIXME: Fix if footer visible
   var off = 0;
   if (mxClient.IS_IOS && !window.navigator.standalone) {
     if (window.innerHeight != document.documentElement.clientHeight) {
       off = document.documentElement.clientHeight - window.innerHeight;
       window.scrollTo(0, 0);
     }
   }
 
   var tmp = 0;
 
   tmp += this.demobarContainer.$height || 0;
 
   this.menubarContainer.style.height = this.menubarHeight + 'px';
   tmp += this.menubarHeight;
 
   if (this.toolbar != null) {
     this.toolbarContainer.style.height = this.toolbarHeight + 'px';
     tmp += this.toolbarHeight;
   }
 
   this.diagramContainer.style.top = tmp + 'px';
   this.diagramContainer.style.bottom = this.footerHeight + off + 'px';
 
   // actions windows should be below the header part
   if (this.actions) {
     if (this.actions.sidebarWindow && this.actions.sidebarWindow.window.getY() < tmp) this.actions.sidebarWindow.window.setLocation(this.actions.sidebarWindow.window.getX(), tmp);
 
     if (this.actions.formatWindow && this.actions.formatWindow.window.getY() < tmp) this.actions.formatWindow.window.setLocation(this.actions.formatWindow.window.getX(), tmp);
   }
 
   if (sizeDidChange) this.editor.graph.sizeDidChange();
 };
 
 /**
  * Creates the required containers.
  */
 
 EditorUi.prototype.createDivs = function () {
   //----->fix<------//
   var demobar = webix.ui({
     css: 'demoheader',
     autoheight: true,
     hidden: true, // set false to see the demo-banner
     rows: [
         {
             height: 10
         },
         {
             cols: [
                 {
                     rows:
                         [
                             {
                                 borderless: true,
                                 autoheight: true,
                                 css: 'demo_template',
                                 template: "<p align='right'>Это демонстрационная версия продукта. До окончания пробного периода осталось дней:</p>"
                                     + "<p align='right'>Информацию о полной версии можно получить в коммерческом департаменте: sales.mt@systeme.ru 8 (800) 250-63-60</p>"
                             }
                         ]
                 },
                 {
                     view: "template",
                     css: 'demo_template',
                     borderless: true,
                     autoheight: true,
                     width: 100,
                     template: function (obj) {
                        
                         return "<p align='center' class=demorestborder> </p>";
                     },
                     
                 }
             ]
         },
         {
             height: 10
         }
     ]
 })
 //----->fix<------//
   this.demobarContainer = demobar || { $height: 0 };
 //----->fix<------//
   var menubar = webix.ui({
     css: 'demoheader',
     autoheight: true,
     hidden: true, // set false to see the demo-banner
     rows: [
         {
             height: 10
         },
         {
             cols: [
                 {
                     rows:
                         [
                             {
                                 borderless: true,
                                 autoheight: true,
                                 css: 'demo_template',
                                 template: "<p align='right'>Это демонстрационная версия продукта. До окончания пробного периода осталось дней:</p>"
                                     + "<p align='right'>Информацию о полной версии можно получить в коммерческом департаменте: sales.mt@systeme.ru 8 (800) 250-63-60</p>"
                             }
                         ]
                 },
                 {
                     view: "template",
                     css: 'demo_template',
                     borderless: true,
                     autoheight: true,
                     width: 100,
                     template: function (obj) {
                        
                         return "<p align='center' class=demorestborder> </p>";
                     },
                     
                 }
             ]
         },
         {
             height: 10
         }
     ]
 })
 //----->fix<------//
   if (menubar) {
     webix.html.addCss(menubar.getNode(), 'geMenubarContainer');
     this.menubarContainer = menubar.getNode();
   }
 
   this.toolbarContainer = this.createDiv('geToolbarContainer');
   this.diagramContainer = this.createDiv('geDiagramContainer');
 };
 
 /**
  * Creates the required containers.
  */
 EditorUi.prototype.createUi = function () {
   // Creates menubar
   this.menubar = this.editor.isViewMode() ? null : this.menus.createMenubar(this.createDiv('geMenubar'));
   if (this.menubar) this.menubarContainer.appendChild(this.menubar.container);
 
   // Creates toolbar
   this.toolbar = this.editor.isViewMode() ? null : new Toolbar(this, this.createDiv('geToolbar'));
   if (this.toolbar != null) {
     this.toolbarContainer.appendChild(this.toolbar.container);
     this.container.appendChild(this.toolbarContainer);
   }
 
   this.container.appendChild(this.diagramContainer);
 };
 
 /**
  * Creates the actual toolbar for the toolbar container.
  */
 EditorUi.prototype.createDiv = function (classname) {
   var elt = document.createElement('div');
   elt.className = classname;
 
   return elt;
 };
 
 EditorUi.prototype.handleError = function (resp, title, fn, invokeFnOnClose, notFoundMessage) {
   var e = resp != null && resp.error != null ? resp.error : resp;
 
   if (e != null || title != null) {
     var msg = mxUtils.htmlEntities(mxResources.get('unknownError'));
     var btn = mxResources.get('ok');
     title = title != null ? title : mxResources.get('error');
 
     if (e != null && e.message != null) {
       msg = mxUtils.htmlEntities(e.message);
     }
 
     this.showError(title, msg, btn, fn, null, null, null, null, null, null, null, null, invokeFnOnClose ? fn : null);
   } else if (fn != null) {
     fn();
   }
 };
 EditorUi.prototype.showError = function (title, msg, btn, fn, retry, btn2, fn2, btn3, fn3, w, h, hide, onClose) {
   var dlg = new ErrorDialog(this, title, msg, btn || mxResources.get('ok'), fn, retry, btn2, fn2, hide, btn3, fn3);
   var lines = Math.ceil(msg != null ? msg.length / 50 : 1);
   this.showDialog(dlg.container, w || 340, h || 100 + lines * 20, true, false, onClose);
   dlg.init();
 };
 
 /**
  * Displays dialog.
  */
 EditorUi.prototype.showDialog = function (elt, w, h, modal, closable, onClose, noScroll, transparent, onResize, ignoreBgClick) {
   this.editor.graph.tooltipHandler.hideTooltip();
 
   this.dialog = new Dialog(this, elt, w, h, modal, closable, onClose, noScroll, transparent, onResize, /*ignoreBgClick*/ true);
   this.dialogs.push(this.dialog);
 };
 
 /**
  * Hides dialog.
  */
 EditorUi.prototype.hideDialog = function (cancel, isEsc) {
   if (this.dialogs != null && this.dialogs.length > 0) {
     var dlg = this.dialogs.pop();
 
     if (dlg.close(cancel, isEsc) == false) {
       //add the dialog back if dialog closing is cancelled
       this.dialogs.push(dlg);
       return;
     }
 
     this.dialog = this.dialogs.length > 0 ? this.dialogs[this.dialogs.length - 1] : null;
     this.editor.fireEvent(new mxEventObject('hideDialog'));
 
     if (this.dialog == null && this.editor.graph.container.style.visibility != 'hidden') {
       window.setTimeout(
         mxUtils.bind(this, function () {
           if (this.editor.graph.isEditing() && this.editor.graph.cellEditor.textarea != null) {
             this.editor.graph.cellEditor.textarea.focus();
           } else {
             mxUtils.clearSelection();
             this.editor.graph.container.focus();
           }
         }),
         0
       );
     }
   }
 };
 
 /**
  * Display a color dialog.
  */
 EditorUi.prototype.pickColor = function (color, apply) {
   var graph = this.editor.graph;
   var selState = graph.cellEditor.saveSelection();
   var h = 226 + (Math.ceil(ColorDialog.prototype.presetColors.length / 12) + Math.ceil(ColorDialog.prototype.defaultColors.length / 12)) * 17;
 
   var dlg = new ColorDialog(
     this,
     color || 'none',
     function (color) {
       graph.cellEditor.restoreSelection(selState);
       apply(color);
     },
     function () {
       graph.cellEditor.restoreSelection(selState);
     }
   );
   this.showDialog(dlg.container, 230, h, true, false);
   dlg.init();
 };
 
 /**
  * Adds the label menu items to the given menu and parent.
  */
 EditorUi.prototype.openFile = function () {
   // Closes dialog after open
   window.openFile = new OpenFile(
     mxUtils.bind(this, function (cancel) {
       this.hideDialog(cancel);
     })
   );
 
   // Removes openFile if dialog is closed
   this.showDialog(new OpenDialog(this).container, 320, 220, true, true, function () {
     window.openFile = null;
   });
 };
 
 /**
  * Extracs the graph model from the given HTML data from a data transfer event.
  */
 EditorUi.prototype.extractGraphModelFromHtml = function (data) {
   var result = null;
 
   try {
     var idx = data.indexOf('&lt;mxGraphModel ');
 
     if (idx >= 0) {
       var idx2 = data.lastIndexOf('&lt;/mxGraphModel&gt;');
 
       if (idx2 > idx) {
         result = data
           .substring(idx, idx2 + 21)
           .replace(/&gt;/g, '>')
           .replace(/&lt;/g, '<')
           .replace(/\\&quot;/g, '"')
           .replace(/\n/g, '');
       }
     }
   } catch (e) {
     // ignore
   }
 
   return result;
 };
 
 /**
  * Opens the given files in the editor.
  */
 EditorUi.prototype.extractGraphModelFromEvent = function (evt) {
   var result = null;
   var data = null;
 
   if (evt != null) {
     var provider = evt.dataTransfer != null ? evt.dataTransfer : evt.clipboardData;
 
     if (provider != null) {
       if (document.documentMode == 10 || document.documentMode == 11) {
         data = provider.getData('Text');
       } else {
         data = mxUtils.indexOf(provider.types, 'text/html') >= 0 ? provider.getData('text/html') : null;
 
         if (mxUtils.indexOf(provider.types, 'text/plain' && (data == null || data.length == 0))) {
           data = provider.getData('text/plain');
         }
       }
 
       if (data != null) {
         data = Graph.zapGremlins(mxUtils.trim(data));
 
         // Tries parsing as HTML document with embedded XML
         var xml = this.extractGraphModelFromHtml(data);
 
         if (xml != null) {
           data = xml;
         }
       }
     }
   }
 
   if (data != null && this.isCompatibleString(data)) {
     result = data;
   }
 
   return result;
 };
 
 /**
  * Hook for subclassers to return true if event data is a supported format.
  * This implementation always returns false.
  */
 EditorUi.prototype.isCompatibleString = function (data) {
   return false;
 };
 
 /**
  * Adds the label menu items to the given menu and parent.
  */
 EditorUi.prototype.saveFile = function (forceDialog) {
   if (!forceDialog && this.editor.filename != null) {
     this.save(this.editor.getOrCreateFilename());
   } else {
     var dlg = new FilenameDialog(
       this,
       this.editor.getOrCreateFilename(),
       mxResources.get('save'),
       mxUtils.bind(this, function (name) {
         AJAX.post(
           API.FUNC.schemeAdd,
           null,
           { name: name },
           mxUtils.bind(this, function (xhr, res) {
             if (res) {
               this.scheme = res;
               this.save(name);
             }
           }),
           function (xhr, err) {
             console.log('Ошибка добавления схемы')
             // messageError('Ошибка добавления схемы');
           }
         );
       }),
       mxResources.get('schemeName'),
       mxUtils.bind(this, function (name) {
         if (name != null && name.length > 0) return true;
         console.log(mxResources.get('invalidName'))
         // messageError(mxResources.get('invalidName'));
         return false;
       })
     );
 
     this.showDialog(dlg.container, 300, 80, true, true);
     dlg.init();
   }
 };
 
 /**
  * Saves the current graph under the given filename.
  */
 EditorUi.prototype.save = function (name) {
   if (!isNullOrEmpty(name)) {
     try {
       if (this.editor.graph.isEditing()) this.editor.graph.stopEditing();
 
       var xml = mxUtils.getXml(this.editor.getGraphXml());
       this.scheme.model = xml;
       AJAX.post(
         // SAVE_URL,
         null,
         null,
         this.scheme,
         mxUtils.bind(this, function (xhr, res) {
           if (!res) {
             console.log('Ошибка сохранения схемы.')
             // messageError('Ошибка сохранения схемы.');
             return;
           }
           this.editor.setFilename(name);
           this.editor.setModified(false);
         }),
         function (xhr, err) {
           console.log('Ошибка сохранения схемы.')
           // messageError('Ошибка сохранения схемы.');
         }
       );
     } catch (e) {
       console.log(mxResources.get('errorSavingFile'))
       // messageError(mxResources.get('errorSavingFile'));
     }
   }
 };
 
 /**
  * Executes the given action.
  */
 EditorUi.prototype.animateAction = function (exec, animate, post) {
   var graph = this.editor.graph;
 
   if (graph.isEnabled()) {
     graph.getModel().beginUpdate();
     try {
       exec();
     } catch (e) {
       throw e;
     } finally {
       // Animates the changes in the graph model except for Camino, where animation is too slow
       if (animate && navigator.userAgent.indexOf('Camino') < 0) {
         // New API for animating graph layout results asynchronously
         var morph = new mxMorphing(graph);
         morph.addListener(
           mxEvent.DONE,
           mxUtils.bind(this, function () {
             graph.getModel().endUpdate();
 
             if (post != null) {
               post();
             }
           })
         );
 
         morph.startAnimation();
       } else {
         graph.getModel().endUpdate();
 
         if (post != null) {
           post();
         }
       }
     }
   }
 };
 
 var imageUploader = webix.ui({
   //---fix---//
   //id: 'img_uploader',
   //---fix---//
   view: 'uploader',
   multiple: false,
   apiOnly: true,
   autosend: false,
   on: {
     onBeforeFileAdd: function (item) {
       if (this.config.accept && this.config.accept !== '*') {
         let acceptedTypes = this.config.accept.split(',').map(function (x) {
           return x.trimFromStart('.');
         });
         if (acceptedTypes.indexOf(item.type.toLowerCase()) < 0) {
           console.log('common.errors.support_only_files' + ': ' + acceptedTypes.join(','))
           // messageError(translate('common.errors.support_only_files') + ': ' + acceptedTypes.join(','));
           this.files.clearAll();
           return false;
         }
       }
     },
     //onAfterFileAdd: function (item)
     //{
     //    var inputs = this.$view.getElementsByTagName("INPUT");
     //    var fileList = inputs[inputs.length - 1].files;
     //    if (fileList && fileList.length > 0)
     //    {
     //        // last file is loaded by client
     //        if (this.files.count() === fileList.length)
     //        {
     //            //var fdata = new FormData();
     //            //fdata.append('ftype', this.config.ftype);
     //            //let obj = this.files.data.pull[item.id];
     //            //fdata.append('files[]', obj.file, obj.name);
     //            //let fileData = new Blob([files[0]]);
     //            var self = this;
     //            HELP.readFile(item.file, function (data)
     //            {
     //                let imgbase64 = 'data:image/' + item.type + ';base64,' + Base64.encode(data, true);
     //                var img = new Image();
     //                img.onload = function()
     //                {
     //                    fn(newValue, img.width, img.height);
     //                };
     //                img.onerror = function()
     //                {
     //                    fn(null);
     //                    messageError(mxResources.get('fileNotFound'));
     //                };
     //                img.src = newValue;
     //                self.files.clearAll();
     //            });
     //        }
     //    }
     //}
   },
 });
 EditorUi.prototype.showImageDialog = function (title, value, fn, ignoreExisting) {
   var cellEditor = this.editor.graph.cellEditor;
   var selState = cellEditor.saveSelection();
   //var newValue = mxUtils.prompt(title, value);
   //cellEditor.restoreSelection(selState);
 
   //if (newValue != null && newValue.length > 0)
   //{
   //    var img = new Image();
 
   //    img.onload = function()
   //    {
   //        fn(newValue, img.width, img.height);
   //    };
   //    img.onerror = function()
   //    {
   //        fn(null);
   //        messageError(mxResources.get('fileNotFound'));
   //    };
 
   //    img.src = newValue;
   //}
   //else
   //{
   //    fn(null);
   //}
 
   var inputs = imageUploader.$view.getElementsByTagName('INPUT');
   if (inputs.length > 0) {
     var fileInput = inputs[inputs.length - 1];
     if (fileInput) {
       let acceptedImages = '.svg,.png,.gif,.jpg,.jpeg,.bmp';
       $(fileInput).attr('accept', acceptedImages);
       imageUploader.define('accept', acceptedImages);
       var uploaderEvent = imageUploader.attachEvent('onAfterFileAdd', function (item) {
         cellEditor.restoreSelection(selState);
         var inputs = this.$view.getElementsByTagName('INPUT');
         if (inputs.length > 0) {
           var fileList = inputs[inputs.length - 1].files;
           if (fileList && fileList.length > 0) {
             if (this.files.count() === fileList.length) {
               var self = this;
               if (item.type.toLowerCase() == 'svg') {
                 HELP.readFile(item.file, function (data) {
                   let imageData = window.btoa ? window.btoa(data) : Base64.encode(data, true);
                   var img = new Image();
                   img.onload = function () {
                     fn('data:image/svg+xml,' + imageData, img.width, img.height);
                   };
                   img.onerror = function () {
                     fn(null);
                     console.log(mxResources.get('errorLoadingFile'))
                     // messageError(mxResources.get('errorLoadingFile'));
                   };
                   img.src = 'data:image/svg+xml;base64,' + imageData;
                   self.files.clearAll();
                 });
               } else {
                 HELP.readBinaryFile(item.file, function (data) {
                   let imageData = window.btoa ? window.btoa(data) : Base64.encode(data, true);
                   var img = new Image();
                   img.onload = function () {
                     fn('data:image/' + item.type + ',' + imageData, img.width, img.height);
                   };
                   img.onerror = function () {
                     fn(null);
                     console.log(mxResources.get('errorLoadingFile'))
                     // messageError(mxResources.get('errorLoadingFile'));
                   };
                   img.src = 'data:image/' + item.type + ';base64,' + imageData;
                   self.files.clearAll();
                 });
               }
             }
           }
         }
         imageUploader.detachEvent(uploaderEvent);
       });
       imageUploader.fileDialog();
     }
   }
 };
 
 /**
  * Hides the current menu.
  */
 EditorUi.prototype.showLinkDialog = function (value, btnLabel, fn) {
   var dlg = new LinkDialog(this, value, btnLabel, fn);
   this.showDialog(dlg.container, 420, 90, true, true);
   dlg.init();
 };
 
 /**
  * Hides the current menu.
  */
 EditorUi.prototype.showDataDialog = function (cell) {
   if (cell != null) {
     var dlg = new EditDataDialog(this, cell);
     this.showDialog(dlg.container, 480, 420, true, true, null, false);
     dlg.init();
   }
 };
 
 /**
  * Hides the current menu.
  */
 EditorUi.prototype.showBackgroundImageDialog = function (apply) {
   apply =
     apply != null
       ? apply
       : mxUtils.bind(this, function (image) {
           var change = new ChangePageSetup(this, null, image);
           change.ignoreColor = true;
 
           this.editor.graph.model.execute(change);
         });
 
   var newValue = mxUtils.prompt(mxResources.get('backgroundImage'), '');
 
   if (newValue != null && newValue.length > 0) {
     var img = new Image();
 
     img.onload = function () {
       apply(new mxImage(newValue, img.width, img.height));
     };
     img.onerror = function () {
       apply(null);
       console.log(mxResources.get('fileNotFound'))
       // messageError(mxResources.get('fileNotFound'));
     };
 
     img.src = newValue;
   } else {
     apply(null);
   }
 };
 
 /**
  * Loads the stylesheet for this graph.
  */
 EditorUi.prototype.setBackgroundImage = function (image) {
   this.editor.graph.setBackgroundImage(image);
   this.editor.graph.view.validateBackgroundImage();
 
   this.fireEvent(new mxEventObject('backgroundImageChanged'));
 };
 
 EditorUi.prototype.confirm = function (msg, okFn, cancelFn) {
   //---fix---//
 //   messageConfirm(msg, function (result) {
 //     if (result === true && okFn != null) okFn();
 //     else if (cancelFn != null) cancelFn();
 //   });
  //---fix---//
  };
 
 // Alt+Shift+Keycode mapping to action
 EditorUi.prototype.altShiftActions = {
   67: 'clearWaypoints', // Alt+Shift+C
   65: 'connectionArrows', // Alt+Shift+A
   76: 'editLink', // Alt+Shift+L
   80: 'connectionPoints', // Alt+Shift+P
   84: 'editTooltip', // Alt+Shift+T
   86: 'pasteSize', // Alt+Shift+V
   88: 'copySize', // Alt+Shift+X
 };
 
 /**
  * Creates the keyboard event handler for the current graph and history.
  */
 EditorUi.prototype.createKeyHandler = function (editor) {
   var editorUi = this;
   var graph = this.editor.graph;
   var keyHandler = new mxKeyHandler(graph);
 
   var isEventIgnored = keyHandler.isEventIgnored;
   keyHandler.isEventIgnored = function (evt) {
     // Handles undo/redo/ctrl+./,/u via action and allows ctrl+b/i only if editing value is HTML (except for FF and Safari)
     return (!this.isControlDown(evt) || mxEvent.isShiftDown(evt) || (evt.keyCode != 90 && evt.keyCode != 89 && evt.keyCode != 188 && evt.keyCode != 190 && evt.keyCode != 85)) && ((evt.keyCode != 66 && evt.keyCode != 73) || !this.isControlDown(evt) || (this.graph.cellEditor.isContentEditing() && !mxClient.IS_FF && !mxClient.IS_SF)) && isEventIgnored.apply(this, arguments);
   };
 
   // Ignores graph enabled state but not view mode state
   keyHandler.isEnabledForEvent = function (evt) {
     return !mxEvent.isConsumed(evt) && this.isGraphEvent(evt) && this.isEnabled() && (editorUi.dialogs == null || editorUi.dialogs.length == 0);
   };
 
   // Routes command-key to control-key on Mac
   keyHandler.isControlDown = function (evt) {
     return mxEvent.isControlDown(evt) || (mxClient.IS_MAC && evt.metaKey);
   };
 
   var queue = [];
   var thread = null;
 
   // Helper function to move cells with the cursor keys
   function nudge(keyCode, stepSize, resize) {
     queue.push(function () {
       if (!graph.isSelectionEmpty() && graph.isEnabled()) {
         stepSize = stepSize != null ? stepSize : 1;
 
         if (resize) {
           // Resizes all selected vertices
           graph.getModel().beginUpdate();
           try {
             var cells = graph.getSelectionCells();
 
             for (var i = 0; i < cells.length; i++) {
               if (graph.getModel().isVertex(cells[i]) && graph.isCellResizable(cells[i])) {
                 var geo = graph.getCellGeometry(cells[i]);
 
                 if (geo != null) {
                   geo = geo.clone();
 
                   if (keyCode == 37) {
                     geo.width = Math.max(0, geo.width - stepSize);
                   } else if (keyCode == 38) {
                     geo.height = Math.max(0, geo.height - stepSize);
                   } else if (keyCode == 39) {
                     geo.width += stepSize;
                   } else if (keyCode == 40) {
                     geo.height += stepSize;
                   }
 
                   graph.getModel().setGeometry(cells[i], geo);
                 }
               }
             }
           } finally {
             graph.getModel().endUpdate();
           }
         } else {
           // Moves vertices up/down in a stack layout
           var cell = graph.getSelectionCell();
           var parent = graph.model.getParent(cell);
           var layout = null;
 
           if (graph.getSelectionCount() == 1 && graph.model.isVertex(cell) && graph.layoutManager != null && !graph.isCellLocked(cell)) {
             layout = graph.layoutManager.getLayout(parent);
           }
 
           if (layout != null && layout.constructor == mxStackLayout) {
             var index = parent.getIndex(cell);
 
             if (keyCode == 37 || keyCode == 38) {
               graph.model.add(parent, cell, Math.max(0, index - 1));
             } else if (keyCode == 39 || keyCode == 40) {
               graph.model.add(parent, cell, Math.min(graph.model.getChildCount(parent), index + 1));
             }
           } else {
             var dx = 0;
             var dy = 0;
 
             if (keyCode == 37) {
               dx = -stepSize;
             } else if (keyCode == 38) {
               dy = -stepSize;
             } else if (keyCode == 39) {
               dx = stepSize;
             } else if (keyCode == 40) {
               dy = stepSize;
             }
 
             graph.moveCells(graph.getMovableCells(graph.getSelectionCells()), dx, dy);
           }
         }
       }
     });
 
     if (thread != null) {
       window.clearTimeout(thread);
     }
 
     thread = window.setTimeout(function () {
       if (queue.length > 0) {
         graph.getModel().beginUpdate();
         try {
           for (var i = 0; i < queue.length; i++) {
             queue[i]();
           }
 
           queue = [];
         } finally {
           graph.getModel().endUpdate();
         }
         graph.scrollCellToVisible(graph.getSelectionCell());
       }
     }, 200);
   }
 
   // Overridden to handle special alt+shift+cursor keyboard shortcuts
   var directions = { 37: mxConstants.DIRECTION_WEST, 38: mxConstants.DIRECTION_NORTH, 39: mxConstants.DIRECTION_EAST, 40: mxConstants.DIRECTION_SOUTH };
 
   var keyHandlerGetFunction = keyHandler.getFunction;
   mxKeyHandler.prototype.getFunction = function (evt) {
     if (graph.isEnabled()) {
       // TODO: Add alt modified state in core API, here are some specific cases
       if (mxEvent.isShiftDown(evt) && mxEvent.isAltDown(evt)) {
         var action = editorUi.actions.get(editorUi.altShiftActions[evt.keyCode]);
 
         if (action != null) {
           return action.funct;
         }
       }
 
       if (evt.keyCode == 9 && mxEvent.isAltDown(evt)) {
         if (mxEvent.isShiftDown(evt)) {
           // Alt+Shift+Tab
           return function () {
             graph.selectParentCell();
           };
         } else {
           // Alt+Tab
           return function () {
             graph.selectChildCell();
           };
         }
       } else if (directions[evt.keyCode] != null && !graph.isSelectionEmpty()) {
         // On macOS, Control+Cursor is used by Expose so allow for Alt+Control to resize
         if (!this.isControlDown(evt) && mxEvent.isShiftDown(evt) && mxEvent.isAltDown(evt)) {
           if (graph.model.isVertex(graph.getSelectionCell())) {
             return function () {
               var cells = graph.connectVertex(graph.getSelectionCell(), directions[evt.keyCode], graph.defaultEdgeLength, evt, true);
 
               if (cells != null && cells.length > 0) {
                 if (cells.length == 1 && graph.model.isEdge(cells[0])) {
                   graph.setSelectionCell(graph.model.getTerminal(cells[0], false));
                 } else {
                   graph.setSelectionCell(cells[cells.length - 1]);
                 }
 
                 graph.scrollCellToVisible(graph.getSelectionCell());
 
                 if (editorUi.hoverIcons != null) {
                   editorUi.hoverIcons.update(graph.view.getState(graph.getSelectionCell()));
                 }
               }
             };
           }
         } else {
           // Avoids consuming event if no vertex is selected by returning null below
           // Cursor keys move and resize (ctrl) cells
           if (this.isControlDown(evt)) {
             return function () {
               nudge(evt.keyCode, mxEvent.isShiftDown(evt) ? graph.gridSize : null, true);
             };
           } else {
             return function () {
               nudge(evt.keyCode, mxEvent.isShiftDown(evt) ? graph.gridSize : null);
             };
           }
         }
       }
     }
 
     return keyHandlerGetFunction.apply(this, arguments);
   };
 
   // Binds keystrokes to actions
   keyHandler.bindAction = mxUtils.bind(this, function (code, control, key, shift) {
     var action = this.actions.get(key);
 
     if (action != null) {
       var f = function (evt) {
         if (action.isEnabled()) {
           action.funct(evt);
         }
       };
 
       if (control) {
         if (shift) {
           keyHandler.bindControlShiftKey(code, f);
         } else {
           keyHandler.bindControlKey(code, f);
         }
       } else {
         if (shift) {
           keyHandler.bindShiftKey(code, f);
         } else {
           keyHandler.bindKey(code, f);
         }
       }
     }
   });
 
   var ui = this;
   var keyHandlerEscape = keyHandler.escape;
   keyHandler.escape = function (evt) {
     keyHandlerEscape.apply(this, arguments);
   };
 
   // Ignores enter keystroke. Remove this line if you want the
   // enter keystroke to stop editing. N, W, T are reserved.
   keyHandler.enter = function () {};
 
   keyHandler.bindControlShiftKey(36, function () {
     graph.exitGroup();
   }); // Ctrl+Shift+Home
   keyHandler.bindControlShiftKey(35, function () {
     graph.enterGroup();
   }); // Ctrl+Shift+End
   keyHandler.bindKey(36, function () {
     graph.home();
   }); // Home
   keyHandler.bindKey(35, function () {
     graph.refresh();
   }); // End
   keyHandler.bindAction(107, true, 'zoomIn'); // Ctrl+Plus
   keyHandler.bindAction(109, true, 'zoomOut'); // Ctrl+Minus
   keyHandler.bindAction(80, true, 'print'); // Ctrl+P
   keyHandler.bindAction(79, true, 'outline', true); // Ctrl+Shift+O
   keyHandler.bindAction(88, true, 'bindings', true); // Ctrl+Shift+X
 
   if (!this.editor.isViewMode()) {
     keyHandler.bindControlKey(36, function () {
       if (graph.isEnabled()) {
         graph.foldCells(true);
       }
     }); // Ctrl+Home
     keyHandler.bindControlKey(35, function () {
       if (graph.isEnabled()) {
         graph.foldCells(false);
       }
     }); // Ctrl+End
     keyHandler.bindControlKey(13, function () {
       if (graph.isEnabled()) {
         graph.setSelectionCells(graph.duplicateCells(graph.getSelectionCells(), false));
       }
     }); // Ctrl+Enter
     keyHandler.bindAction(8, false, 'delete'); // Backspace
     keyHandler.bindAction(8, true, 'deleteAll'); // Backspace
     keyHandler.bindAction(46, false, 'delete'); // Delete
     keyHandler.bindAction(46, true, 'deleteAll'); // Ctrl+Delete
     keyHandler.bindAction(72, true, 'resetView'); // Ctrl+H
     keyHandler.bindAction(72, true, 'fitWindow', true); // Ctrl+Shift+H
     keyHandler.bindAction(74, true, 'fitPage'); // Ctrl+J
     keyHandler.bindAction(74, true, 'fitTwoPages', true); // Ctrl+Shift+J
     keyHandler.bindAction(48, true, 'customZoom'); // Ctrl+0
     keyHandler.bindAction(82, true, 'turn'); // Ctrl+R
     keyHandler.bindAction(82, true, 'clearDefaultStyle', true); // Ctrl+Shift+R
     keyHandler.bindAction(83, true, 'save'); // Ctrl+S
     keyHandler.bindAction(83, true, 'saveAs', true); // Ctrl+Shift+S
     keyHandler.bindAction(65, true, 'selectAll'); // Ctrl+A
     keyHandler.bindAction(65, true, 'selectNone', true); // Ctrl+A
     keyHandler.bindAction(73, true, 'selectVertices', true); // Ctrl+Shift+I
     keyHandler.bindAction(69, true, 'selectEdges', true); // Ctrl+Shift+E
     keyHandler.bindAction(69, true, 'editStyle'); // Ctrl+E
     keyHandler.bindAction(66, true, 'bold'); // Ctrl+B
     keyHandler.bindAction(66, true, 'toBack', true); // Ctrl+Shift+B
     keyHandler.bindAction(70, true, 'toFront', true); // Ctrl+Shift+F
     keyHandler.bindAction(68, true, 'duplicate'); // Ctrl+D
     keyHandler.bindAction(68, true, 'setAsDefaultStyle', true); // Ctrl+Shift+D
     keyHandler.bindAction(90, true, 'undo'); // Ctrl+Z
     keyHandler.bindAction(89, true, 'autosize', true); // Ctrl+Shift+Y
     keyHandler.bindAction(88, true, 'cut'); // Ctrl+X
     keyHandler.bindAction(67, true, 'copy'); // Ctrl+C
     keyHandler.bindAction(86, true, 'paste'); // Ctrl+V
     keyHandler.bindAction(71, true, 'group'); // Ctrl+G
     keyHandler.bindAction(77, true, 'editData'); // Ctrl+M
     keyHandler.bindAction(78, false, 'new', true); // Shift+N
     keyHandler.bindAction(79, false, 'open', true); // Shift+O
     keyHandler.bindAction(71, true, 'grid', true); // Ctrl+Shift+G
     keyHandler.bindAction(73, true, 'italic'); // Ctrl+I
     keyHandler.bindAction(76, true, 'lockUnlock'); // Ctrl+L
     keyHandler.bindAction(76, true, 'layers', true); // Ctrl+Shift+L
     keyHandler.bindAction(80, true, 'formatPanel', true); // Ctrl+Shift+P
     keyHandler.bindAction(85, true, 'underline'); // Ctrl+U
     keyHandler.bindAction(85, true, 'ungroup', true); // Ctrl+Shift+U
     keyHandler.bindAction(190, true, 'superscript'); // Ctrl+.
     keyHandler.bindAction(188, true, 'subscript'); // Ctrl+,
     keyHandler.bindKey(13, function () {
       if (graph.isEnabled()) {
         graph.startEditingAtCell();
       }
     }); // Enter
     keyHandler.bindKey(113, function () {
       if (graph.isEnabled()) {
         graph.startEditingAtCell();
       }
     }); // F2
 
     if (!mxClient.IS_WIN) {
       keyHandler.bindAction(90, true, 'redo', true); // Ctrl+Shift+Z
     } else {
       keyHandler.bindAction(89, true, 'redo'); // Ctrl+Y
     }
   }
 
   return keyHandler;
 };
 
 EditorUi.prototype.destroy = function () {
   if (this.editor != null) {
     this.editor.destroy();
     this.editor = null;
   }
 
   if (this.menubar != null) {
     this.menubar.destroy();
     this.menubar = null;
   }
 
   if (this.toolbar != null) {
     this.toolbar.destroy();
     this.toolbar = null;
   }
 
   if (this.sidebar != null) {
     this.sidebar.destroy();
     this.sidebar = null;
   }
 
   if (this.keyHandler != null) {
     this.keyHandler.destroy();
     this.keyHandler = null;
   }
 
   if (this.keydownHandler != null) {
     mxEvent.removeListener(document, 'keydown', this.keydownHandler);
     this.keydownHandler = null;
   }
 
   if (this.keyupHandler != null) {
     mxEvent.removeListener(document, 'keyup', this.keyupHandler);
     this.keyupHandler = null;
   }
 
   if (this.resizeHandler != null) {
     mxEvent.removeListener(window, 'resize', this.resizeHandler);
     this.resizeHandler = null;
   }
 
   if (this.gestureHandler != null) {
     mxEvent.removeGestureListeners(document, this.gestureHandler);
     this.gestureHandler = null;
   }
 
   if (this.orientationChangeHandler != null) {
     mxEvent.removeListener(window, 'orientationchange', this.orientationChangeHandler);
     this.orientationChangeHandler = null;
   }
 
   if (this.scrollHandler != null) {
     mxEvent.removeListener(window, 'scroll', this.scrollHandler);
     this.scrollHandler = null;
   }
  
   if (this.viewHandler != null) {
     this.viewHandler.destroy();
     this.viewHandler = null;
   }
 
   if (this.destroyFunctions != null) {
     for (var i = 0; i < this.destroyFunctions.length; i++) this.destroyFunctions[i]();
 
     this.destroyFunctions = null;
   }
 
   var c = [this.menubarContainer, this.toolbarContainer, this.diagramContainer, this.layersDialog];
   for (var i = 0; i < c.length; i++) {
     if (c[i] != null && c[i].parentNode != null) c[i].parentNode.removeChild(c[i]);
   }
 };
 
 // export { ChangePageSetup };

 //Menus.js

 
// import * as mxgraph from 'mxgraph';
// import Editor from './Editor'
// import { ColorDialog, FilenameDialog } from './Dialogs'
// import EditorUi from './EditorUi'
// let { 
//     mxClient, 
//     mxUtils, 
//     mxResources, 
//     mxConstants,
//     mxEvent,
//     mxEdgeHandler,
//     mxPopupMenu,
//     mxEventObject,
//     mxMouseEvent,
//     mxEventSource,
// } = mxgraph();

/**
 * Constructs a new graph menu
 */
//export default function Menus (editorUi) {

function Menus (editorUi) {
    this.editorUi = editorUi;
    this.menus = new Object();
    this.init();
  };
  
  /**
   * Sets the default font family.
   */
  Menus.prototype.defaultFont = mxConstants.DEFAULT_FONTFAMILY;
  
  /**
   * Sets the default font size.
   */
  Menus.prototype.defaultFontSize = '12';
  
  /**
   * Sets the default font size.
   */
  Menus.prototype.defaultMenuItems = ['file', 'edit', 'view', 'arrange', 'extras'];
  
  /**
   * Adds the label menu items to the given menu and parent.
   */
  Menus.prototype.defaultFonts = ['PT Sans', 'Tahoma', 'Arial', 'Helvetica', 'Times New Roman', 'Verdana', 'Courier New', 'Lucida Console'];
  /**
   * Adds the label menu items to the given menu and parent.
   */
  Menus.prototype.init = function () {
    var graph = this.editorUi.editor.graph;
    var isGraphEnabled = mxUtils.bind(graph, graph.isEnabled);
  
    this.customFonts = [];
    this.customFontSizes = [];
  
    this.put(
      'fontFamily',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          var addItem = mxUtils.bind(this, function (fontname) {
            var tr = this.styleChange(
              menu,
              fontname,
              [mxConstants.STYLE_FONTFAMILY],
              [fontname],
              null,
              parent,
              function () {
                document.execCommand('fontname', false, fontname);
              },
              function () {
                graph.updateLabelElements(graph.getSelectionCells(), function (elt) {
                  elt.removeAttribute('face');
                  elt.style.fontFamily = null;
  
                  if (elt.nodeName == 'PRE') {
                    graph.replaceElement(elt, 'div');
                  }
                });
              }
            );
            tr.firstChild.nextSibling.style.fontFamily = fontname;
          });
  
          for (var i = 0; i < this.defaultFonts.length; i++) {
            addItem(this.defaultFonts[i]);
          }
  
          menu.addSeparator(parent);
  
          if (this.customFonts.length > 0) {
            for (var i = 0; i < this.customFonts.length; i++) addItem(this.customFonts[i]);
  
            menu.addSeparator(parent);
            menu.addItem(
              mxResources.get('reset'),
              null,
              mxUtils.bind(this, function () {
                this.customFonts = [];
                this.editorUi.fireEvent(new mxEventObject('customFontsChanged'));
              }),
              parent
            );
  
            menu.addSeparator(parent);
          }
  
          this.promptChange(
            menu,
            mxResources.get('custom') + '...',
            '',
            mxConstants.DEFAULT_FONTFAMILY,
            mxConstants.STYLE_FONTFAMILY,
            parent,
            true,
            mxUtils.bind(this, function (newValue) {
              if (mxUtils.indexOf(this.customFonts, newValue) < 0) {
                this.customFonts.push(newValue);
                this.editorUi.fireEvent(new mxEventObject('customFontsChanged'));
              }
            })
          );
        })
      )
    );
    this.put(
      'formatBlock',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          function addItem(label, tag) {
            return menu.addItem(
              label,
              null,
              mxUtils.bind(this, function () {
                // TODO: Check if visible
                if (graph.cellEditor.textarea != null) {
                  graph.cellEditor.textarea.focus();
                  document.execCommand('formatBlock', false, '<' + tag + '>');
                }
              }),
              parent
            );
          }
  
          addItem(mxResources.get('normal'), 'p');
  
          addItem('', 'h1').firstChild.nextSibling.innerHTML = '<h1 style="margin:0px;">' + mxResources.get('heading') + ' 1</h1>';
          addItem('', 'h2').firstChild.nextSibling.innerHTML = '<h2 style="margin:0px;">' + mxResources.get('heading') + ' 2</h2>';
          addItem('', 'h3').firstChild.nextSibling.innerHTML = '<h3 style="margin:0px;">' + mxResources.get('heading') + ' 3</h3>';
          addItem('', 'h4').firstChild.nextSibling.innerHTML = '<h4 style="margin:0px;">' + mxResources.get('heading') + ' 4</h4>';
          addItem('', 'h5').firstChild.nextSibling.innerHTML = '<h5 style="margin:0px;">' + mxResources.get('heading') + ' 5</h5>';
          addItem('', 'h6').firstChild.nextSibling.innerHTML = '<h6 style="margin:0px;">' + mxResources.get('heading') + ' 6</h6>';
  
          addItem('', 'pre').firstChild.nextSibling.innerHTML = '<pre style="margin:0px;">' + mxResources.get('formatted') + '</pre>';
          addItem('', 'blockquote').firstChild.nextSibling.innerHTML = '<blockquote style="margin-top:0px;margin-bottom:0px;">' + mxResources.get('blockquote') + '</blockquote>';
        })
      )
    );
    this.put(
      'fontSize',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          var sizes = [6, 8, 9, 10, 11, 12, 14, 18, 24, 36, 48, 72];
  
          var addItem = mxUtils.bind(this, function (fontsize) {
            this.styleChange(menu, fontsize, [mxConstants.STYLE_FONTSIZE], [fontsize], null, parent, function () {
              if (graph.cellEditor.textarea != null) {
                // Creates an element with arbitrary size 3
                document.execCommand('fontSize', false, '3');
  
                // Changes the css font size of the first font element inside the in-place editor with size 3
                // hopefully the above element that we've just created. LATER: Check for new element using
                // previous result of getElementsByTagName (see other actions)
                var elts = graph.cellEditor.textarea.getElementsByTagName('font');
  
                for (var i = 0; i < elts.length; i++) {
                  if (elts[i].getAttribute('size') == '3') {
                    elts[i].removeAttribute('size');
                    elts[i].style.fontSize = fontsize + 'px';
  
                    break;
                  }
                }
              }
            });
          });
  
          for (var i = 0; i < sizes.length; i++) {
            addItem(sizes[i]);
          }
  
          menu.addSeparator(parent);
  
          if (this.customFontSizes.length > 0) {
            for (var i = 0; i < this.customFontSizes.length; i++) {
              addItem(this.customFontSizes[i]);
            }
  
            menu.addSeparator(parent);
  
            menu.addItem(
              mxResources.get('reset'),
              null,
              mxUtils.bind(this, function () {
                this.customFontSizes = [];
              }),
              parent
            );
  
            menu.addSeparator(parent);
          }
  
          this.promptChange(
            menu,
            mxResources.get('custom') + '...',
            '',
            '12',
            mxConstants.STYLE_FONTSIZE,
            parent,
            true,
            mxUtils.bind(this, function (newValue) {
              this.customFontSizes.push(newValue);
            })
          );
        })
      )
    );
    this.put(
      'direction',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          menu.addItem(
            mxResources.get('flipH'),
            null,
            function () {
              graph.toggleCellStyles(mxConstants.STYLE_FLIPH, false);
            },
            parent
          );
          menu.addItem(
            mxResources.get('flipV'),
            null,
            function () {
              graph.toggleCellStyles(mxConstants.STYLE_FLIPV, false);
            },
            parent
          );
          this.addMenuItems(menu, ['-', 'rotation'], parent);
        })
      )
    );
    this.put(
      'align',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          menu.addItem(
            mxResources.get('leftAlign'),
            null,
            function () {
              graph.alignCells(mxConstants.ALIGN_LEFT);
            },
            parent
          );
          menu.addItem(
            mxResources.get('centerAlign'),
            null,
            function () {
              graph.alignCells(mxConstants.ALIGN_CENTER);
            },
            parent
          );
          menu.addItem(
            mxResources.get('rightAlign'),
            null,
            function () {
              graph.alignCells(mxConstants.ALIGN_RIGHT);
            },
            parent
          );
          menu.addSeparator(parent);
          menu.addItem(
            mxResources.get('topAlign'),
            null,
            function () {
              graph.alignCells(mxConstants.ALIGN_TOP);
            },
            parent
          );
          menu.addItem(
            mxResources.get('middleAlign'),
            null,
            function () {
              graph.alignCells(mxConstants.ALIGN_MIDDLE);
            },
            parent
          );
          menu.addItem(
            mxResources.get('bottomAlign'),
            null,
            function () {
              graph.alignCells(mxConstants.ALIGN_BOTTOM);
            },
            parent
          );
        })
      )
    );
    this.put(
      'distribute',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          menu.addItem(
            mxResources.get('horizontal'),
            null,
            function () {
              graph.distributeCells(true);
            },
            parent
          );
          menu.addItem(
            mxResources.get('vertical'),
            null,
            function () {
              graph.distributeCells(false);
            },
            parent
          );
        })
      )
    );
    this.put(
      'navigation',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          this.addMenuItems(menu, [/*'home', '-', 'exitGroup', 'enterGroup', '-', */ 'expand', 'collapse', '-', 'collapsible'], parent);
        })
      )
    );
    this.put(
      'arrange',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          this.addMenuItems(menu, ['toFront', 'toBack', '-'], parent);
          this.addSubmenu('direction', menu, parent);
          this.addMenuItems(menu, ['turn', '-'], parent);
          this.addSubmenu('align', menu, parent);
          this.addSubmenu('distribute', menu, parent);
          menu.addSeparator(parent);
          this.addSubmenu('navigation', menu, parent);
          this.addSubmenu('insert', menu, parent);
          //this.addSubmenu('layout', menu, parent);
          this.addMenuItems(menu, ['-', 'group', 'ungroup', 'removeFromGroup', '-', 'clearWaypoints', 'autosize'], parent);
        })
      )
    ).isEnabled = isGraphEnabled;
    this.put(
      'insert',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          this.addMenuItems(menu, ['insertLink', 'insertImage'], parent);
        })
      )
    );
    this.put(
      'view',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          this.addMenuItems(menu, ['sidebarPanel', 'formatPanel', 'outline', 'layers', 'bindings', '-', 'pageView', 'pageScale', '-', 'scrollbars', 'tooltips', '-', 'grid', 'guides', '-', 'connectionArrows', 'connectionPoints', '-', 'resetView', 'zoomIn', 'zoomOut'], parent);
        })
      )
    );
    // Two special dropdowns that are only used in the toolbar
    this.put(
      'viewPanels',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          this.addMenuItems(menu, ['sidebarPanel', 'formatPanel', 'outline', 'layers', 'bindings'], parent, null, null);
        })
      )
    );
    this.put(
      'viewZoom',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          this.addMenuItems(menu, ['resetView', '-'], parent);
          var scales = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2, 3, 4];
  
          for (var i = 0; i < scales.length; i++) {
            (function (scale) {
              menu.addItem(
                scale * 100 + '%',
                null,
                function () {
                  graph.zoomTo(scale);
                },
                parent
              );
            })(scales[i]);
          }
  
          this.addMenuItems(menu, ['-', 'fitWindow', 'fitPageWidth', 'fitPage', 'fitTwoPages', '-', 'customZoom'], parent);
        })
      )
    );
    this.put(
      'file',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          this.addMenuItems(menu, ['new', 'open', '-', 'save', 'saveAs', '-', /*'import',*/ 'export', '-', 'pageSetup', 'print'], parent);
        })
      )
    );
    this.put(
      'edit',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          this.addMenuItems(menu, ['undo', 'redo', '-', 'cut', 'copy', 'paste', 'delete', '-', 'duplicate', '-', 'editData', 'editTooltip', 'editStyle', '-', 'edit', '-', 'editLink', 'openLink', '-', 'selectVertices', 'selectEdges', 'selectAll', 'selectNone', '-', 'lockUnlock']);
        })
      )
    );
    this.put(
      'extras',
      new Menu(
        mxUtils.bind(this, function (menu, parent) {
          this.addMenuItems(menu, ['autosave', /*'copyConnect', 'collapseExpand',*/ '-', 'editDiagram']);
        })
      )
    );
  };
  
  /**
   * Adds the label menu items to the given menu and parent.
   */
  Menus.prototype.put = function (name, menu) {
    this.menus[name] = menu;
  
    return menu;
  };
  
  /**
   * Adds the label menu items to the given menu and parent.
   */
  Menus.prototype.get = function (name) {
    return this.menus[name];
  };
  
  /**
   * Adds the given submenu.
   */
  Menus.prototype.addSubmenu = function (name, menu, parent, label) {
    var entry = this.get(name);
  
    if (entry != null) {
      var enabled = entry.isEnabled();
  
      if (menu.showDisabled || enabled) {
        var submenu = menu.addItem(label || mxResources.get(name), null, null, parent, null, enabled);
        this.addMenu(name, menu, submenu);
      }
    }
  };
  
  /**
   * Adds the label menu items to the given menu and parent.
   */
  Menus.prototype.addMenu = function (name, popupMenu, parent) {
    var menu = this.get(name);
  
    if (menu != null && (popupMenu.showDisabled || menu.isEnabled())) {
      this.get(name).execute(popupMenu, parent);
    }
  };
  
  /**
   * Adds a menu item to insert a table.
   */
  Menus.prototype.addInsertTableItem = function (menu) {
    var graph = this.editorUi.editor.graph;
  
    function createTable(rows, cols) {
      var html = ['<table>'];
  
      for (var i = 0; i < rows; i++) {
        html.push('<tr>');
  
        for (var j = 0; j < cols; j++) {
          html.push('<td><br></td>');
        }
  
        html.push('</tr>');
      }
  
      html.push('</table>');
  
      return html.join('');
    }
  
    // Show table size dialog
    var elt2 = menu.addItem(
      '',
      null,
      mxUtils.bind(this, function (evt) {
        var td = graph.getParentByName(mxEvent.getSource(evt), 'TD');
  
        if (td != null && graph.cellEditor.textarea != null) {
          var row2 = graph.getParentByName(td, 'TR');
  
          // To find the new link, we create a list of all existing links first
          // LATER: Refactor for reuse with code for finding inserted image below
          var tmp = graph.cellEditor.textarea.getElementsByTagName('table');
          var oldTables = [];
  
          for (var i = 0; i < tmp.length; i++) {
            oldTables.push(tmp[i]);
          }
  
          // Finding the new table will work with insertHTML, but IE does not support that
          graph.container.focus();
          graph.pasteHtmlAtCaret(createTable(row2.sectionRowIndex + 1, td.cellIndex + 1));
  
          // Moves cursor to first table cell
          var newTables = graph.cellEditor.textarea.getElementsByTagName('table');
  
          if (newTables.length == oldTables.length + 1) {
            // Inverse order in favor of appended tables
            for (var i = newTables.length - 1; i >= 0; i--) {
              if (i == 0 || newTables[i] != oldTables[i - 1]) {
                graph.selectNode(newTables[i].rows[0].cells[0]);
                break;
              }
            }
          }
        }
      })
    );
  
    function createPicker(rows, cols) {
      var table2 = document.createElement('table');
      table2.setAttribute('border', '1');
      table2.style.borderCollapse = 'collapse';
      table2.setAttribute('cellPadding', '8');
  
      for (var i = 0; i < rows; i++) {
        var row = table2.insertRow(i);
        for (var j = 0; j < cols; j++) row.insertCell(-1);
      }
  
      return table2;
    }
    function extendPicker(picker, rows, cols) {
      for (var i = picker.rows.length; i < rows; i++) {
        var row = picker.insertRow(i);
        for (var j = 0; j < picker.rows[0].cells.length; j++) row.insertCell(-1);
      }
      for (var i = 0; i < picker.rows.length; i++) {
        var row = picker.rows[i];
        for (var j = row.cells.length; j < cols; j++) row.insertCell(-1);
      }
    }
  
    elt2.firstChild.innerHTML = '';
    var picker = createPicker(5, 5);
    elt2.firstChild.appendChild(picker);
  
    var label = document.createElement('div');
    label.style.padding = '4px';
    label.style.fontSize = Menus.prototype.defaultFontSize + 'px';
    label.innerHTML = '1x1';
    elt2.firstChild.appendChild(label);
  
    mxEvent.addListener(picker, 'mouseover', function (e) {
      var td = graph.getParentByName(mxEvent.getSource(e), 'TD');
      if (td != null) {
        var row2 = graph.getParentByName(td, 'TR');
        extendPicker(picker, Math.min(20, row2.sectionRowIndex + 2), Math.min(20, td.cellIndex + 2));
        label.innerHTML = td.cellIndex + 1 + 'x' + (row2.sectionRowIndex + 1);
  
        for (var i = 0; i < picker.rows.length; i++) {
          var r = picker.rows[i];
  
          for (var j = 0; j < r.cells.length; j++) {
            var cell = r.cells[j];
  
            if (i <= row2.sectionRowIndex && j <= td.cellIndex) {
              cell.style.backgroundColor = 'blue';
            } else {
              cell.style.backgroundColor = 'white';
            }
          }
        }
  
        mxEvent.consume(e);
      }
    });
  };
  
  /**
   * Adds a style change item to the given menu.
   */
  Menus.prototype.edgeStyleChange = function (menu, label, keys, values, sprite, parent, reset) {
    return menu.addItem(
      label,
      null,
      mxUtils.bind(this, function () {
        var graph = this.editorUi.editor.graph;
        graph.stopEditing(false);
  
        graph.getModel().beginUpdate();
        try {
          var cells = graph.getSelectionCells();
          var edges = [];
  
          for (var i = 0; i < cells.length; i++) {
            var cell = cells[i];
  
            if (graph.getModel().isEdge(cell)) {
              if (reset) {
                var geo = graph.getCellGeometry(cell);
  
                // Resets all edge points
                if (geo != null) {
                  geo = geo.clone();
                  geo.points = null;
                  graph.getModel().setGeometry(cell, geo);
                }
              }
  
              for (var j = 0; j < keys.length; j++) {
                graph.setCellStyles(keys[j], values[j], [cell]);
              }
  
              edges.push(cell);
            }
          }
  
          this.editorUi.fireEvent(new mxEventObject('styleChanged', 'keys', keys, 'values', values, 'cells', edges));
        } finally {
          graph.getModel().endUpdate();
        }
      }),
      parent,
      sprite
    );
  };
  
  /**
   * Adds a style change item to the given menu.
   */
  Menus.prototype.styleChange = function (menu, label, keys, values, sprite, parent, fn, post) {
    var apply = this.createStyleChangeFunction(keys, values);
  
    return menu.addItem(
      label,
      null,
      mxUtils.bind(this, function () {
        var graph = this.editorUi.editor.graph;
  
        if (fn != null && graph.cellEditor.isContentEditing()) {
          fn();
        } else {
          apply(post);
        }
      }),
      parent,
      sprite
    );
  };
  
  Menus.prototype.createStyleChangeFunction = function (keys, values) {
    return mxUtils.bind(this, function (post) {
      var graph = this.editorUi.editor.graph;
      graph.stopEditing(false);
  
      graph.getModel().beginUpdate();
      try {
        for (var i = 0; i < keys.length; i++) {
          graph.setCellStyles(keys[i], values[i]);
  
          // Removes CSS alignment to produce consistent output
          if (keys[i] == mxConstants.STYLE_ALIGN) {
            graph.updateLabelElements(graph.getSelectionCells(), function (elt) {
              elt.removeAttribute('align');
              elt.style.textAlign = null;
            });
          }
        }
  
        if (post != null) {
          post();
        }
  
        this.editorUi.fireEvent(new mxEventObject('styleChanged', 'keys', keys, 'values', values, 'cells', graph.getSelectionCells()));
      } finally {
        graph.getModel().endUpdate();
      }
    });
  };
  
  /**
   * Adds a style change item with a prompt to the given menu.
   */
  Menus.prototype.promptChange = function (menu, label, hint, defaultValue, key, parent, enabled, fn, sprite) {
    return menu.addItem(
      label,
      null,
      mxUtils.bind(this, function () {
        var graph = this.editorUi.editor.graph;
        var value = defaultValue;
        var state = graph.getView().getState(graph.getSelectionCell());
  
        if (state != null) {
          value = state.style[key] || value;
        }
  
        var dlg = new FilenameDialog(
          this.editorUi,
          value,
          mxResources.get('apply'),
          mxUtils.bind(this, function (newValue) {
            if (newValue != null && newValue.length > 0) {
              graph.getModel().beginUpdate();
              try {
                graph.stopEditing(false);
                graph.setCellStyles(key, newValue);
              } finally {
                graph.getModel().endUpdate();
              }
  
              if (fn != null) {
                fn(newValue);
              }
            }
          }),
          mxResources.get('enterValue') + (hint.length > 0 ? ' ' + hint : '')
        );
        this.editorUi.showDialog(dlg.container, 300, 80, true, true);
        dlg.init();
      }),
      parent,
      sprite,
      enabled
    );
  };
  
  /**
   * Adds a handler for showing a menu in the given element.
   */
  Menus.prototype.pickColor = function (key, cmd, defaultValue) {
    var graph = this.editorUi.editor.graph;
    var h = 226 + (Math.ceil(ColorDialog.prototype.presetColors.length / 12) + Math.ceil(ColorDialog.prototype.defaultColors.length / 12)) * 17;
  
    if (cmd != null && graph.cellEditor.isContentEditing()) {
      // Saves and restores text selection for in-place editor
      var selState = graph.cellEditor.saveSelection();
  
      var dlg = new ColorDialog(
        this.editorUi,
        defaultValue || '000000',
        mxUtils.bind(this, function (color) {
          graph.cellEditor.restoreSelection(selState);
          document.execCommand(cmd, false, color != mxConstants.NONE ? color : 'transparent');
        }),
        function () {
          graph.cellEditor.restoreSelection(selState);
        }
      );
      this.editorUi.showDialog(dlg.container, 230, h, true, true);
      dlg.init();
    } else {
      if (this.colorDialog == null) {
        this.colorDialog = new ColorDialog(this.editorUi);
      }
  
      this.colorDialog.currentColorKey = key;
      var state = graph.getView().getState(graph.getSelectionCell());
      var color = 'none';
  
      if (state != null) {
        color = state.style[key] || color;
      }
  
      if (color == 'none') {
        color = 'ffffff';
        this.colorDialog.picker.fromString('ffffff');
        this.colorDialog.colorInput.value = 'none';
      } else {
        this.colorDialog.picker.fromString(color);
      }
  
      this.editorUi.showDialog(this.colorDialog.container, 230, h, true, true);
      this.colorDialog.init();
    }
  };
  
  /**
   * Adds a handler for showing a menu in the given element.
   */
  Menus.prototype.toggleStyle = function (key, defaultValue) {
    var graph = this.editorUi.editor.graph;
    var value = graph.toggleCellStyles(key, defaultValue);
    this.editorUi.fireEvent(new mxEventObject('styleChanged', 'keys', [key], 'values', [value], 'cells', graph.getSelectionCells()));
  };
  
  /**
   * Creates the keyboard event handler for the current graph and history.
   */
  Menus.prototype.addMenuItem = function (menu, key, parent, trigger, sprite, label) {
    var action = this.editorUi.actions.get(key);
  
    if (action != null && (menu.showDisabled || action.isEnabled()) && action.visible) {
      var item = menu.addItem(
        label || action.label,
        null,
        function (evt) {
          action.funct(trigger || evt);
        },
        parent,
        sprite,
        action.isEnabled()
      );
  
      // Adds checkmark image
      if (action.toggleAction && action.isSelected()) menu.addCheckmark(item, Editor.checkmarkImage);
  
      this.addShortcut(item, action);
  
      return item;
    }
    return null;
  };
  
  /**
   * Adds a checkmark to the given menuitem.
   */
  Menus.prototype.addShortcut = function (item, action) {
    if (action.shortcut != null) {
      var td = item.firstChild.nextSibling.nextSibling;
      var span = document.createElement('span');
      span.style.color = 'gray';
      mxUtils.write(span, action.shortcut);
      td.appendChild(span);
    }
  };
  
  Menus.prototype.addMenuItems = function (menu, keys, parent, trigger, sprites) {
    for (var i = 0; i < keys.length; i++) {
      if (keys[i] == '-') {
        menu.addSeparator(parent);
      } else {
        this.addMenuItem(menu, keys[i], parent, trigger, sprites != null ? sprites[i] : null);
      }
    }
  };
  Menus.prototype.createPopupMenu = function (menu, cell, evt, bool) {
    var editor = this.editorUi.editor;
    var graph = editor.graph;
    menu.smartSeparators = true;
  
    if (!editor.isViewMode()) {
      if (graph.isSelectionEmpty()) this.addMenuItems(menu, ['undo', 'redo', 'pasteHere'], null, evt);
      else this.addMenuItems(menu, ['delete', '-', 'cut', 'copy', '-', 'duplicate'], null, evt);
  
      if (!graph.isSelectionEmpty()) {
        if (graph.getSelectionCount() == 1) {
          this.addMenuItems(menu, ['setAsDefaultStyle'], null, evt);
        }
        menu.addSeparator();
  
        cell = graph.getSelectionCell();
        var state = graph.view.getState(cell);
  
        if (state != null) {
          var hasWaypoints = false;
          this.addMenuItems(menu, ['toFront', 'toBack', '-'], null, evt);
  
          if (graph.getModel().isEdge(cell) && mxUtils.getValue(state.style, mxConstants.STYLE_EDGE, null) != mxConstants.EDGESTYLE_ENTITY_RELATION && mxUtils.getValue(state.style, mxConstants.STYLE_SHAPE, null) != 'arrow') {
            var handler = graph.selectionCellsHandler.getHandler(cell);
            var isWaypoint = false;
  
            if (handler instanceof mxEdgeHandler && handler.bends != null && handler.bends.length > 2) {
              //index for longTouch
              let index = null;
  
              if (bool) {
                const abspoints = handler.abspoints;
                let minDistance = Number.MAX_VALUE;
  
                if (handler.currentPoint) {
                  //---fix---//
                  let clickX = handler.currentPoint.x;
                  let clickY = handler.currentPoint.y;
                   //---fix---//
                  // clickX = handler.currentPoint.x;
                  // clickY = handler.currentPoint.y;
  
                  if (clickX && clickY) {
                    for (var i = 0; i < abspoints.length; i++) {
                      const point = abspoints[i];
                      const distance = Math.sqrt(Math.pow(clickX - point.x, 2) + Math.pow(clickY - point.y, 2));
  
                      if (distance < minDistance) {
                        minDistance = distance;
                        index = i;
                      }
                    }
                  }
                }
              } else {
                //index for rightClick
                index = handler.getHandleForEvent(graph.updateMouseEvent(new mxMouseEvent(evt)));
              }
              // Configures removeWaypoint action before execution
              // Using trigger parameter is cleaner but have to find waypoint here anyway.
              var rmWaypointAction = this.editorUi.actions.get('removeWaypoint');
              rmWaypointAction.handler = handler;
              rmWaypointAction.index = index;
              isWaypoint = index > 0 && index < handler.bends.length - 1;
            }
            menu.addSeparator();
            this.addMenuItem(menu, 'turn', null, evt, null, mxResources.get('reverse'));
            this.addMenuItems(menu, [isWaypoint ? 'removeWaypoint' : 'addWaypoint'], null, evt);
  
            // Adds reset waypoints option if waypoints exist
            var geo = graph.getModel().getGeometry(cell);
            hasWaypoints = geo != null && geo.points != null && geo.points.length > 0;
          }
  
          if (graph.getSelectionCount() == 1 && (hasWaypoints || (graph.getModel().isVertex(cell) && graph.getModel().getEdgeCount(cell) > 0))) {
            this.addMenuItems(menu, ['clearWaypoints'], null, evt);
          }
  
          if (graph.getSelectionCount() > 1) {
            menu.addSeparator();
            this.addMenuItems(menu, ['group'], null, evt);
          } else if (graph.getSelectionCount() == 1 && !graph.getModel().isEdge(cell) && !graph.isSwimlane(cell) && graph.getModel().getChildCount(cell) > 0) {
            menu.addSeparator();
            this.addMenuItems(menu, ['ungroup'], null, evt);
          }
  
          if (graph.getSelectionCount() == 1) {
            menu.addSeparator();
            this.addMenuItems(menu, ['editData', 'editLink'], null, evt);
  
            // Shows edit image action if there is an image in the style
            if (graph.getModel().isVertex(cell) && mxUtils.getValue(state.style, mxConstants.STYLE_IMAGE, null) != null) {
              menu.addSeparator();
              this.addMenuItem(menu, 'image', null, evt).firstChild.nextSibling.innerHTML = mxResources.get('editImage') + '...';
            }
  
            //menu.addSeparator();
            //this.addMenuItem(menu, 'bindings', null, evt);
          }
        }
      } else {
        this.addMenuItems(menu, ['-', 'selectVertices', 'selectEdges', 'selectAll', '-', 'clearDefaultStyle', '-', 'editData'], null, evt);
      }
    }
  };
  Menus.prototype.createMenubar = function (container) {
    var menubar = new Menubar(this.editorUi, container);
    var menus = this.defaultMenuItems;
  
    for (var i = 0; i < menus.length; i++) {
      mxUtils.bind(this, function (menu) {
        var elt = menubar.addMenu(
          mxResources.get(menus[i]),
          mxUtils.bind(this, function () {
            // Allows extensions of menu.funct
            menu.funct.apply(this, arguments);
          })
        );
  
        this.menuCreated(menu, elt);
      })(this.get(menus[i]));
    }
  
    return menubar;
  };
  
  /**
   * Creates the keyboard event handler for the current graph and history.
   */
  Menus.prototype.menuCreated = function (menu, elt, className) {
    if (elt != null) {
      className = className != null ? className : 'geItem';
  
      menu.addListener('stateChanged', function () {
        elt.enabled = menu.enabled;
  
        if (!menu.enabled) {
          elt.className = className + ' mxDisabled';
  
          if (document.documentMode == 8) {
            elt.style.color = '#c3c3c3';
          }
        } else {
          elt.className = className;
  
          if (document.documentMode == 8) {
            elt.style.color = '';
          }
        }
      });
    }
  };
  
  /**
   * Construcs a new menubar for the given editor.
   */
  function Menubar(editorUi, container) {
    this.editorUi = editorUi;
    this.container = container;
  }
  
  /**
   * Adds the menubar elements.
   */
  Menubar.prototype.hideMenu = function () {
    this.editorUi.hideCurrentMenu();
  };
  
  /**
   * Adds a submenu to this menubar.
   */
  Menubar.prototype.addMenu = function (label, funct, before) {
    var elt = document.createElement('a');
    elt.className = 'geItem';
    mxUtils.write(elt, label);
    this.addMenuHandler(elt, funct);
  
    if (before != null) {
      this.container.insertBefore(elt, before);
    } else {
      this.container.appendChild(elt);
    }
  
    return elt;
  };
  
  /**
   * Adds a handler for showing a menu in the given element.
   */
  Menubar.prototype.addMenuHandler = function (elt, funct) {
    if (funct != null) {
      var show = true;
  
      var clickHandler = mxUtils.bind(this, function (evt) {
        if ((show && elt.enabled == null) || elt.enabled) {
          this.editorUi.editor.graph.popupMenuHandler.hideMenu();
          var menu = new mxPopupMenu(funct);
          menu.div.className = ' webix_view webix_window webix_popup webix_win_content geMenubarMenu';
          menu.smartSeparators = true;
          menu.showDisabled = true;
          menu.autoExpand = true;
  
          // Disables autoexpand and destroys menu when hidden
          menu.hideMenu = mxUtils.bind(this, function () {
            mxPopupMenu.prototype.hideMenu.apply(menu, arguments);
            this.editorUi.resetCurrentMenu();
            menu.destroy();
          });
  
          var offset = mxUtils.getOffset(elt);
          menu.popup(offset.x, offset.y + elt.offsetHeight, null, evt);
          this.editorUi.setCurrentMenu(menu, elt);
        }
  
        mxEvent.consume(evt);
      });
  
      // Shows menu automatically while in expanded state
      mxEvent.addListener(
        elt,
        'mousemove',
        mxUtils.bind(this, function (evt) {
          if (this.editorUi.currentMenu != null && this.editorUi.currentMenuElt != elt) {
            this.editorUi.hideCurrentMenu();
            clickHandler(evt);
          }
        })
      );
  
      // Hides menu if already showing and prevents focus
      mxEvent.addListener(
        elt,
        mxClient.IS_POINTER ? 'pointerdown' : 'mousedown',
        mxUtils.bind(this, function (evt) {
          show = this.currentElt != elt;
          evt.preventDefault();
        })
      );
  
      mxEvent.addListener(
        elt,
        'click',
        mxUtils.bind(this, function (evt) {
          clickHandler(evt);
          show = true;
        })
      );
    }
  };
  
  /**
   * Creates the keyboard event handler for the current graph and history.
   */
  Menubar.prototype.destroy = function () {
    // do nothing
  };
  
  /**
   * Constructs a new action for the given parameters.
   */
  function Menu(funct, enabled) {
    mxEventSource.call(this);
    this.funct = funct;
    this.enabled = enabled != null ? enabled : true;
  }
  
  // Menu inherits from mxEventSource
  mxUtils.extend(Menu, mxEventSource);
  
  /**
   * Sets the enabled state of the action and fires a stateChanged event.
   */
  Menu.prototype.isEnabled = function () {
    return this.enabled;
  };
  
  /**
   * Sets the enabled state of the action and fires a stateChanged event.
   */
  Menu.prototype.setEnabled = function (value) {
    if (this.enabled != value) {
      this.enabled = value;
      this.fireEvent(new mxEventObject('stateChanged'));
    }
  };
  
  /**
   * Sets the enabled state of the action and fires a stateChanged event.
   */
  Menu.prototype.execute = function (menu, parent) {
    this.funct(menu, parent);
  };
  
  /**
   * "Installs" menus in EditorUi.
   */
  EditorUi.prototype.createMenus = function () {
    return new Menus(this);
  };

  //Init.js

  // import { $ } from 'jquery';
// // import { API } from './scada'
// import { isNullOrEmpty, isDefined } from './client';
// import * as mxgraph from 'mxgraph';
// let { 
    
//     mxGraphModel, 
//     mxClient, 
//     mxUtils, 
//     mxConstants,
//     mxImage,
//     mxEvent,
//     mxPopupMenu,
//     mxConstraintHandler,
//     mxCell,
//     mxWindow,
//     mxObjectCodec,
//     mxCodecRegistry,
//     mxGenericChangeCodec,
// } = mxgraph();


// Workaround for allowing target="_blank" in HTML sanitizer
// see https://code.google.com/p/google-caja/issues/detail?can=2&q=&colspec=ID%20Type%20Status%20Priority%20Owner%20Summary&groupby=&sort=&id=1296
//---fix---//
// if (typeof html4 !== 'undefined')
// {
//     html4.ATTRIBS["a::target"] = 0;
//     html4.ATTRIBS["source::src"] = 0;
//     html4.ATTRIBS["video::src"] = 0;
//     // Would be nice for tooltips but probably a security risk...
//     //html4.ATTRIBS["video::autoplay"]   = 0;
//     //html4.ATTRIBS["video::autobuffer"] = 0;
//// }
//---fix---//
// define API
//---fix---//
// API.FUNC.schemeEqView     = "/equipments/view";
// API.FUNC.schemeExecCmd    = API.PREFIX + "scheme/execCmd";
// API.FUNC.schemeEquipments = API.PREFIX + "scheme/equipments";
//---fix---//
// Fixes possible clipping issues in Chrome
mxClient.NO_FO = true;

// Changes default colors
mxConstants.SHADOW_OPACITY      = 0.5;
mxConstants.SHADOWCOLOR         = '#c0c0c0';
mxConstants.SHADOW_OFFSET_X     = 4;
mxConstants.SHADOW_OFFSET_Y     = 4;
mxConstants.DEFAULT_FONTSIZE    = 14;
mxConstants.DEFAULT_FONTFAMILY  = "'PT Sans'";
mxConstants.EDGESTYLE_ISOMETRIC = 'isometricEdgeStyle';
mxConstants.STYLE_CONNECTABLE   = 'connectable';

mxUtils.errorImage       = 'data:image/gif;base64,R0lGODlhEAAQAPcAAADGAIQAAISEhP8AAP///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////yH5BAEAAAAALAAAAAAQABAAAAhoAAEIFBigYMGBCAkGGMCQ4cGECxtKHBAAYUQCEzFSHLiQgMeGHjEGEAAg4oCQJz86LCkxpEqHAkwyRClxpEyXGmGaREmTIsmOL1GO/DkzI0yOE2sKIMlRJsWhCQHENDiUaVSpS5cmDAgAOw==';
mxUtils.transparentImage = 'data:image/gif;base64,R0lGODlhMAAwAIAAAP///wAAACH5BAEAAAAALAAAAAAwADAAAAIxhI+py+0Po5y02ouz3rz7D4biSJbmiabqyrbuC8fyTNf2jef6zvf+DwwKh8Si8egpAAA7';

mxConstraintHandler.prototype.pointImage = new mxImage('data:image/gif;base64,R0lGODlhBQAFAJECAAAA/////////wAAACH5BAEAAAIALAAAAAAFAAUAAAIIRBSml7yGQAEAOw==', 5, 5);

mxPopupMenu.prototype.zIndex = 100;
mxPopupMenu.prototype.submenuImage = 'data:image/gif;base64,R0lGODlhCQAJAIAAAP///zMzMyH5BAEAAAAALAAAAAAJAAkAAAIPhI8WebHsHopSOVgb26AAADs=';

mxWindow.prototype.closeImage     = 'data:image/gif;base64,R0lGODlhDAAMAIAAAP///0RERCH5BAAAAAAALAAAAAAMAAwAAAIdjI8Hy23w2JtR1bQiVDlIvnVIt3llqKFm4yRuUAAAOw==';
mxWindow.prototype.minimizeImage  = 'data:image/gif;base64,R0lGODlhDAAMAIAAAERERP///yH5BAAAAAAALAAAAAAMAAwAAAIXhI8Xy20Nw4tsUgnuspTHlyhgmHkQGRYAOw==';
mxWindow.prototype.maximizeImage  = 'data:image/gif;base64,R0lGODlhDAAMAPcAAP///0RERAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADAAMAAAIMAADCBxIcCCAgwgTCgRQ0ODChg8DMEx4UOJDihMvUrRoESPHiRsZcmwoEqNCiAUDAgA7';
mxWindow.prototype.normalizeImage = 'data:image/gif;base64,R0lGODlhDAAMAPcAAP///0RERAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAADAAMAAAIMgADCBxIcCCAgwgTCkRYMACAhQcbPnQYUeHEiQQfXmy4sKPFiA4pVgSJ0SDJhCg5NgwIADs=';
mxWindow.prototype.resizeImage    = 'data:image/gif;base64,R0lGODlhDAAMAJECAP///4CAgNTQyAAAACH5BAEAAAIALAAAAAAMAAwAAAIblI8CmRB83IMSqvBWw3dnHnFV+GVGhZZXmaoFADs=';

// custom images
mxConstants.PICTURE_IMAGE = 'data:image/png,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J/AAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QAAKqNIzIAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAHdElNRQfjCw8MAR6ZuReNAAABuElEQVRIx8XVv2sTcRzG8VfkxNbBpbjULqUOLv5a/IGgkwQHJ3WwTWc3oU7iojiJ/0GGqtRChw4qilBQURBcBGk6tVRB0QppUSzUSC/ydUjz45KmzWXxuenueN7Pc5877gM5c2Ih5RErGCGS89CiCWXpFDltkoyCXoeUUtqh15w1YuNdmCsaF0eipvJ9jln3zu8OAGXRjsSFjJu+ee6Fr0Y7K5EEjLnlvVFXLHsg2xkiyNfmuqJgJ9hrxdttvXmhscGAPo/FYNlrR9M+wqpgoAH3My3gh5dyziPjmuOm086A/ZYEnywJPtiTdgYsOuKu7xZcd8pqi+GsKf1bNdhaWSXBgn3tG2ylc54oGjPoVbJFZw2ySr4YwgXrtRZ5IQnoccOBTdP/+Gxw4+yS2Lz+VsAuzwRFB9umV1VtkQD0mBHc86sJkUyv6qLYvKd1QCX9Dk4mEK3pjS1CFVC3SyDa2+sIwYQZwe2GWxXE1U3LN+p+BfC3yV5FhG3stbfQaocTprax1wCPdKuNT7nYNUDzP/H/AMqirt2RcmW1He5ojTRrt4K1jBGTPnrTxXI9Y8gwDJvtar3Pusw/AuXdyJGME8cAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTktMTEtMTVUMTI6MDE6MzArMDA6MDAHdoikAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE5LTExLTE1VDEyOjAxOjMwKzAwOjAwdiswGAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=';
mxConstants.SOUND_IMAGE   = 'data:image/png,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAQAAADZc7J / AAAABGdBTUEAALGPC / xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QAAKqNIzIAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAHdElNRQfjCw8LOjhySWvNAAACKElEQVRIx7WUTUhUURTHf9ZMGNNkoTaUlvWkpdpQaZQLiQirhRRhMBTRRqn1tKqgVYQE0XfkooKiRWAhCIqRJtMDPxYyfdBCEstRM + gDRmZ4mK + Fdy73zXvz3qR07ubc887 / d8 + 53Hfgv1vpcsQbiWEyRFHulBUu8hoGWaCKEE1LATQywFsO8p4EG2T0CmcozAfQQifXiZDOiv + ijXFOuHfu4xYpInKvE1W + FnKBFI9ZlUsepIspdisRnSh + 9ijVVvOVLnxOco0PxKmwxHSiVJNiXKmqgmluLJb7hJCSHEYnQtIGjlPGOdo5QAvzwATHecNzYgWY3GNCpG2lFT9 / ssQ6HVwDoIZuXnJWxO8Tpg5M9snUehYc2lIvcRcGh4S / hXlq3R6Sk41wl8vC / 0I / x6yAUVo9EbeppVL4fdRbAUnaPQFjJKgT / ie0f20BYEo + 7R8ULwWwhjnhBUhmA4o85UG281H45cxYAWEmPQHN / GRY + HsZsgICBDzLv8QdDABWc5heHxBkvSzP3fw8JU2b2J3CpAOSmJZ1xCbLvMRK + pmUb2AdM5wHKEFT1kUMTjoASnlGmh42idhKOonjdyrzNIZlgCwCtvGA / Uorj / gua7FZEymuUmBrIWMafSTY4XZZDfzmoZw4KkDjJnN0s9njutnJN16I + asC3hHjqJc4c9YYr1mbBbCN0tz / wmcaCPGKKsqYlVEjv9MzVswAJoN5 / CEuVrIccR72F6cfjBeeMpVLAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDE5LTExLTE1VDExOjU4OjU2KzAwOjAwkkFfXwAAACV0RVh0ZGF0ZTptb2RpZnkAMjAxOS0xMS0xNVQxMTo1ODo1NiswMDowMOMc5 + MAAAAZdEVYdFNvZnR3YXJlAHd3dy5pbmtzY2FwZS5vcmeb7jwaAAAAAElFTkSuQmCC';
mxConstants.BLOCKED_IMAGE = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAC0pJREFUeNrsmUuvJMlVx3/nRES+quq+71yN2wyeGT8GITALQAILGQEbLLNAXvg7zIeY78QWyQtWeGGBJZARwhjb0+7u6b6veldmRsRhkVV3qqe75/bMwGIkhxTKulWZGf/z+v9PxBUz48s2lC/h+FKC9p/84v3337/7nFLCzDg7O+PBgweMRiP6vqdt21HXdb/rvf+buq7/MoTwloiknLOLMWYzQ0Q+XsT7MqW0vrm5eXR9ff3jtm3/MaX0UzMjhEBd15RlCcDL0vWDDz74dNAvGyJyB2L70gtV/fOqqr47mUy+XZblhYhkM9OUku0W3l1DCCGl1KrqGzlnubq6erLZbB6JyHUIIX5hT79s7FtvZjjnvu29/+HR0dGfnZ2d+dFo5HdG7aKzmwBFUUhKyZ+cnFRVVU26rpvPZrNnwE+AZ/8voFNKrNdrvPfjEMIfVVX1/aqq/vjo6Gh0cHBAXdfPRWIfMIBzDjOjaRonImc5579wznF5edl1XfejEMJdenxh0Dsgfd+zWq2o6/q98Xj8w5OTk++ORqOmaRpU9YU83E+n/eGc4+DggKIo3qrr+nvAzx8/fvzvZvbRF/J0zvm5z2ZGjPFss9m8B3y/aZq/Pjw8/Fpd164oClJKiAiq+kqwZkbOGRGhLEvqulYROZ3P53/b9/11SulHMcb/uHvWDFFFnUdU7wetn7jJzPDev1sUxQ+apvneZDJ5u2ka55y7A7kP6lU1sR8NVWU0GuUHDx78iYhweXm5nM1mvwJWO+PNDMsRS6/h6YOjE7BMTomUeswoj46OvnFxcfGd8/PztyeTSQgh3EVhF5Hd32YZMxDAABFQdTjn7lInpYSq6vn5Od77rwN/kFL6FxF+EUIx92VDt15y/dFD1ovb+0FXXkADIiU5G2a5PDo6enBxcfHO2dlpaJoG5xwppTuwm806L5er2PV9yjnf8bSZmVOVumnCqGlC8F5QvUvB8XiMqjbT2+lX5/P526L6NHg/V+fpFxs202fMb57eD3p5+SGhOaA+fhPnS0nd2nsfvHcqThVVQYS7EKYUmU6nN8+eXT5crrsnGZ0ZRBVCzrYORWhODttvCHxzPBpVhXOwLd6cMzFGYooumzgfGo2pY335S24f/YJ2OYOXiM0LoFfXj6m6NWVR4kfHRrZkSJeMNhsYAqKIOiwlYszM5ssnT54+/ef57c2/WoqPzXKnqqXlPC/r+kD6r/xdU9cP6mZUqfOoKjFFYsq0XZ/6ZG2McWOrWewXV0x/859Mnz0iaoW64n7QIgLtgnT1c6Q9I9UX04SfRXMpScC0QLRAnAKJJJEe96yN9tNu9vSf3OrpQ4tdxpdqKSabHBRx0nyrt3fW2VWIL0EEMx2urjCK0Tqbzbqn/z1vrz8krVdoKBFz2GvxtDqfY+vT7KaiX/uU1OX29MDiibPUY7EFNchpOzus35i1i5SXl4n5o2x9my3URuqz2TrZZppJnZF6SNslYw/OQe5FUlvZ+vZsc/Xrr26uP3xmYWzix5EkybIloPtU0CnLSPCnUcu3cozHNn8mLE/edfG00LSGzjAKSBHJhsQ12k1P3frqDy22fSQ8ziK9kyKY6DJIMRZLX/dxWbt+Dm0/UEqKqAW0XzhbPr1I82e/H/t+FLX6KONjzEyTMc0mS+DJp4KeFOmvSs1vH3j7ZsH61GjttC3ency1KS6naPDgPZITakLRdRzMf/3meXr4nTLMv5bI05zo1cdAzquyaJvj9OT3RtOfjQKPoChABE0JDYFiPg+T6a/eOY0PdVysbtfItMP6tcWrTdSHMfMQ+IdPBX1ed38/9um9N4ruzcb1TczQuI/Kg3lblvGXOHWgguYh28qcOFnNj72fNZvJ+u0UU7JspipiWA4+6SR9WE9uZmVYlog6RAWXB9Ur2tafruZfKcrZaXZt2kSLy4Td9jad9+6/uiw/uxf0adn/6VGZvvU7o8Rh4+gl4AoIfo6TJWIKeVA+AUyNapT9ceV9yuPRHUOJgGUEYQjOHJHF8JRtpScZQZJUYyuPKy1d9qzbxO0qEpb2htfAJunifnHRFGpnNmlUDo8bYnWAlBWKIU4RHSiPfck2Q8wQhC2JvyjfIoOVd42NgWUsGwZY3+H7NcVsQcwd1SYtyuQW2djc33tg3qmILzzl4RH+6AI3PkAlI24QFMwGjR6EGucc6oaeAds6EgYjGEQkx0S+M2BnhwKCoeTNGre6JRr41RRHK2qpVKS+F3TM0kbT3EuQvhgJkxP8yTneCypG7jusa8kxQs6IOrQs0bIgm5H6SEoJMHxR4INH+x7btEhKg8EqiA/4qkZcoDclzeZEhN4v6FkS88albHXK1nyGflrAeQglUtVoUOjW5M2a/vqKuJhjMaJlRXV6iobjoQ9ZLtisVphlxsfH+GKCdRu660viYomlhHiHPzhCzy/wzRjBD1ToiyH1hlAIUADlZwA95BwpYTkNubdZE29vaJ/8hu7mmtx1+NEIrxlfOWIfWV9eMr++IeeMs0gdhDy/pXv6mO76mtz3aCgo39jg6xqtR8OZQI6DWFneph0CuJdhfK3tFts8FhHUKa4IuKpAHLgyoMGjCjn19OsV7WI2NEOboc0dnvH4qiB5RX2Bhr0G314VavxnB31XdIbljHqPn4zBzvHjGssJDQXF8RFalLBaYymRY4/ljOWIiOCahursjDAaDZsFdbjRBF9VQyLs1nkR/Rf0dDbEe/x4gis9Fg8BQ8QNYVbdo7odT4Oo4sqS0nssJSxnUEV8AUWNiWDZ9oDLvqd1C/xzgkYQ73FBkaZAyAOhGYhzEAevstsn7k0tS7SqBl3ZGmRZySgp7ernlSkinw/0yw5vtu96HuDzy8idqGyngtz15Dsel0/gs8++G38l/YlgMRL7DcQNxG7gaTekB+q2KretgY+39NhmQ2xbLEeyGYIivkSqEWj5MmfuUdiLVvjXxYwI1vfE+Zw0vSQtF1jsB54+OcFPDsgpkbORs4GlbTGmYb93fU1arcgpohpwk0PC6RvIOID4VyTC5/X0sJ0G1WGHvlrRXt3QT2+wrkXrBvUBrZqBFYqCUFVYTriiABPiekN7c0N/OyXHHvUFRQIdH+LHArqdIv8HoHe56Nz2pTpEP4OlTE6GZMNMMFE0lIR6RDlpsZxxVYOpwxAsDc9YMkx3xw/bwlXdU0L5op7evmTbIInzuGZEODlDyhLr+4EZxodIUeODUZ/IANaM6vAYCRVSTwgn50hZb2Xc4yeHaFltqdFeqwDvAW1DpCxjKWJdj2VBVfDjA7QsKfqzweXO4UIBoUQNqomnqEeDMhQFOI82Y8qLQIhxy5GChgJXluTcYzkNe8ac9jpIeaXnXwDtFOfE1OfO/GZKmj6F3GJOMKdDtohgA3ENqtetseWwkEPwu3U2dlf+QyMhH5Na3GBrtsUKrNe45S2+W+It4lVwijh7HZ4WESFjfYfNb0ldJs+uiSLbg5ot/T2XRHZ3qGLIXT0JtnfWItheoclWULIZ2QyLPdatyKslpMjdiZC8Buh571ARRossm7ihl63s7opG2BbN8+lktnPJ3g5ly9eyx/XPHUuaGYaYmWCZYD1tb9xuhGn0fh59aLOGe0Fft2HWprTKWNWssqYUNwbxFUIrey2kAAmI2wzQbT+8W3T3Ww/k7Uzb+0qByqu53lSWUbnpfFz0vuuzdK/j6Ud9lsZgXElyKdnCsC4b+ZMdzV5T47fXfnuwkrffNXtN/O63dgt+N70gjYhMnFIltFxnVy6ib9dRb2OWm3tBt0n+DfQ2RDdOKi5n5nk4osl7NfVZQFfbe7tXgQZpxDhwRp2QUZt0tEm67rJcxSz/80J4f/sf29+CfvX43wEAm9+HxEl+FgsAAAAASUVORK5CYII=';
mxConstants.MANUAL_IMAGE  = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAA9tJREFUeNrsmE1rE18Uxn/3ziQ2BZMKpVrqQvAvokgXdiHoZ1AXuhc/gEs/gWtXgqALF67+G0EX4kIk3agLW6wBLSrRvlprU5uXmkyaZI4LJ+NMkqYjnbwU+hwGJpM7Z565c+5zzzlKRNhrMEP0FfTt1W4fpNmDMMN2OMssb3nLBhtoNGOMcZazHOVoiN9UJMgRGA/loUzIhMQlLkMyJBflokzKpHcIuz1Cn2kLiw02yJMHIEuWCpWgsa9CD49NNvMLLMR/8hMbmwMcYIwxRhnFwHCeqtxzAAMDFXztTQDToZJeZDF+n/skSVKhwggjXOMa17ke2McSSzzgAY95jIVFnDhXuMJNbgL8FzrpIkW+8IUUKQBWHcuRI0EikI8yZRZZZIYZBGGAAc5xrv73/87RVjL/SfIUChMT7ShlhIh7/i8+DAwiRFwf3nDqieSFgWmmecQjPvIRgGMc4za3m0j31V6+zDLPec4UUwCc4pSPdF/uiArlC7vGEPSFxyteMcUUBQoYGJzkJOc5z2EOd5RkIykDw3etUTJ9pF/ykrvc5TvfMTG5zGWOc7yjpG1scuR4wxtGGaVKlRVWsLCCLcQttihQcG8oUcLGDqwErTaTuuL8faDpm8UyZZIkWWCBGDFsbFZZZY65YKS9u5l2bCfN/cAHnvGMOHEsLFKk+MUvd8w667zmNRYWGs0SS8wz705GlSppx7oieXnyPOEJSZIYGNjYFCiQJeuO+cxn7nCHGDEUii22yJKlRq03qWmNGuuObYeSY+Eu3ADys90q7hX0ToS9RDW6L4ib2xd8wjLLvOAF88yjUHziE9/41t+kZ5jhK1+JEnUlMUeurQz2vEYsOtZv2JPV+D7pfdJBSdeoNZb7fYFGTj71OMIRxhlnjTU0mhw51lhrmyZ2Agc5yAgjDDJIjRrved+yw9SESZnM3pJbckJOCF00JUouyAW5J/cq2zSx2LHtNS7jXSd9SS61o+SGhxKEEiWKFBlm2C10hxgiQQKNpkoVC6vjcS+eOnuFFRXjj0WJOkVFAwYZ9P2+wQ0yZDAxmWOOpzzlHe98jjuJTTbRaB8v0/t2UaK+0gjgKlebWrkpUl0jXS82okQ5xKG2uYeqS2A92CJEpFXl3I12giBkyKDRTqgGKADqnZ5e9kEUih/8aN5cWiX4s8z2RQ7t5Wd6L9TT0PonSZN2eyDeXbOT+bQgvqK31doxvas0TZoaNZe0jc0ww74bTnOaDBl3XNiENZoznHGvxYg1z7iIUKaMhYUg2xJJkOhJk9LC8hEaYOAP6cAT0atQ3kXfoz/6B/tFQBfxewC/bMen8WndXwAAAABJRU5ErkJggg==';

// Disables built-in context menu
mxEvent.disableContextMenu(document.body);

// Voltage class
var VCLASS = {
    UOFF: '#ffffff',
    UGEN: '#e646e6',
    SERVICE: '#cdff9b',
    MOVABLE_GROUND: '#968C55',
    CURRENT_VOLTAGE_LOAD: '#00FF00',
    GENERATION: '#DC9691',
    DAMAGE: '#FF0000',
    OVERLOAD: '#FFFF00',
    UNRELIABLE_INFO: '#FFFFFF',
    DATE_TIME_FREQ: '#FFBE00',
    ASU_TP_PS: '#505050',
    PTK_CUS: '#000000',

    getOptions: function ()
    {
        if (this.options == null)
        {
            this.options = [
                { id: 'V0',    value: 'Не задано' },
                { id: 'V1',    value: 'До 1 кВ'   },
                { id: 'V6',    value: '6 кВ'      },
                { id: 'V10',   value: '10 кВ'     },
                { id: 'V20',   value: '20 кВ'     },
                { id: 'V35',   value: '35 кВ'     },
                { id: 'V110',  value: '110 кВ'    },
                { id: 'V150',  value: '150 кВ'    },
                { id: 'V220',  value: '220 кВ'    },
                { id: 'V330',  value: '330 кВ'    },
                { id: 'V400',  value: '400 кВ'    },
                { id: 'V500',  value: '500 кВ'    },
                { id: 'V750',  value: '750 кВ'    },
                { id: 'V800',  value: '800 кВ'    },
                { id: 'V1150', value: '1150 кВ'   }
            ];
        }
        return this.options;
    },
    getColor: function (val)
    {
        return VCLASS.getMap()[val];
    },
    isDefaultValue: function (val)
    {
        return val == null || val == 'V0';
    },
    getMap: function ()
    {
        if (this.map == null)
        {
            this.map = {
                V0:    'none',
                V1:    '#bebebe',
                V6:    '#c89664',
                V10:   '#640064',
                V20:   '#826432',
                V35:   '#826432',
                V110:  '#00b4c8',
                V150:  '#aa9600',
                V220:  '#c8c800',
                V330:  '#008c00',
                V400:  '#f0961e',
                V500:  '#a50f0a',
                V750:  '#0000c8',
                V800:  '#0000c8',
                V1150: '#cd8aff'
            };
        }
        return this.map;
    }
};

function mxBindings (source)
{
    if (source != null && isDefined(source.length))
    {
        for (let i = 0; i < source.length; i++)
            this.push(source[i]);
    }
}
mxUtils.extend(mxBindings, Array);

var codec = new mxObjectCodec(new mxBindings());
codec.encode = function (enc, obj)
{
    let xmlDoc   = mxUtils.createXmlDocument();
    let bindings = xmlDoc.createElement('mxBindings');
    if (obj != null && obj instanceof mxBindings)
    {
        for (let i = 0; i < obj.length; i++)
        {
            let bindItem = obj[i];
            if (bindItem != null)
            {
                let item = xmlDoc.createElement('item');
                $(item).attr('name', bindItem.name);
                $(item).attr('value', bindItem.value);
                bindings.appendChild(item);
            }
        }
    }
    return bindings;
};
codec.decode = function (dec, node, into)
{
    let bindings = [];
    var items = node.getElementsByTagName('item');
    if (items && items.length > 0)
    {
        for (let i = 0; i < items.length; i++)
            bindings.push({ name: $(items[i]).attr('name'), value: $(items[i]).attr('value') });
    }
    return new mxBindings(bindings);
};
mxCodecRegistry.register(codec);

function mxBindingsChange(model, cell, bindings)
{
    this.model = model;
    this.cell = cell;
    this.bindings = bindings;
    this.previous = bindings;
};
mxBindingsChange.prototype.execute = function ()
{
    if (this.cell != null)
    {
        this.bindings = this.previous;
        this.previous = this.model.bindingsForCellChanged(this.cell, this.previous);
    }
};
mxGraphModel.prototype.setBinding = function (cell, name, value)
{
    // update cell runtime bindings
    if (cell.bindings == null)
        cell.bindings = new mxBindings();
    let targetBinding = this.getBinding(name);
    if (targetBinding != null)
        targetBinding.value = JSON.stringify(value);
    else
        cell.bindings.push({ name: name, value: value });
    this.setBindings(cell, cell.bindings);
};
mxGraphModel.prototype.setBindings = function (cell, bindings)
{
    if (bindings != cell.bindings)
    {
        this.execute(new mxBindingsChange(this, cell, bindings));
    }
    return bindings;
};
mxGraphModel.prototype.bindingsForCellChanged = function (cell, bindings)
{
    var previous = cell.bindings;
    cell.setBindings(bindings);
    return previous;
};
mxCodecRegistry.register(mxGenericChangeCodec(new mxBindingsChange(), 'bindings'));


mxCell.prototype.setBindings = function (array)
{
   
    // update cell runtime bindings
    this.bindings = new mxBindings(array);
    // Clones the value for correct undo/redo
    //let cellValue = this.getValue().cloneNode(true);
    // update cell value
    //if (cellValue != null && mxUtils.isNode(cellValue))
    //{
    //    var xmlDoc = mxUtils.createXmlDocument();
    //    var bindings = xmlDoc.createElement('bindings');
    //    xmlDoc.appendChild(bindings);
    //    for (let i = 0; i < array.length; i++)
    //    {
    //        let bindItem = array[i];
    //        if (bindItem != null)
    //        {
    //            let item = xmlDoc.createElement('item');
    //            $(item).attr('name',  bindItem.name);
    //            $(item).attr('value', bindItem.value);
    //            bindings.appendChild(item);
    //        }
    //    }
    //    // update target values
    //    var cellBindings = cellValue.getElementsByTagName('bindings');
    //    if (cellBindings && cellBindings.length > 0)
    //        cellValue.removeChild(cellBindings[0]);
    //    cellValue.appendChild(bindings);
    //}
    //return cellValue;
};
mxCell.prototype.getBinding = function (name)
{
  
    //if (this.bindings == null)
        //this.bindings = this.getBindings();
    return this.bindings != null ? this.bindings.find(function (x) { return x.name == name; }) : null;
};
mxCell.prototype.getBindingsByID = function (bindID)
{
    if (this.bindings == null)
        return [];
    return this.bindings.filter(function (x) { return !isNullOrEmpty(x.value) && x.value.indexOf(bindID) > 0; });
};

// export { VCLASS }

//Dialogs.js

// import $ from "jquery";
// import * as mxgraph from 'mxgraph';
// import { API } from './scada'
// import Editor, { Dialog } from './Editor'
// import Sidebar from './Sidebar';
// import Graph from './Graph'
// import Format from './Format'
// import BindingsHandler from "./Bindings";
// import * as webix from 'webix/webix.js';
// import 'webix/webix.css';
// import { HELP, AJAX } from './client'
// import jscolor from 'jscolor'
// const {
// $$
// } = webix

// let { 
//     mxGraphModel, 
//     mxClient, 
//     mxUtils, 
//     mxResources, 
//     mxRectangle,
//     mxConstants,
//     mxEvent,
//     mxPoint,
//     mxPopupMenu,
//     mxEventObject,
//     mxCodec,
//     mxCell,
//     mxImageExport,
//     mxOutline,
//     mxWindow,
//     mxXmlCanvas2D,
//     mxXmlRequest,
//     mxForm,
// } = mxgraph();

/**
 * Fix minimize/maximize localization
 */

function mtWindow(title, content, x, y, width, height, minimizable, moveable, replace, style)
{
    mxWindow.call(this, title, content, x, y, width, height, minimizable, moveable, replace, style);
    this.addListener(mxEvent.SHOW, mxUtils.bind(this, function ()
    {
        this.closeImg.title = mxResources.get('close');
        this.maximize.title = mxResources.get('expand');
        this.minimize.title = mxResources.get('collapse');
        this.fit();
    }));
    this.addListener(mxEvent.MAXIMIZE, mxUtils.bind(this, function ()
    {
        this.maximize.title = mxResources.get('restore');
    }));
    this.addListener(mxEvent.MINIMIZE, mxUtils.bind(this, function ()
    {
        this.minimize.title = mxResources.get('restore');        
    }));
    this.addListener(mxEvent.NORMALIZE, mxUtils.bind(this, function ()
    {
        this.maximize.title = mxResources.get('expand');
        this.minimize.title = mxResources.get('collapse');
    }));
}
mtWindow.prototype = new mxWindow();
mtWindow.prototype.constructor = mtWindow;

/**
 * Constructs a new open dialog.
 */
var OpenDialog = function()
{
    var iframe = document.createElement('iframe');
    iframe.style.backgroundColor = 'transparent';
    iframe.allowTransparency = 'true';
    iframe.style.borderStyle = 'none';
    iframe.style.borderWidth = '0px';
    iframe.style.overflow = 'hidden';
    iframe.frameBorder = '0';
        
    iframe.setAttribute('width',  320 + 'px');
    iframe.setAttribute('height', 220 + 'px');
    //iframe.setAttribute('src', OPEN_FORM);
    
    this.container = iframe;
};

/**
 * Constructs a new color dialog.
 */
var ColorDialog = function(editorUi, color, apply, cancelFn)
{
    this.editorUi = editorUi;
    
    var input = document.createElement('input');
    input.style.marginBottom = '10px';
    input.style.width = '216px';
    
    // Required for picker to render in IE
    if (mxClient.IS_IE)
    {
        input.style.marginTop = '10px';
        document.body.appendChild(input);
    }
    
    this.init = function()
    {
        if (!mxClient.IS_TOUCH)
        {
            input.focus();
        }
    };

    var picker = new jscolor.color(input);
    picker.pickerOnfocus = false;
    picker.showPicker();

    var div = document.createElement('div');
    jscolor.picker.box.style.position = 'relative';
    jscolor.picker.box.style.width = '230px';
    jscolor.picker.box.style.height = '100px';
    jscolor.picker.box.style.paddingBottom = '10px';
    div.appendChild(jscolor.picker.box);

    var center = document.createElement('center');
    
    function createRecentColorTable()
    {
        var table = addPresets((ColorDialog.recentColors.length == 0) ? ['FFFFFF'] :
                    ColorDialog.recentColors, 11, 'FFFFFF', true);
        table.style.marginBottom = '8px';
        
        return table;
    };
    
    function addPresets(presets, rowLength, defaultColor, addResetOption)
    {
        rowLength = (rowLength != null) ? rowLength : 12;
        var table = document.createElement('table');
        table.style.borderCollapse = 'collapse';
        table.setAttribute('cellspacing', '0');
        table.style.marginBottom = '20px';
        table.style.cellSpacing = '0px';
        var tbody = document.createElement('tbody');
        table.appendChild(tbody);

        var rows = presets.length / rowLength;
        
        for (var row = 0; row < rows; row++)
        {
            var tr = document.createElement('tr');
            
            for (var i = 0; i < rowLength; i++)
            {
                (function(clr)
                {
                    var td = document.createElement('td');
                    td.style.border = '1px solid black';
                    td.style.padding = '0px';
                    td.style.width = '16px';
                    td.style.height = '16px';
                    
                    if (clr == null)
                    {
                        clr = defaultColor;
                    }
                    
                    if (clr == 'none')
                    {
                        td.style.background = 'url(\'' + Dialog.prototype.noColorImage + '\')';
                    }
                    else
                    {
                        td.style.backgroundColor = '#' + clr;
                    }
                    
                    tr.appendChild(td);

                    if (clr != null)
                    {
                        td.style.cursor = 'pointer';
                        
                        mxEvent.addListener(td, 'click', function()
                        {
                            if (clr == 'none')
                            {
                                picker.fromString('ffffff');
                                input.value = 'none';
                            }
                            else
                            {
                                picker.fromString(clr);
                            }
                        });
                    }
                })(presets[row * rowLength + i]);
            }
            
            tbody.appendChild(tr);
        }
        
        if (addResetOption)
        {
            var td = document.createElement('td');
            td.setAttribute('title', mxResources.get('reset'));
            td.style.border = '1px solid black';
            td.style.padding = '0px';
            td.style.width = '16px';
            td.style.height = '16px';
            td.style.backgroundImage = 'url(\'' + Dialog.prototype.closeImage + '\')';
            td.style.backgroundPosition = 'center center';
            td.style.backgroundRepeat = 'no-repeat';
            td.style.cursor = 'pointer';
            
            tr.appendChild(td);

            mxEvent.addListener(td, 'click', function()
            {
                ColorDialog.resetRecentColors();
                table.parentNode.replaceChild(createRecentColorTable(), table);
            });
        }
        
        center.appendChild(table);
        
        return table;
    };

    div.appendChild(input);
    mxUtils.br(div);
    
    // Adds recent colors
    createRecentColorTable();
        
    // Adds presets
    var table = addPresets(this.presetColors);
    table.style.marginBottom = '8px';
    table = addPresets(this.defaultColors);
    table.style.marginBottom = '16px';

    div.appendChild(center);

    var buttons = document.createElement('div');
    buttons.style.textAlign = 'right';
    buttons.style.whiteSpace = 'nowrap';
    
    var cancelBtn = mxUtils.button(mxResources.get('cancel'), function()
    {
        editorUi.hideDialog();
        if (cancelFn != null)
            cancelFn();
    });
    cancelBtn.className = 'geBtn';
    buttons.appendChild(cancelBtn);
    
    var applyFunction = (apply != null) ? apply : this.createApplyFunction();
    var applyBtn = mxUtils.button(mxResources.get('apply'), function()
    {
        var color = input.value;
        
        // Blocks any non-alphabetic chars in colors
        if (/(^#?[a-zA-Z0-9]*$)/.test(color))
        {
            //ColorDialog.addRecentColor(color, 12);
            
            if (color != 'none' && color.charAt(0) != '#')
            {
                color = '#' + color;
            }

            ColorDialog.addRecentColor((color != 'none') ? color.substring(1) : color, 12);
            applyFunction(color);
            editorUi.hideDialog();
        }
        else
        {
            editorUi.handleError({message: mxResources.get('invalidInput')});	
        }
    });
    applyBtn.className = 'geBtn gePrimaryBtn';
    buttons.appendChild(applyBtn);
    
    if (color != null)
    {
        if (color == 'none')
        {
            picker.fromString('ffffff');
            input.value = 'none';
        }
        else
        {
            picker.fromString(color);
        }
    }
    
    div.appendChild(buttons);
    this.picker = picker;
    this.colorInput = input;

    // LATER: Only fires if input if focused, should always fire if this dialog is showing.
    mxEvent.addListener(div, 'keydown', function(e)
    {
        if (e.keyCode == 27)
        {
            editorUi.hideDialog();
            if (cancelFn != null)
                cancelFn();
            mxEvent.consume(e);
        }
    });
    
    this.container = div;
};
ColorDialog.prototype.presetColors = ['E6D0DE', 'CDA2BE', 'B5739D', 'E1D5E7', 'C3ABD0', 'A680B8', 'D4E1F5', 'A9C4EB', '7EA6E0', 'D5E8D4', '9AC7BF', '67AB9F', 'D5E8D4', 'B9E0A5', '97D077', 'FFF2CC', 'FFE599', 'FFD966', 'FFF4C3', 'FFCE9F', 'FFB570', 'F8CECC', 'F19C99', 'EA6B66']; 
ColorDialog.prototype.defaultColors = ['none', 'FFFFFF', 'E6E6E6', 'CCCCCC', 'B3B3B3', '999999', '808080', '666666', '4D4D4D', '333333', '1A1A1A', '000000', 'FFCCCC', 'FFE6CC', 'FFFFCC', 'E6FFCC', 'CCFFCC', 'CCFFE6', 'CCFFFF', 'CCE5FF', 'CCCCFF', 'E5CCFF', 'FFCCFF', 'FFCCE6',
        'FF9999', 'FFCC99', 'FFFF99', 'CCFF99', '99FF99', '99FFCC', '99FFFF', '99CCFF', '9999FF', 'CC99FF', 'FF99FF', 'FF99CC', 'FF6666', 'FFB366', 'FFFF66', 'B3FF66', '66FF66', '66FFB3', '66FFFF', '66B2FF', '6666FF', 'B266FF', 'FF66FF', 'FF66B3', 'FF3333', 'FF9933', 'FFFF33',
        '99FF33', '33FF33', '33FF99', '33FFFF', '3399FF', '3333FF', '9933FF', 'FF33FF', 'FF3399', 'FF0000', 'FF8000', 'FFFF00', '80FF00', '00FF00', '00FF80', '00FFFF', '007FFF', '0000FF', '7F00FF', 'FF00FF', 'FF0080', 'CC0000', 'CC6600', 'CCCC00', '66CC00', '00CC00', '00CC66',
        '00CCCC', '0066CC', '0000CC', '6600CC', 'CC00CC', 'CC0066', '990000', '994C00', '999900', '4D9900', '009900', '00994D', '009999', '004C99', '000099', '4C0099', '990099', '99004D', '660000', '663300', '666600', '336600', '006600', '006633', '006666', '003366', '000066',
        '330066', '660066', '660033', '330000', '331A00', '333300', '1A3300', '003300', '00331A', '003333', '001933', '000033', '190033', '330033', '33001A'];
ColorDialog.prototype.createApplyFunction = function()
{
    return mxUtils.bind(this, function(color)
    {
        var graph = this.editorUi.editor.graph;
        
        graph.getModel().beginUpdate();
        try
        {
            graph.setCellStyles(this.currentColorKey, color);
            this.editorUi.fireEvent(new mxEventObject('styleChanged', 'keys', [this.currentColorKey],
                'values', [color], 'cells', graph.getSelectionCells()));
        }
        finally
        {
            graph.getModel().endUpdate();
        }
    });
};
ColorDialog.recentColors = [];
ColorDialog.addRecentColor = function(color, max)
{
    if (color != null)
    {
        mxUtils.remove(color, ColorDialog.recentColors);
        ColorDialog.recentColors.splice(0, 0, color);
        
        if (ColorDialog.recentColors.length >= max)
        {
            ColorDialog.recentColors.pop();
        }
    }
};
ColorDialog.resetRecentColors = function()
{
    ColorDialog.recentColors = [];
};

/**
 * Constructs a new filename dialog.
 */
var FilenameDialog = function(editorUi, filename, buttonText, fn, label, validateFn, content, helpLink, closeOnBtn, cancelFn, hints, w)
{
    closeOnBtn = (closeOnBtn != null) ? closeOnBtn : true;
    var row, td;
    
    var table = document.createElement('table');
    var tbody = document.createElement('tbody');
    table.style.marginTop = '8px';
    
    row = document.createElement('tr');
    
    td = document.createElement('td');
    td.style.whiteSpace = 'nowrap';
    //td.style.fontSize = '10pt';
    td.style.width = '120px';
    mxUtils.write(td, (label || mxResources.get('filename')) + ':');
    
    row.appendChild(td);
    
    var nameInput = document.createElement('input');
    nameInput.setAttribute('value', filename || '');
    nameInput.style.marginLeft = '4px';
    nameInput.style.width = (w != null) ? w + 'px' : '180px';
    
    var genericBtn = mxUtils.button(buttonText, function()
    {
        if (validateFn == null || validateFn(nameInput.value))
        {
            if (closeOnBtn)
                editorUi.hideDialog();            
            fn(nameInput.value);
        }
    });
    genericBtn.className = 'geBtn gePrimaryBtn';
    
    this.init = function()
    {
        if (label == null && content != null)
            return;
        
        nameInput.focus();
        
        if (mxClient.IS_GC || mxClient.IS_FF || document.documentMode >= 5)
            nameInput.select();
        else
            document.execCommand('selectAll', false, null);
        
        // Installs drag and drop handler for links
        if (Graph.fileSupport)
        {
            // Setup the dnd listeners
            var dlg = table.parentNode;
            if (dlg != null)
            {
                var graph = editorUi.editor.graph;
                var dropElt = null;
                    
                mxEvent.addListener(dlg, 'dragleave', function(evt)
                {
                    if (dropElt != null)
                    {
                        dropElt.style.backgroundColor = '';
                        dropElt = null;
                    }
                    
                    evt.stopPropagation();
                    evt.preventDefault();
                });
                
                mxEvent.addListener(dlg, 'dragover', mxUtils.bind(this, function(evt)
                {
                    // IE 10 does not implement pointer-events so it can't have a drop highlight
                    if (dropElt == null && (!mxClient.IS_IE || document.documentMode > 10))
                    {
                        dropElt = nameInput;
                        dropElt.style.backgroundColor = '#ebf2f9';
                    }
                    
                    evt.stopPropagation();
                    evt.preventDefault();
                }));
                        
                mxEvent.addListener(dlg, 'drop', mxUtils.bind(this, function(evt)
                {
                    if (dropElt != null)
                    {
                        dropElt.style.backgroundColor = '';
                        dropElt = null;
                    }
    
                    if (mxUtils.indexOf(evt.dataTransfer.types, 'text/uri-list') >= 0)
                    {
                        nameInput.value = decodeURIComponent(evt.dataTransfer.getData('text/uri-list'));
                        genericBtn.click();
                    }
    
                    evt.stopPropagation();
                    evt.preventDefault();
                }));
            }
        }
    };

    td = document.createElement('td');
    td.style.whiteSpace = 'nowrap';
    td.appendChild(nameInput);
    row.appendChild(td);
    
    if (label != null || content == null)
    {
        tbody.appendChild(row);
        if (hints != null)
            td.appendChild(FilenameDialog.createTypeHint(editorUi, nameInput, hints));
    }
    
    if (content != null)
    {
        row = document.createElement('tr');
        td = document.createElement('td');
        td.colSpan = 2;
        td.appendChild(content);
        row.appendChild(td);
        tbody.appendChild(row);
    }
    
    row = document.createElement('tr');
    td = document.createElement('td');
    td.colSpan = 2;
    td.style.paddingTop = '20px';
    td.style.whiteSpace = 'nowrap';
    td.setAttribute('align', 'right');
    
    var cancelBtn = mxUtils.button(mxResources.get('cancel'), function()
    {
        editorUi.hideDialog();
        if (cancelFn != null)
            cancelFn();
    });
    cancelBtn.className = 'geBtn';
    td.appendChild(cancelBtn);
        
    if (helpLink != null)
    {
        var helpBtn = mxUtils.button(mxResources.get('help'), function()
        {
            editorUi.editor.graph.openLink(helpLink);
        });
        helpBtn.className = 'geBtn';	
        td.appendChild(helpBtn);
    }

    mxEvent.addListener(nameInput, 'keypress', function(e)
    {
        if (e.keyCode == 13)
        {
            genericBtn.click();
        }
    });
    
    td.appendChild(genericBtn);
    
    row.appendChild(td);
    tbody.appendChild(row);
    table.appendChild(tbody);
    
    this.container = table;
};
FilenameDialog.filenameHelpLink = null;
FilenameDialog.createTypeHint = function(ui, nameInput, hints)
{
    var hint = document.createElement('img');
    hint.style.cssText = 'vertical-align:top;height:16px;width:16px;margin-left:4px;background-repeat:no-repeat;background-position:center bottom;cursor:pointer;';
    mxUtils.setOpacity(hint, 70);
    
    var nameChanged = function()
    {
        hint.setAttribute('src', Editor.helpImage);
        hint.setAttribute('title', mxResources.get('help'));
        
        for (var i = 0; i < hints.length; i++)
        {
            if (hints[i].ext.length > 0 &&
                nameInput.value.substring(nameInput.value.length -
                        hints[i].ext.length - 1) == '.' + hints[i].ext)
            {
                hint.setAttribute('src',  mxClient.imageBasePath + '/warning.png');
                hint.setAttribute('title', mxResources.get(hints[i].title));
                break;
            }
        }
    };
    
    mxEvent.addListener(nameInput, 'keyup', nameChanged);
    mxEvent.addListener(nameInput, 'change', nameChanged);
    mxEvent.addListener(hint, 'click', function(evt)
    {
        var title = hint.getAttribute('title');
        
        if (hint.getAttribute('src') == Editor.helpImage)
        {
            ui.editor.graph.openLink(FilenameDialog.filenameHelpLink);
        }
        else if (title != '')
        {
            ui.showError(null, title, mxResources.get('help'), function()
            {
                ui.editor.graph.openLink(FilenameDialog.filenameHelpLink);
            }, null, mxResources.get('ok'), null, null, null, 340, 90);
        }
        
        mxEvent.consume(evt);
    });
    
    nameChanged();
    
    return hint;
};

/**
 * Constructs a new textarea dialog.
 */
var TextareaDialog = function(editorUi, title, url, fn, cancelFn, cancelTitle, w, h, addButtons, noHide, noWrap, applyTitle, helpLink)
{
    w = (w != null) ? w : 300;
    h = (h != null) ? h : 120;
    noHide = (noHide != null) ? noHide : false;
    var row, td;
    
    var table = document.createElement('table');
    var tbody = document.createElement('tbody');
    
    row = document.createElement('tr');
    
    td = document.createElement('td');
    //td.style.fontSize = '10pt';
    td.style.width = '100px';
    mxUtils.write(td, title);
    
    row.appendChild(td);
    tbody.appendChild(row);

    row = document.createElement('tr');
    td = document.createElement('td');

    var nameInput = document.createElement('textarea');
    
    if (noWrap)
    {
        nameInput.setAttribute('wrap', 'off');
    }
    
    nameInput.setAttribute('spellcheck', 'false');
    nameInput.setAttribute('autocorrect', 'off');
    nameInput.setAttribute('autocomplete', 'off');
    nameInput.setAttribute('autocapitalize', 'off');
    
    mxUtils.write(nameInput, url || '');
    nameInput.style.resize = 'none';
    nameInput.style.width = w + 'px';
    nameInput.style.height = h + 'px';
    
    this.textarea = nameInput;

    this.init = function()
    {
        nameInput.focus();
        nameInput.scrollTop = 0;
    };

    td.appendChild(nameInput);
    row.appendChild(td);
    
    tbody.appendChild(row);

    row = document.createElement('tr');
    td = document.createElement('td');
    td.style.paddingTop = '14px';
    td.style.whiteSpace = 'nowrap';
    td.setAttribute('align', 'right');
    
    if (helpLink != null)
    {
        var helpBtn = mxUtils.button(mxResources.get('help'), function()
        {
            editorUi.editor.graph.openLink(helpLink);
        });
        helpBtn.className = 'geBtn';
        
        td.appendChild(helpBtn);
    }
    
    var cancelBtn = mxUtils.button(cancelTitle || mxResources.get('cancel'), function()
    {
        editorUi.hideDialog();
        
        if (cancelFn != null)
        {
            cancelFn();
        }
    });
    cancelBtn.className = 'geBtn';
    td.appendChild(cancelBtn);
    
    if (addButtons != null)
    {
        addButtons(td, nameInput);
    }
    
    if (fn != null)
    {
        var genericBtn = mxUtils.button(applyTitle || mxResources.get('apply'), function()
        {
            if (!noHide)
                editorUi.hideDialog();
            fn(nameInput.value);
        });
        
        genericBtn.className = 'geBtn gePrimaryBtn';	
        td.appendChild(genericBtn);
    }
    
    row.appendChild(td);
    tbody.appendChild(row);
    table.appendChild(tbody);
    this.container = table;
};

/**
 * Constructs a new edit file dialog.
 */
var EditDiagramDialog = function(editorUi)
{
    var div = document.createElement('div');
    div.style.textAlign = 'right';
    var textarea = document.createElement('textarea');
    textarea.setAttribute('wrap', 'off');
    textarea.setAttribute('spellcheck', 'false');
    textarea.setAttribute('autocorrect', 'off');
    textarea.setAttribute('autocomplete', 'off');
    textarea.setAttribute('autocapitalize', 'off');
    textarea.style.overflow = 'auto';
    textarea.style.resize = 'none';
    textarea.style.width = '580px';
    textarea.style.height = '360px';
    textarea.style.marginBottom = '16px';
    
    textarea.value = mxUtils.getPrettyXml(editorUi.editor.getGraphXml());
    div.appendChild(textarea);
    
    this.init = function()
    {
        textarea.focus();
    };
    
    // Enables dropping files
    if (Graph.fileSupport)
    {
        function handleDrop(evt)
        {
            evt.stopPropagation();
            evt.preventDefault();
            
            if (evt.dataTransfer.files.length > 0)
            {
                var file = evt.dataTransfer.files[0];
                var reader = new FileReader();
                
                reader.onload = function(e)
                {
                    textarea.value = e.target.result;
                };
                
                reader.readAsText(file);
            }
            else
            {
                textarea.value = editorUi.extractGraphModelFromEvent(evt);
            }
        };
        function handleDragOver(evt)
        {
            evt.stopPropagation();
            evt.preventDefault();
        };

        // Setup the dnd listeners.
        textarea.addEventListener('dragover', handleDragOver, false);
        textarea.addEventListener('drop', handleDrop, false);
    }
    
    var cancelBtn = mxUtils.button(mxResources.get('cancel'), function()
    {
        editorUi.hideDialog();
    });
    cancelBtn.className = 'geBtn';
    div.appendChild(cancelBtn);
    
    var select = document.createElement('select');
    select.style.width = '250px';
    select.className = 'geBtn';

    if (editorUi.editor.graph.isEnabled())
    {
        var replaceOption = document.createElement('option');
        replaceOption.setAttribute('value', 'replace');
        mxUtils.write(replaceOption, mxResources.get('replaceExistingDrawing'));
        select.appendChild(replaceOption);

        var importOption = document.createElement('option');
        importOption.setAttribute('value', 'import');
        mxUtils.write(importOption, mxResources.get('addToExistingDrawing'));
        select.appendChild(importOption);
    }

    //div.appendChild(select);

    var okBtn = mxUtils.button(mxResources.get('ok'), function()
    {
        // Removes all illegal control characters before parsing
        var data = Graph.zapGremlins(mxUtils.trim(textarea.value));
        var error = null;
        
        if (select.value == 'replace')
        {
            editorUi.editor.graph.model.beginUpdate();
            try
            {
                editorUi.editor.setGraphXml(mxUtils.parseXml(data).documentElement);
                // LATER: Why is hideDialog between begin-/endUpdate faster?
                editorUi.hideDialog();
            }
            catch (e)
            {
                error = e;
            }
            finally
            {
                editorUi.editor.graph.model.endUpdate();				
            }
        }
        else if (select.value == 'import')
        {
            editorUi.editor.graph.model.beginUpdate();
            try
            {
                var doc = mxUtils.parseXml(data);
                var model = new mxGraphModel();
                var codec = new mxCodec(doc);
                codec.decode(doc.documentElement, model);
                
                var children = model.getChildren(model.getChildAt(model.getRoot(), 0));
                editorUi.editor.graph.setSelectionCells(editorUi.editor.graph.importCells(children));
                
                // LATER: Why is hideDialog between begin-/endUpdate faster?
                editorUi.hideDialog();
            }
            catch (e)
            {
                error = e;
            }
            finally
            {
                editorUi.editor.graph.model.endUpdate();				
            }
        }
            
        if (error != null)
        console.log('error')
            // messageError(error.message);
    });
    okBtn.className = 'geBtn gePrimaryBtn';
    div.appendChild(okBtn);

    this.container = div;
};

/**
 * Constructs a new export dialog.
 */
var ExportDialog = function(editorUi)
{
    var graph = editorUi.editor.graph;
    var bounds = graph.getGraphBounds();
    var scale = graph.view.scale;
    
    var width = Math.ceil(bounds.width / scale);
    var height = Math.ceil(bounds.height / scale);

    var row, td;
    
    var table = document.createElement('table');
    var tbody = document.createElement('tbody');
    table.setAttribute('cellpadding', (mxClient.IS_SF) ? '0' : '2');
    
    row = document.createElement('tr');
    
    td = document.createElement('td');
    //td.style.fontSize = '10pt';
    td.style.width = '100px';
    mxUtils.write(td, mxResources.get('filename') + ':');
    
    row.appendChild(td);
    
    var nameInput = document.createElement('input');
    nameInput.setAttribute('value', editorUi.editor.getOrCreateFilename());
    nameInput.style.width = '180px';

    td = document.createElement('td');
    td.appendChild(nameInput);
    row.appendChild(td);
    
    tbody.appendChild(row);
        
    row = document.createElement('tr');
    
    td = document.createElement('td');
    //td.style.fontSize = '10pt';
    mxUtils.write(td, mxResources.get('format') + ':');
    
    row.appendChild(td);
    
    var imageFormatSelect = document.createElement('select');
    imageFormatSelect.style.width = '180px';

    //var pngOption = document.createElement('option');
    //pngOption.setAttribute('value', 'png');
    //mxUtils.write(pngOption, mxResources.get('formatPng'));
    //imageFormatSelect.appendChild(pngOption);
    
    if (ExportDialog.showGifOption)
    {
        var gifOption = document.createElement('option');
        gifOption.setAttribute('value', 'gif');
        mxUtils.write(gifOption, mxResources.get('formatGif'));
        imageFormatSelect.appendChild(gifOption);
    }
    
    //var jpgOption = document.createElement('option');
    //jpgOption.setAttribute('value', 'jpg');
    //mxUtils.write(jpgOption, mxResources.get('formatJpg'));
    //imageFormatSelect.appendChild(jpgOption);

    //var pdfOption = document.createElement('option');
    //pdfOption.setAttribute('value', 'pdf');
    //mxUtils.write(pdfOption, mxResources.get('formatPdf'));
    //imageFormatSelect.appendChild(pdfOption);
    
    var svgOption = document.createElement('option');
    svgOption.setAttribute('value', 'svg');
    mxUtils.write(svgOption, mxResources.get('formatSvg'));
    imageFormatSelect.appendChild(svgOption);
    
    if (ExportDialog.showXmlOption)
    {
        var xmlOption = document.createElement('option');
        xmlOption.setAttribute('value', 'xml');
        mxUtils.write(xmlOption, mxResources.get('formatXml'));
        imageFormatSelect.appendChild(xmlOption);
    }

    td = document.createElement('td');
    td.appendChild(imageFormatSelect);
    row.appendChild(td);
    
    tbody.appendChild(row);
    
    row = document.createElement('tr');

    td = document.createElement('td');
    //td.style.fontSize = '10pt';
    mxUtils.write(td, mxResources.get('zoom') + ' (%):');
    
    row.appendChild(td);
    
    var zoomInput = document.createElement('input');
    zoomInput.setAttribute('type', 'number');
    zoomInput.setAttribute('value', '100');
    zoomInput.style.width = '180px';

    td = document.createElement('td');
    td.appendChild(zoomInput);
    row.appendChild(td);

    tbody.appendChild(row);

    row = document.createElement('tr');

    td = document.createElement('td');
    //td.style.fontSize = '10pt';
    mxUtils.write(td, mxResources.get('width') + ':');
    
    row.appendChild(td);
    
    var widthInput = document.createElement('input');
    widthInput.setAttribute('value', width);
    widthInput.style.width = '180px';

    td = document.createElement('td');
    td.appendChild(widthInput);
    row.appendChild(td);

    tbody.appendChild(row);
    
    row = document.createElement('tr');
    
    td = document.createElement('td');
    //td.style.fontSize = '10pt';
    mxUtils.write(td, mxResources.get('height') + ':');
    
    row.appendChild(td);
    
    var heightInput = document.createElement('input');
    heightInput.setAttribute('value', height);
    heightInput.style.width = '180px';

    td = document.createElement('td');
    td.appendChild(heightInput);
    row.appendChild(td);

    tbody.appendChild(row);
    
    row = document.createElement('tr');
    
    td = document.createElement('td');
    //td.style.fontSize = '10pt';
    mxUtils.write(td, mxResources.get('background') + ':');
    
    row.appendChild(td);
    
    var transparentCheckbox = document.createElement('input');
    transparentCheckbox.setAttribute('type', 'checkbox');
    transparentCheckbox.checked = graph.background == null || graph.background == mxConstants.NONE;

    td = document.createElement('td');
    td.appendChild(transparentCheckbox);
    mxUtils.write(td, mxResources.get('transparent'));
    
    row.appendChild(td);
    
    tbody.appendChild(row);
    
    row = document.createElement('tr');

    td = document.createElement('td');
    //td.style.fontSize = '10pt';
    mxUtils.write(td, mxResources.get('borderWidth') + ':');
    
    row.appendChild(td);
    
    var borderInput = document.createElement('input');
    borderInput.setAttribute('type', 'number');
    borderInput.setAttribute('value', ExportDialog.lastBorderValue);
    borderInput.style.width = '180px';

    td = document.createElement('td');
    td.appendChild(borderInput);
    row.appendChild(td);

    tbody.appendChild(row);
    table.appendChild(tbody);
    
    // Handles changes in the export format
    function formatChanged()
    {
        var name = nameInput.value;
        var dot = name.lastIndexOf('.');
        
        if (dot > 0)
        {
            nameInput.value = name.substring(0, dot + 1) + imageFormatSelect.value;
        }
        else
        {
            nameInput.value = name + '.' + imageFormatSelect.value;
        }
        
        if (imageFormatSelect.value === 'xml')
        {
            zoomInput.setAttribute('disabled', 'true');
            widthInput.setAttribute('disabled', 'true');
            heightInput.setAttribute('disabled', 'true');
            borderInput.setAttribute('disabled', 'true');
        }
        else
        {
            zoomInput.removeAttribute('disabled');
            widthInput.removeAttribute('disabled');
            heightInput.removeAttribute('disabled');
            borderInput.removeAttribute('disabled');
        }
        
        if (imageFormatSelect.value === 'png' || imageFormatSelect.value === 'svg')
        {
            transparentCheckbox.removeAttribute('disabled');
        }
        else
        {
            transparentCheckbox.setAttribute('disabled', 'disabled');
        }
    }
    
    mxEvent.addListener(imageFormatSelect, 'change', formatChanged);
    formatChanged();

    function checkValues()
    {
        // if (widthInput.value * heightInput.value > MAX_AREA || widthInput.value <= 0)
        if (widthInput.value * heightInput.value > 15000 * 15000 || widthInput.value <= 0)
        {
            widthInput.style.backgroundColor = 'red';
        }
        else
        {
            widthInput.style.backgroundColor = '';
        }
        //if (widthInput.value * heightInput.value > MAX_AREA || heightInput.value <= 0)
        if (widthInput.value * heightInput.value > 15000 * 15000 || heightInput.value <= 0)
        {
            heightInput.style.backgroundColor = 'red';
        }
        else
        {
            heightInput.style.backgroundColor = '';
        }
    }

    mxEvent.addListener(zoomInput, 'change', function()
    {
        var s = Math.max(0, parseFloat(zoomInput.value) || 100) / 100;
        zoomInput.value = parseFloat((s * 100).toFixed(2));
        
        if (width > 0)
        {
            widthInput.value = Math.floor(width * s);
            heightInput.value = Math.floor(height * s);
        }
        else
        {
            zoomInput.value = '100';
            widthInput.value = width;
            heightInput.value = height;
        }
        
        checkValues();
    });

    mxEvent.addListener(widthInput, 'change', function()
    {
        var s = parseInt(widthInput.value) / width;
        
        if (s > 0)
        {
            zoomInput.value = parseFloat((s * 100).toFixed(2));
            heightInput.value = Math.floor(height * s);
        }
        else
        {
            zoomInput.value = '100';
            widthInput.value = width;
            heightInput.value = height;
        }
        
        checkValues();
    });

    mxEvent.addListener(heightInput, 'change', function()
    {
        var s = parseInt(heightInput.value) / height;
        
        if (s > 0)
        {
            zoomInput.value = parseFloat((s * 100).toFixed(2));
            widthInput.value = Math.floor(width * s);
        }
        else
        {
            zoomInput.value = '100';
            widthInput.value = width;
            heightInput.value = height;
        }
        
        checkValues();
    });
    
    row = document.createElement('tr');
    td = document.createElement('td');
    td.setAttribute('align', 'right');
    td.style.paddingTop = '22px';
    td.colSpan = 2;
    
    var saveBtn = mxUtils.button(mxResources.get('export'), mxUtils.bind(this, function()
    {
        if (parseInt(zoomInput.value) <= 0)
        {
            console.log(mxResources.get('drawingEmpty'))
            // messageError(mxResources.get('drawingEmpty'));
        }
        else
        {
            var name = nameInput.value;
            var format = imageFormatSelect.value;
            var s = Math.max(0, parseFloat(zoomInput.value) || 100) / 100;
            var b = Math.max(0, parseInt(borderInput.value));
            var bg = graph.background;
            
            if ((format == 'svg' || format == 'png') && transparentCheckbox.checked)
            {
                bg = null;
            }
            else if (bg == null || bg == mxConstants.NONE)
            {
                bg = '#ffffff';
            }
            
            ExportDialog.lastBorderValue = b;
            ExportDialog.exportFile(editorUi, name, format, bg, s, b);
        }
    }));
    saveBtn.className = 'geBtn gePrimaryBtn';
    
    var cancelBtn = mxUtils.button(mxResources.get('cancel'), function()
    {
        editorUi.hideDialog();
    });
    cancelBtn.className = 'geBtn';
    td.appendChild(cancelBtn);
    td.appendChild(saveBtn);

    row.appendChild(td);
    tbody.appendChild(row);
    table.appendChild(tbody);

    this.container = table;
};
/**
 * Remembers last value for border.
 */
ExportDialog.lastBorderValue = 0;
/**
 * Global switches for the export dialog.
 */
ExportDialog.showGifOption = false;
/**
 * Global switches for the export dialog.
 */
ExportDialog.showXmlOption = true;
/**
 * Hook for getting the export format. Returns null for the default
 * intermediate XML export format or a function that returns the
 * parameter and value to be used in the request in the form
 * key=value, where value should be URL encoded.
 */
ExportDialog.exportFile = function(editorUi, name, format, bg, s, b)
{
    var graph = editorUi.editor.graph;
    
    if (format == 'xml')
    {
        ExportDialog.saveLocalFile(editorUi, mxUtils.getXml(editorUi.editor.getGraphXml()), name, format);
    }
    else if (format == 'svg')
    {
        ExportDialog.saveLocalFile(editorUi, mxUtils.getXml(graph.getSvg(bg, s, b)), name, format);
    }
    else
    {
        var bounds = graph.getGraphBounds();
        
        // New image export
        var xmlDoc = mxUtils.createXmlDocument();
        var root = xmlDoc.createElement('output');
        xmlDoc.appendChild(root);
        
        // Renders graph. Offset will be multiplied with state's scale when painting state.
        var xmlCanvas = new mxXmlCanvas2D(root);
        xmlCanvas.translate(Math.floor((b / s - bounds.x) / graph.view.scale),
            Math.floor((b / s - bounds.y) / graph.view.scale));
        xmlCanvas.scale(s / graph.view.scale);
        
        var imgExport = new mxImageExport();
        imgExport.drawState(graph.getView().getState(graph.model.root), xmlCanvas);
        
        // Puts request data together
        var param = 'xml=' + encodeURIComponent(mxUtils.getXml(root));
        var w = Math.ceil(bounds.width * s / graph.view.scale + 2 * b);
        var h = Math.ceil(bounds.height * s / graph.view.scale + 2 * b);
        
        // Requests image if request is valid
        if (param.length <= 10485760 && w * h < 15000 * 15000)
        {
            editorUi.hideDialog();
           // var req = new mxXmlRequest(EXPORT_URL, 'format=' + format +
           var req = new mxXmlRequest(null, 'format=' + format +
                '&filename=' + encodeURIComponent(name) +
                '&bg=' + ((bg != null) ? bg : 'none') +
                '&w=' + w + '&h=' + h + '&' + param);
            req.simulate(document, '_blank');
        }
        else
        {
            console.log(mxResources.get('drawingTooLarge'))
            // messageError(mxResources.get('drawingTooLarge'));
        }
    }
};
/**
 * Hook for getting the export format. Returns null for the default
 * intermediate XML export format or a function that returns the
 * parameter and value to be used in the request in the form
 * key=value, where value should be URL encoded.
 */
ExportDialog.saveLocalFile = function(editorUi, data, filename, format)
{
    //if (data.length < MAX_REQUEST_SIZE)
    //----fix---//
    // if (data.length < 10485760)
    // {
    //     editorUi.hideDialog();
    //     var req = new mxXmlRequest(SAVE_URL, 'xml=' + encodeURIComponent(data) + '&filename=' +
    //         encodeURIComponent(filename) + '&format=' + format);
    //     req.simulate(document, '_blank');
    // }
    // else
    // {
    //     console.log(mxResources.get('drawingTooLarge'))
    //     // messageError(mxResources.get('drawingTooLarge'));
    //     mxUtils.popup(xml);
    // }
    //----fix---//
};

/**
 * Constructs a new metadata dialog.
 */
var EditDataDialog = function(ui, cell)
{
    var div   = document.createElement('div');
    var graph = ui.editor.graph;
    
    var value = graph.getModel().getValue(cell);
    
    // Converts the value to an XML node
    if (!mxUtils.isNode(value))
    {
        var doc = mxUtils.createXmlDocument();
        var obj = doc.createElement('object');
        obj.setAttribute('label', value || '');
        value = obj;
    }

    // Creates the dialog contents
    var form = new mxForm('properties');
    form.table.style.width = '100%';

    var names = [];
    var texts = [];
    var count = 0;
    var attrs = value.attributes;

    var id = (EditDataDialog.getDisplayIdForCell != null) ? EditDataDialog.getDisplayIdForCell(ui, cell) : null;
    
    var addRemoveButton = function(text, name)
    {
        var wrapper = document.createElement('div');
        wrapper.style.position = 'relative';
        wrapper.style.paddingRight = '20px';
        wrapper.style.boxSizing = 'border-box';
        wrapper.style.width = '100%';
        
        var removeAttr = document.createElement('a');
        var img = mxUtils.createImage(Dialog.prototype.closeImage);
        img.style.height = '9px';
        img.style.fontSize = '9px';
        img.style.marginBottom = (mxClient.IS_IE11) ? '-1px' : '5px';
        
        removeAttr.className = 'geButton';
        removeAttr.setAttribute('title', mxResources.get('delete'));
        removeAttr.style.position = 'absolute';
        removeAttr.style.top = '4px';
        removeAttr.style.right = '0px';
        removeAttr.style.margin = '0px';
        removeAttr.style.width = '9px';
        removeAttr.style.height = '9px';
        removeAttr.style.cursor = 'pointer';
        removeAttr.appendChild(img);
        
        var removeAttrFn = (function(name)
        {
            return function()
            {
                var count = 0;
                
                for (var j = 0; j < names.length; j++)
                {
                    if (names[j] == name)
                    {
                        texts[j] = null;
                        form.table.deleteRow(count + ((id != null) ? 1 : 0));
                        
                        break;
                    }
                    
                    if (texts[j] != null)
                    {
                        count++;
                    }
                }
            };
        })(name);
        
        mxEvent.addListener(removeAttr, 'click', removeAttrFn);
        
        var parent = text.parentNode;
        wrapper.appendChild(text);
        wrapper.appendChild(removeAttr);
        parent.appendChild(wrapper);
    };
    var addTextArea = function(index, name, value)
    {
        names[index] = name;
        texts[index] = form.addTextarea(names[count] + ':', value, 2);
        texts[index].style.width = '100%';
        
        addRemoveButton(texts[index], name);
    };
    
    var temp = [];
    var isLayer = graph.getModel().getParent(cell) == graph.getModel().getRoot();

    for (var i = 0; i < attrs.length; i++)
    {
        if ((isLayer || attrs[i].nodeName != 'label') && attrs[i].nodeName != 'placeholders')
            temp.push({name: attrs[i].nodeName, value: attrs[i].nodeValue});
    }
    
    // Sorts by name
    temp.sort(function(a, b)
    {
        if (a.name < b.name)
        {
            return -1;
        }
        else if (a.name > b.name)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    });

    if (id != null)
    {	
        var text = document.createElement('div');
        text.style.width = '100%';
        //text.style.fontSize = '11px';
        text.style.textAlign = 'center';
        mxUtils.write(text, id);
        form.addField(mxResources.get('id') + ':', text);
    }
    
    for (var i = 0; i < temp.length; i++)
    {
        addTextArea(count, temp[i].name, temp[i].value);
        count++;
    }
    
    var top = document.createElement('div');
    top.style.cssText = 'position:absolute;left:30px;right:30px;overflow-y:auto;top:30px;bottom:80px;';
    top.appendChild(form.table);

    var newProp = document.createElement('div');
    newProp.style.boxSizing    = 'border-box';
    newProp.style.paddingRight = '160px';
    newProp.style.whiteSpace   = 'nowrap';
    newProp.style.marginTop    = '6px';
    newProp.style.width        = '100%';
    
    var nameInput = document.createElement('input');
    nameInput.setAttribute('placeholder', mxResources.get('enterPropertyName'));
    nameInput.setAttribute('type', 'text');
    nameInput.setAttribute('size', (mxClient.IS_IE || mxClient.IS_IE11) ? '36' : '40');
    nameInput.style.boxSizing = 'border-box';
    nameInput.style.marginLeft = '2px';
    nameInput.style.width = '100%';
    
    newProp.appendChild(nameInput);
    top.appendChild(newProp);
    div.appendChild(top);
    
    var addBtn = mxUtils.button(mxResources.get('addProperty'), function()
    {
        var name = nameInput.value;

        // Avoid ':' in attribute names which seems to be valid in Chrome
        if (name.length > 0 && name != 'label' && name != 'placeholders' && name.indexOf(':') < 0)
        {
            try
            {
                var idx = mxUtils.indexOf(names, name);
                
                if (idx >= 0 && texts[idx] != null)
                {
                    texts[idx].focus();
                }
                else
                {
                    // Checks if the name is valid
                    var clone = value.cloneNode(false);
                    clone.setAttribute(name, '');
                    
                    if (idx >= 0)
                    {
                        names.splice(idx, 1);
                        texts.splice(idx, 1);
                    }

                    names.push(name);
                    var text = form.addTextarea(name + ':', '', 2);
                    text.style.width = '100%';
                    texts.push(text);
                    addRemoveButton(text, name);

                    text.focus();
                }

                addBtn.setAttribute('disabled', 'disabled');
                nameInput.value = '';
            }
            catch (e)
            {
                console.log('error')
                // messageError(e.message);
            }
        }
        else
        {
            console.log(mxResources.get('invalidName'))
            // messageError(mxResources.get('invalidName'));
        }
    });
    
    this.init = function()
    {
        if (texts.length > 0)
        {
            texts[0].focus();
        }
        else
        {
            nameInput.focus();
        }
    };
    
    addBtn.setAttribute('title', mxResources.get('addProperty'));
    addBtn.setAttribute('disabled', 'disabled');
    addBtn.style.textOverflow = 'ellipsis';
    addBtn.style.position = 'absolute';
    addBtn.style.overflow = 'hidden';
    addBtn.style.width = '144px';
    addBtn.style.right = '0px';
    addBtn.className = 'geBtn';
    newProp.appendChild(addBtn);

    var cancelBtn = mxUtils.button(mxResources.get('cancel'), function()
    {
        ui.hideDialog.apply(ui, arguments);
    });
    cancelBtn.className = 'geBtn';
    
    var applyBtn = mxUtils.button(mxResources.get('apply'), function()
    {
        try
        {
            ui.hideDialog.apply(ui, arguments);
            
            // Clones and updates the value
            value = value.cloneNode(true);
            var removeLabel = false;
            
            for (var i = 0; i < names.length; i++)
            {
                if (texts[i] == null)
                {
                    value.removeAttribute(names[i]);
                }
                else
                {
                    value.setAttribute(names[i], texts[i].value);
                    removeLabel = removeLabel || (names[i] == 'placeholder' && value.getAttribute('placeholders') == '1');
                }
            }
            
            // Removes label if placeholder is assigned
            if (removeLabel)
                value.removeAttribute('label');
            
            // Updates the value of the cell (undoable)
            graph.getModel().setValue(cell, value);
        }
        catch (e)
        {
            HELP.log(e);
            console.log('error')
            // messageError(e.message);
        }
    });
    applyBtn.className = 'geBtn gePrimaryBtn';
    
    function updateAddBtn()
    {
        if (nameInput.value.length > 0)
        {
            addBtn.removeAttribute('disabled');
        }
        else
        {
            addBtn.setAttribute('disabled', 'disabled');
        }
    };
    mxEvent.addListener(nameInput, 'keyup', updateAddBtn);
    
    // Catches all changes that don't fire a keyup (such as paste via mouse)
    mxEvent.addListener(nameInput, 'change', updateAddBtn);
    
    var buttons = document.createElement('div');
    buttons.style.cssText = 'position:absolute;left:30px;right:30px;text-align:right;bottom:30px;height:40px;'
    
    if (ui.editor.graph.getModel().isVertex(cell) || ui.editor.graph.getModel().isEdge(cell))
    {
        var replace = document.createElement('span');
        replace.style.marginRight = '10px';
        //var input = document.createElement('input');
        //input.setAttribute('type', 'checkbox');
        //input.style.marginRight = '6px';
        
        //if (value.getAttribute('placeholders') == '1')
        //{
        //    input.setAttribute('checked', 'checked');
        //    input.defaultChecked = true;
        //}
    
        //mxEvent.addListener(input, 'click', function()
        //{
        //    if (value.getAttribute('placeholders') == '1')
        //    {
        //        value.removeAttribute('placeholders');
        //    }
        //    else
        //    {
        //        value.setAttribute('placeholders', '1');
        //    }
        //});
        
        //replace.appendChild(input);
        //mxUtils.write(replace, mxResources.get('placeholders'));        
        buttons.appendChild(replace);
    }
    
    buttons.appendChild(cancelBtn);
    buttons.appendChild(applyBtn);
    div.appendChild(buttons);

    this.container = div;
};
EditDataDialog.getDisplayIdForCell = function(ui, cell)
{
    var id = null;
    if (ui.editor.graph.getModel().getParent(cell) != null)
        id = cell.getId();
    return id;
};

/**
 * Constructs a new link dialog.
 */
var LinkDialog = function(editorUi, initialValue, btnLabel, fn)
{
    var div = document.createElement('div');
    mxUtils.write(div, mxResources.get('editLink') + ':');
    
    var inner = document.createElement('div');
    inner.className = 'geTitle';
    inner.style.backgroundColor = 'transparent';
    inner.style.borderColor = 'transparent';
    inner.style.whiteSpace = 'nowrap';
    inner.style.textOverflow = 'clip';
    inner.style.cursor = 'default';
    
    inner.style.paddingRight = '20px';
    
    var linkInput = document.createElement('input');
    linkInput.setAttribute('value', initialValue);
    linkInput.setAttribute('placeholder', 'http://www.example.com/');
    linkInput.setAttribute('type', 'text');
    linkInput.style.marginTop = '6px';
    linkInput.style.width = '400px';
    linkInput.style.backgroundImage = 'url(\'' + Dialog.prototype.clearImage + '\')';
    linkInput.style.backgroundRepeat = 'no-repeat';
    linkInput.style.backgroundPosition = '100% 50%';
    linkInput.style.paddingRight = '14px';
    
    var cross = document.createElement('div');
    cross.setAttribute('title', mxResources.get('reset'));
    cross.style.position = 'relative';
    cross.style.left = '-16px';
    cross.style.width = '12px';
    cross.style.height = '14px';
    cross.style.cursor = 'pointer';

    cross.style.display = 'inline-block';
    cross.style.top = '3px';
    
    // Needed to block event transparency in IE
    cross.style.background = 'url(\'' + mxUtils.transparentImage + '\')';

    mxEvent.addListener(cross, 'click', function()
    {
        linkInput.value = '';
        linkInput.focus();
    });
    
    inner.appendChild(linkInput);
    inner.appendChild(cross);
    div.appendChild(inner);
    
    this.init = function()
    {
        linkInput.focus();
        
        if (mxClient.IS_GC || mxClient.IS_FF || document.documentMode >= 5)
        {
            linkInput.select();
        }
        else
        {
            document.execCommand('selectAll', false, null);
        }
    };
    
    var btns = document.createElement('div');
    btns.style.marginTop = '18px';
    btns.style.textAlign = 'right';

    mxEvent.addListener(linkInput, 'keypress', function(e)
    {
        if (e.keyCode == 13)
        {
            editorUi.hideDialog();
            fn(linkInput.value);
        }
    });

    var cancelBtn = mxUtils.button(mxResources.get('cancel'), function()
    {
        editorUi.hideDialog();
    });
    cancelBtn.className = 'geBtn'; 
    btns.appendChild(cancelBtn);
    
    var mainBtn = mxUtils.button(btnLabel, function()
    {
        editorUi.hideDialog();
        fn(linkInput.value);
    });
    mainBtn.className = 'geBtn gePrimaryBtn';
    btns.appendChild(mainBtn);
    div.appendChild(btns);

    this.container = div;
};

/**
 * Constructs a new outline window.
 */
var OutlineWindow = function(editorUi, x, y, w, h)
{
    var graph = editorUi.editor.graph;

    var div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.width    = '100%';
    div.style.height   = '100%';
    div.style.border   = '1px solid whiteSmoke';
    div.style.overflow = 'hidden';

    this.window = new mtWindow(mxResources.get('outline'), div, x, y, w, h, true, true);
    this.window.minimumSize = new mxRectangle(0, 0, w, 80);
    this.window.destroyOnClose = false;
    this.window.setMaximizable(false);
    this.window.setResizable(true);
    this.window.setClosable(true);
    this.window.setVisible(true);

    var outline = new mxOutline(graph);

    this.window.setLocation = function(x, y)
    {
        var iw = window.innerWidth || document.body.clientWidth || document.documentElement.clientWidth;
        var ih = window.innerHeight || document.body.clientHeight || document.documentElement.clientHeight;
        
        x = Math.max(0, Math.min(x, iw - this.table.clientWidth));
        y = Math.max(0, Math.min(y, ih - this.table.clientHeight));

        if (this.getX() != x || this.getY() != y)
            mtWindow.prototype.setLocation.apply(this, arguments);
    };
    var resizeListener = mxUtils.bind(this, function ()
    {
        if (this.window.div.clientHeight > graph.container.clientHeight)
            this.window.setSize(this.window.div.style.width, graph.container.clientHeight - 5);
        this.window.setLocation(this.window.getX(), this.window.getY());
        outline.update(false);
    });
    mxEvent.addListener(window, 'resize', resizeListener);    

    this.destroy = function ()
    {
        mxEvent.removeListener(window, 'resize', resizeListener);
        this.window.destroy();
        outline.destroy();
    };

    this.window.addListener(mxEvent.RESIZE, mxUtils.bind(this, function()
    {
        outline.update(false);
        outline.outline.sizeDidChange();
    }));
    this.window.addListener(mxEvent.SHOW, mxUtils.bind(this, function()
    {
        this.window.fit();
        outline.suspended = false;
        outline.outline.refresh();
        outline.update();
    }));
    this.window.addListener(mxEvent.HIDE, mxUtils.bind(this, function()
    {
        outline.suspended = true;
    }));
    this.window.addListener(mxEvent.NORMALIZE, mxUtils.bind(this, function()
    {
        outline.suspended = false;
        outline.update();
    }));
    this.window.addListener(mxEvent.MINIMIZE, mxUtils.bind(this, function()
    {
        outline.suspended = true;
    }));

    var outlineCreateGraph = outline.createGraph;
    outline.createGraph = function(container)
    {
        var g = outlineCreateGraph.apply(this, arguments);
        g.gridEnabled = false;
        g.pageScale   = graph.pageScale;
        g.pageFormat  = graph.pageFormat;
        g.background  = (graph.background == null || graph.background == mxConstants.NONE) ? graph.defaultPageBackgroundColor : graph.background;
        g.pageVisible = graph.pageVisible;

        var current = mxUtils.getCurrentStyle(graph.container);
        div.style.backgroundColor = current.backgroundColor;

        return g;
    };
    outline.getOutlineOffset = function (scale)
    {
        return new mxPoint(20, 20);
    };

    function update()
    {
        outline.outline.pageScale = graph.pageScale;
        outline.outline.pageFormat = graph.pageFormat;
        outline.outline.pageVisible = graph.pageVisible;
        outline.outline.background = (graph.background == null || graph.background == mxConstants.NONE) ? graph.defaultPageBackgroundColor : graph.background;
        
        var current = mxUtils.getCurrentStyle(graph.container);
        div.style.backgroundColor = current.backgroundColor;

        if (graph.view.backgroundPageShape != null && outline.outline.view.backgroundPageShape != null)
            outline.outline.view.backgroundPageShape.fill = graph.view.backgroundPageShape.fill;
        
        outline.outline.refresh();
    }

    outline.init(div);
    outline.setZoomEnabled(false);

    editorUi.editor.addListener('resetGraphView', update);
    editorUi.addListener('pageFormatChanged', update);
    editorUi.addListener('backgroundColorChanged', update);
    editorUi.addListener('backgroundImageChanged', update);
    editorUi.addListener('pageViewChanged', function()
    {
        update();
        outline.update(true);
    });
    
    if (outline.outline.dialect == mxConstants.DIALECT_SVG)
    {
        var zoomInAction  = editorUi.actions.get('zoomIn');
        var zoomOutAction = editorUi.actions.get('zoomOut');
        
        mxEvent.addMouseWheelListener(function(evt, up)
        {
            var outlineWheel = false;

            var source = mxEvent.getSource(evt);
            while (source != null)
            {
                if (source == outline.outline.view.canvas.ownerSVGElement)
                {
                    outlineWheel = true;
                    break;
                }
                source = source.parentNode;
            }
    
            if (outlineWheel)
            {
                if (up)
                    zoomInAction.funct();
                else
                    zoomOutAction.funct();
    
                //mxEvent.consume(evt);
            }
        });
    }
};

/**
 * Constructs a new layers window.
 */
var LayersWindow = function(editorUi, x, y, w, h)
{
    var graph = editorUi.editor.graph;
    
    var div = document.createElement('div');
    div.style.userSelect = 'none';
    div.style.background = (Dialog.backdropColor == 'white') ? 'whiteSmoke' : Dialog.backdropColor;
    div.style.border = '1px solid whiteSmoke';
    div.style.height = '100%';
    div.style.marginBottom = '10px';
    div.style.overflow = 'auto';

    var tbarHeight = '26px';
    
    var listDiv = document.createElement('div')
    listDiv.style.backgroundColor = (Dialog.backdropColor == 'white') ? '#dcdcdc' : Dialog.backdropColor;
    listDiv.style.position = 'absolute';
    listDiv.style.overflow = 'auto';
    listDiv.style.left = '0px';
    listDiv.style.right = '0px';
    listDiv.style.top = '0px';
    listDiv.style.bottom = (parseInt(tbarHeight) + 7) + 'px';
    div.appendChild(listDiv);
    
    var dragSource = null;
    var dropIndex = null;
    
    mxEvent.addListener(div, 'dragover', function(evt)
    {
        evt.dataTransfer.dropEffect = 'move';
        dropIndex = 0;
        evt.stopPropagation();
        evt.preventDefault();
    });
    
    // Workaround for "no element found" error in FF
    mxEvent.addListener(div, 'drop', function(evt)
    {
        evt.stopPropagation();
        evt.preventDefault();
    });

    var layerCount = null;
    var selectionLayer = null;
    
    var ldiv = document.createElement('div');
    
    ldiv.className = 'geToolbarContainer';
    ldiv.style.position = 'absolute';
    ldiv.style.bottom = '0px';
    ldiv.style.left = '0px';
    ldiv.style.right = '0px';
    ldiv.style.height = tbarHeight;
    ldiv.style.overflow = 'hidden';
    ldiv.style.padding = '4px 0px 3px 0px';
    ldiv.style.backgroundColor = (Dialog.backdropColor == 'white') ? 'whiteSmoke' : Dialog.backdropColor;
    ldiv.style.borderWidth = '1px 0px 0px 0px';
    ldiv.style.borderColor = '#c3c3c3';
    ldiv.style.borderStyle = 'solid';
    ldiv.style.display = 'block';
    ldiv.style.whiteSpace = 'nowrap';
    
    var link = document.createElement('a');
    link.className = 'geButton';
        
    var removeLink = link.cloneNode();
    removeLink.innerHTML = '<div class="geSprite geSprite-delete" style="display:inline-block;"></div>';

    mxEvent.addListener(removeLink, 'click', function(evt)
    {
        if (graph.isEnabled())
        {
            graph.model.beginUpdate();
            try
            {
                var index = graph.model.root.getIndex(selectionLayer);
                graph.removeCells([selectionLayer], false);
                
                // Creates default layer if no layer exists
                if (graph.model.getChildCount(graph.model.root) == 0)
                {
                    graph.model.add(graph.model.root, new mxCell());
                    graph.setDefaultParent(null);
                }
                else if (index > 0 && index <= graph.model.getChildCount(graph.model.root))
                {
                    graph.setDefaultParent(graph.model.getChildAt(graph.model.root, index - 1));
                }
                else
                {
                    graph.setDefaultParent(null);
                }
            }
            finally
            {
                graph.model.endUpdate();
            }
        }
        
        mxEvent.consume(evt);
    });
    
    if (!graph.isEnabled())
        removeLink.className = 'geButton mxDisabled';
    
    ldiv.appendChild(removeLink);

    var insertLink = link.cloneNode();
    insertLink.setAttribute('title', mxUtils.trim(mxResources.get('moveSelectionTo', [''])));
    insertLink.innerHTML = '<div class="geSprite geSprite-insert" style="display:inline-block;"></div>';
    
    mxEvent.addListener(insertLink, 'click', function(evt)
    {
        if (graph.isEnabled() && !graph.isSelectionEmpty())
        {
            editorUi.editor.graph.popupMenuHandler.hideMenu();
            
            var menu = new mxPopupMenu(mxUtils.bind(this, function(menu, parent)
            {
                for (var i = layerCount - 1; i >= 0; i--)
                {
                    (mxUtils.bind(this, function(child)
                    {
                        var item = menu.addItem(graph.convertValueToString(child) ||
                                mxResources.get('background'), null, mxUtils.bind(this, function()
                        {
                            graph.moveCells(graph.getSelectionCells(), 0, 0, false, child);
                        }), parent);
                        
                        if (graph.getSelectionCount() == 1 && graph.model.isAncestor(child, graph.getSelectionCell()))
                        {
                            menu.addCheckmark(item, Editor.checkmarkImage);
                        }
                        
                    }))(graph.model.getChildAt(graph.model.root, i));
                }
            }));
            menu.div.className += ' geMenubarMenu';
            menu.smartSeparators = true;
            menu.showDisabled = true;
            menu.autoExpand = true;
            
            // Disables autoexpand and destroys menu when hidden
            menu.hideMenu = mxUtils.bind(this, function()
            {
                mxPopupMenu.prototype.hideMenu.apply(menu, arguments);
                menu.destroy();
            });
    
            var offset = mxUtils.getOffset(insertLink);
            menu.popup(offset.x, offset.y + insertLink.offsetHeight, null, evt);
            
            // Allows hiding by clicking on document
            editorUi.setCurrentMenu(menu);
        }
    });

    ldiv.appendChild(insertLink);
    
    var dataLink = link.cloneNode();
    dataLink.innerHTML = '<div class="geSprite geSprite-dots" style="display:inline-block;"></div>';
    dataLink.setAttribute('title', mxResources.get('rename'));

    mxEvent.addListener(dataLink, 'click', function(evt)
    {
        if (graph.isEnabled())
            editorUi.showDataDialog(selectionLayer);
        mxEvent.consume(evt);
    });
    
    if (!graph.isEnabled())
        dataLink.className = 'geButton mxDisabled';
    ldiv.appendChild(dataLink);
    
    function renameLayer(layer)
    {
        if (graph.isEnabled() && layer != null)
        {
            var label = graph.convertValueToString(layer);
            var dlg = new FilenameDialog(editorUi, label || mxResources.get('background'), mxResources.get('rename'), mxUtils.bind(this, function(newValue)
            {
                if (newValue != null)
                {
                    graph.cellLabelChanged(layer, newValue);
                }
            }), mxResources.get('enterName'));
            editorUi.showDialog(dlg.container, 320, 80, true, true);
            dlg.init();
        }
    };
    
    var duplicateLink = link.cloneNode();
    duplicateLink.innerHTML = '<div class="geSprite geSprite-duplicate" style="display:inline-block;"></div>';
    
    mxEvent.addListener(duplicateLink, 'click', function(evt)
    {
        if (graph.isEnabled())
        {
            var newCell = null;
            graph.model.beginUpdate();
            try
            {
                newCell = graph.cloneCell(selectionLayer);
                graph.cellLabelChanged(newCell, mxResources.get('untitledLayer'));
                newCell.setVisible(true);
                newCell = graph.addCell(newCell, graph.model.root);
                graph.setDefaultParent(newCell);
            }
            finally
            {
                graph.model.endUpdate();
            }

            if (newCell != null && !graph.isCellLocked(newCell))
            {
                graph.selectAll(newCell);
            }
        }
    });
    
    if (!graph.isEnabled())
        duplicateLink.className = 'geButton mxDisabled';

    ldiv.appendChild(duplicateLink);

    var addLink = link.cloneNode();
    addLink.innerHTML = '<div class="geSprite geSprite-plus" style="display:inline-block;"></div>';
    addLink.setAttribute('title', mxResources.get('addLayer'));
    
    mxEvent.addListener(addLink, 'click', function(evt)
    {
        if (graph.isEnabled())
        {
            graph.model.beginUpdate();
            
            try
            {
                var cell = graph.addCell(new mxCell(mxResources.get('untitledLayer')), graph.model.root);
                graph.setDefaultParent(cell);
            }
            finally
            {
                graph.model.endUpdate();
            }
        }
        
        mxEvent.consume(evt);
    });
    
    if (!graph.isEnabled())
        addLink.className = 'geButton mxDisabled';
    
    ldiv.appendChild(addLink);
    div.appendChild(ldiv);	
    
    function refresh()
    {
        layerCount = graph.model.getChildCount(graph.model.root);
        listDiv.innerHTML = '';

        function addLayer(index, label, child, defaultParent)
        {
            var ldiv = document.createElement('div');
            ldiv.className = 'geToolbarContainer';

            ldiv.style.overflow = 'hidden';
            ldiv.style.position = 'relative';
            ldiv.style.padding = '4px';
            ldiv.style.height = '22px';
            ldiv.style.display = 'block';
            ldiv.style.backgroundColor = (Dialog.backdropColor == 'white') ? 'whiteSmoke' : Dialog.backdropColor;
            ldiv.style.borderWidth = '0px 0px 1px 0px';
            ldiv.style.borderColor = '#c3c3c3';
            ldiv.style.borderStyle = 'solid';
            ldiv.style.whiteSpace = 'nowrap';
            ldiv.setAttribute('title', label);
            
            var left = document.createElement('div');
            left.style.display = 'inline-block';
            left.style.width = '100%';
            left.style.textOverflow = 'ellipsis';
            left.style.overflow = 'hidden';
            
            mxEvent.addListener(ldiv, 'dragover', function(evt)
            {
                evt.dataTransfer.dropEffect = 'move';
                dropIndex = index;
                evt.stopPropagation();
                evt.preventDefault();
            });
            
            mxEvent.addListener(ldiv, 'dragstart', function(evt)
            {
                dragSource = ldiv;
                
                // Workaround for no DnD on DIV in FF
                if (mxClient.IS_FF)
                {
                    // LATER: Check what triggers a parse as XML on this in FF after drop
                    evt.dataTransfer.setData('Text', '<layer/>');
                }
            });
            
            mxEvent.addListener(ldiv, 'dragend', function(evt)
            {
                if (dragSource != null && dropIndex != null)
                {
                    graph.addCell(child, graph.model.root, dropIndex);
                }

                dragSource = null;
                dropIndex = null;
                evt.stopPropagation();
                evt.preventDefault();
            });

            var btn = document.createElement('img');
            btn.setAttribute('draggable', 'false');
            btn.setAttribute('align', 'top');
            btn.setAttribute('border', '0');
            btn.style.padding = '4px';
            btn.setAttribute('title', mxResources.get('lockUnlock'));

            var state = graph.view.getState(child);
                var style = (state != null) ? state.style : graph.getCellStyle(child);

            if (mxUtils.getValue(style, 'locked', '0') == '1')
            {
                btn.setAttribute('src', Dialog.prototype.lockedImage);
            }
            else
            {
                btn.setAttribute('src', Dialog.prototype.unlockedImage);
            }
            
            if (graph.isEnabled())
            {
                btn.style.cursor = 'pointer';
            }
            
            mxEvent.addListener(btn, 'click', function(evt)
            {
                if (graph.isEnabled())
                {
                    var value = null;
                    
                    graph.getModel().beginUpdate();
                    try
                    {
                        value = (mxUtils.getValue(style, 'locked', '0') == '1') ? null : '1';
                        graph.setCellStyles('locked', value, [child]);
                    }
                    finally
                    {
                        graph.getModel().endUpdate();
                    }

                    if (value == '1')
                    {
                        graph.removeSelectionCells(graph.getModel().getDescendants(child));
                    }
                    
                    mxEvent.consume(evt);
                }
            });

            left.appendChild(btn);

            var inp = document.createElement('input');
            inp.setAttribute('type', 'checkbox');
            inp.setAttribute('title', mxResources.get('hideIt', [child.value || mxResources.get('background')]));
            inp.style.marginLeft = '4px';
            inp.style.marginRight = '6px';
            inp.style.marginTop = '4px';
            left.appendChild(inp);
            
            if (graph.model.isVisible(child))
            {
                inp.setAttribute('checked', 'checked');
                inp.defaultChecked = true;
            }

            mxEvent.addListener(inp, 'click', function(evt)
            {
                graph.model.setVisible(child, !graph.model.isVisible(child));
                mxEvent.consume(evt);
            });

            mxUtils.write(left, label);
            ldiv.appendChild(left);
            
            if (graph.isEnabled())
            {
                // Fallback if no drag and drop is available
                if (mxClient.IS_TOUCH || mxClient.IS_POINTER || (mxClient.IS_IE && document.documentMode < 10))
                {
                    var right = document.createElement('div');
                    right.style.display = 'block';
                    right.style.textAlign = 'right';
                    right.style.whiteSpace = 'nowrap';
                    right.style.position = 'absolute';
                    right.style.right = '6px';
                    right.style.top = '6px';
        
                    // Poor man's change layer order
                    if (index > 0)
                    {
                        var img2 = document.createElement('a');
                        
                        img2.setAttribute('title', mxResources.get('toBack'));
                        
                        img2.className = 'geButton';
                        img2.style.cssFloat = 'none';
                        img2.innerHTML = '&#9660;';
                        img2.style.width = '14px';
                        img2.style.height = '14px';
                        //img2.style.fontSize = '14px';
                        img2.style.margin = '0px';
                        img2.style.marginTop = '-1px';
                        right.appendChild(img2);
                        
                        mxEvent.addListener(img2, 'click', function(evt)
                        {
                            if (graph.isEnabled())
                            {
                                graph.addCell(child, graph.model.root, index - 1);
                            }
                            
                            mxEvent.consume(evt);
                        });
                    }
        
                    if (index >= 0 && index < layerCount - 1)
                    {
                        var img1 = document.createElement('a');
                        
                        img1.setAttribute('title', mxResources.get('toFront'));
                        
                        img1.className = 'geButton';
                        img1.style.cssFloat = 'none';
                        img1.innerHTML = '&#9650;';
                        img1.style.width = '14px';
                        img1.style.height = '14px';
                        //img1.style.fontSize = '14px';
                        img1.style.margin = '0px';
                        img1.style.marginTop = '-1px';
                        right.appendChild(img1);
                        
                        mxEvent.addListener(img1, 'click', function(evt)
                        {
                            if (graph.isEnabled())
                            {
                                graph.addCell(child, graph.model.root, index + 1);
                            }
                            
                            mxEvent.consume(evt);
                        });
                    }
                    
                    ldiv.appendChild(right);
                }
                
                if (!mxClient.IS_IE || document.documentMode >= 10)
                {
                    ldiv.setAttribute('draggable', 'true');
                    ldiv.style.cursor = 'move';
                }
            }

            mxEvent.addListener(ldiv, 'dblclick', function(evt)
            {
                var nodeName = mxEvent.getSource(evt).nodeName;
                
                if (nodeName != 'INPUT' && nodeName != 'IMG')
                {
                    renameLayer(child);
                    mxEvent.consume(evt);
                }
            });

            if (graph.getDefaultParent() == child)
            {
                ldiv.style.background =  (Dialog.backdropColor == 'white') ? '#e6eff8' : '#505759';
                ldiv.style.fontWeight = (graph.isEnabled()) ? 'bold' : '';
                selectionLayer = child;
            }
            else
            {
                mxEvent.addListener(ldiv, 'click', function(evt)
                {
                    if (graph.isEnabled())
                    {
                        graph.setDefaultParent(defaultParent);
                        graph.view.setCurrentRoot(null);
                        refresh();
                    }
                });
            }
            
            listDiv.appendChild(ldiv);
        }
        
        // Cannot be moved or deleted
        for (var i = layerCount - 1; i >= 0; i--)
        {
            (mxUtils.bind(this, function(child)
            {
                addLayer(i, graph.convertValueToString(child) || mxResources.get('background'), child, child);
            }))(graph.model.getChildAt(graph.model.root, i));
        }
        
        var label = graph.convertValueToString(selectionLayer) || mxResources.get('background');
        removeLink.setAttribute('title', mxResources.get('removeIt', [label]));
        duplicateLink.setAttribute('title', mxResources.get('duplicateIt', [label]));
        dataLink.setAttribute('title', mxResources.get('editData'));

        if (graph.isSelectionEmpty())
            insertLink.className = 'geButton mxDisabled';
    }

    refresh();
    graph.model.addListener(mxEvent.CHANGE, function()
    {
        refresh();
    });

    graph.selectionModel.addListener(mxEvent.CHANGE, function()
    {
        if (graph.isSelectionEmpty())
            insertLink.className = 'geButton mxDisabled';
        else
            insertLink.className = 'geButton';
    });

    this.window = new mtWindow(mxResources.get('layers'), div, x, y, w, h, true, true);
    this.window.minimumSize = new mxRectangle(0, 0, w, 80);
    this.window.destroyOnClose = false;
    this.window.setMaximizable(false);
    this.window.setResizable(true);
    this.window.setClosable(true);
    this.window.setVisible(true);

    this.window.addListener(mxEvent.SHOW, mxUtils.bind(this, function()
    {
        this.window.fit();
    }));
    
    // Make refresh available via instance
    this.refreshLayers = refresh;
    
    this.window.setLocation = function(x, y)
    {
        var iw = window.innerWidth || document.body.clientWidth || document.documentElement.clientWidth;
        var ih = window.innerHeight || document.body.clientHeight || document.documentElement.clientHeight;
        
        x = Math.max(0, Math.min(x, iw - this.table.clientWidth));
        y = Math.max(0, Math.min(y, ih - this.table.clientHeight));

        if (this.getX() != x || this.getY() != y)
            mtWindow.prototype.setLocation.apply(this, arguments);
    };
    
    var resizeListener = mxUtils.bind(this, function()
    {        
        if (this.window.div.clientHeight > graph.container.clientHeight)
            this.window.setSize(this.window.div.style.width, graph.container.clientHeight - 5);
        this.window.setLocation(this.window.getX(), this.window.getY());
    });
    mxEvent.addListener(window, 'resize', resizeListener);

    this.destroy = function ()
    {
        mxEvent.removeListener(window, 'resize', resizeListener);
        this.window.destroy();
    };
};

/**
 * Constructs a new sidebar window.
 */
var SidebarWindow = function (editorUi, point, w, h)
{
    var x = point.x;
    var y = point.y;

    var graph     = editorUi.editor.graph;
    var container = editorUi.createDiv('geSidebarContainer');

    this.window = new mtWindow(mxResources.get('sidebar'), container, x, y, w, h, true, true);
    this.window.minimumSize = new mxRectangle(0, 0, w, 80);
    this.window.destroyOnClose = false;
    this.window.setMaximizable(false);
    this.window.setResizable(true);
    this.window.setClosable(true);
    this.window.setVisible(true);

    this.window.setLocation = function (x, y)
    {
        var iw = window.innerWidth || document.body.clientWidth || document.documentElement.clientWidth;
        var ih = window.innerHeight || document.body.clientHeight || document.documentElement.clientHeight;

        x = Math.max(0, Math.min(x, iw - this.table.clientWidth));
        y = Math.max(0, Math.min(y, ih - this.table.clientHeight));

        if (this.getX() != x || this.getY() != y)
            mtWindow.prototype.setLocation.apply(this, arguments);
    };

    var resizeListener = mxUtils.bind(this, function ()
    {
        if (this.window.div.clientHeight > graph.container.clientHeight)
            this.window.setSize(this.window.div.style.width, graph.container.clientHeight - 5);
        this.window.setLocation(this.window.getX(), this.window.getY());
    });
    mxEvent.addListener(window, 'resize', resizeListener);

    var sidebar = new Sidebar(editorUi, container);

    this.destroy = function ()
    {
        mxEvent.removeListener(window, 'resize', resizeListener);
        this.window.destroy();
        sidebar.destroy();
    };
    this.window.addListener(mxEvent.SHOW, mxUtils.bind(this, function ()
    {
        this.window.fit();
    }));
};

/**
 * Constructs a new format window.
 */
var FormatWindow = function (editorUi, point, w, h)
{
    var x = point.x;
    var y = point.y;

    var graph = editorUi.editor.graph;
    var container = editorUi.createDiv('geSidebarContainer geFormatContainer');

    this.window = new mtWindow(mxResources.get('properties'), container, x, y, w, h, true, true);
    this.window.minimumSize = new mxRectangle(0, 0, w, 80);
    this.window.destroyOnClose = false;
    this.window.setMaximizable(false);
    this.window.setResizable(true);
    this.window.setClosable(true);
    this.window.setVisible(true);

    this.window.setLocation = function (x, y)
    {
        var iw = window.innerWidth || document.body.clientWidth || document.documentElement.clientWidth;
        var ih = window.innerHeight || document.body.clientHeight || document.documentElement.clientHeight;

        x = Math.max(0, Math.min(x, iw - this.table.clientWidth));
        y = Math.max(0, Math.min(y, ih - this.table.clientHeight));

        if (this.getX() != x || this.getY() != y)
            mtWindow.prototype.setLocation.apply(this, arguments);
    };

    var resizeListener = mxUtils.bind(this, function ()
    {
        if (this.window.div.clientHeight > graph.container.clientHeight)
            this.window.setSize(this.window.div.style.width, graph.container.clientHeight - 5);
        this.window.setLocation(this.window.getX(), this.window.getY());
    });
    mxEvent.addListener(window, 'resize', resizeListener);

    var format = new Format(editorUi, container);

    this.destroy = function ()
    {
        mxEvent.removeListener(window, 'resize', resizeListener);
        this.window.destroy();
        format.destroy();
    };
    this.window.addListener(mxEvent.SHOW, mxUtils.bind(this, function ()
    {
        this.window.fit();
    }));
};

/**
 * Constructs a new bindings window.
 */
var BindingsWindow = function (editorUi, modal, w, h)
{
    let window = $$('bindingsWindow');
    if (window == null)
    {
        var content = editorUi.createDiv('geBindingsContainer');
        window = webix.ui({
            view: "window",
            head: mxResources.get('bindings'),
            css: "bindingsWindow",
            move: true,
            close: true,
            resize: true,
            modal: modal,
            autofocus: true,
            autofit: true,
            toFront: true,
            point: true,
            width:  w || 800,
            height: h || 500,
            id: 'bindingsWindow',
            position: "center",
            body:
            {
                rows:
                    [
                        {
                            css: "content",
                            content: content
                        },
                        {
                            view: "button", width: 0, height: 1, css: "hidden", hotkey: "esc",
                            click: function ()
                            {
                                window.hide();
                            }
                        }
                    ]
            }
        });

        // custom method
        window.setTitle = function (title)
        {
            let header = window.getHead().getChildViews()[0];
            if (header != null)
                header.setHTML(title);
        };
//---fix---//
        // var bindings = new Bindings(window, content);
        var bindings = new BindingsHandler(editorUi).Bindings(window, content);
        var editorUiIsEventIgnored = editorUi.keyHandler.isEventIgnored;
        //---fix---//
        editorUi.keyHandler.isEventIgnored = function (evt)
        {
            let ignored = editorUiIsEventIgnored.apply(this, arguments);
            if (window.isVisible())
            {
                if (window.config.modal)
                    ignored = true;
                else
                {
                    let focused = webix.UIManager.getFocus();
                    if (focused != null)
                    {
                        let topView = focused.getTopParentView();
                        if (topView != null && topView.parentElement != null)
                            ignored |= $(topView.parentElement).hasClass('geBindingsContainer');
                    }
                }
            }
            return ignored;
        };

        window.attachEvent('onShow', function ()
        {
            bindings.refresh();
            editorUi.fireEvent(new mxEventObject('bindings'));
        });
        window.attachEvent('onHide', function ()
        {
            if (!bindings.validate())
            {
                window.show();
                return;
            }
            editorUi.fireEvent(new mxEventObject('bindings'));
        });
        window.attachEvent('onViewResize', function ()
        {
            bindings.adjust();
        });

        this.destroy = function ()
        {
            bindings.destroy();
            window.destructor();
        };
    }
    return window;
};

/**
 * Constructs a new camera window.
 */
var CameraWindow = function (editorUi, srcID)
{
    let window = $$(srcID);
    if (window == null)
    {
        window = webix.ui({
            view: "window",
            head: "Камера",
            move: true,
            close: true,
            resize: true,
            width: 600,
            height: 430,
            id: srcID,
            //position: "center",
            body:
            {
                template: function (obj)
                {
                    return "<canvas id='" + srcID + "' width='100%' height='100%' style='width:100%;height:100%' />";
                }
            }
        });

        let body = window.getBody();
        let image = new Image();

        //let createQuery = function ()
        //{
        //    if (isNullOrEmpty(path.href))
        //        return null;
        //    return path.href + (path.href.indexOf('?') > 0 ? '&' : "?") + 't=' + Date.now();
        //};
        let updateView = function ()
        {
            // get last shot
            AJAX.get(API.FUNC.cameraShot, 'id=' + srcID,
                function (xhr, resp)
                {
                    if (resp != null)
                        image.src = "data:image/jpeg; base64," + resp;
                },
                function (xhr, err)
                {
                    image.src = null;
                });
        };
        let updateRoutine = mxUtils.bind(window, updateView);

        window.attachEvent('onBeforeShow', function ()
        {
            updateView();
        });
        image.onload = function ()
        {
            if (!window.context)
            {
                window.canvas = document.getElementById(srcID);
                window.context = window.canvas.getContext("2d");
            }

            // update size
            let width = body.$width;
            let height = body.$height;
            window.canvas.setAttribute("width", width);
            image.setAttribute("width", width);
            window.canvas.setAttribute("height", height);
            image.setAttribute("height", height);
            // draw image
            window.context.drawImage(this, 0, 0, width, height);
            setTimeout(updateRoutine, 300);
        };

        window.attachEvent('onHide', function ()
        {
            image.onload = null;
            window.close();
            window.destructor();
        });
    }
    return window;
};

/**
 * Constructs a new modal equipment window.
 */
var EquipmentWindow = function (editorUi, eqID)
{
    let window = $$(eqID);
    if (window == null)
    {
        let graph  = editorUi.editor.graph;
        let format = graph.pageFormat;

        window = webix.ui({
            view: "window",
            modal: true,
            head: 'Оборудование',
            move: true,
            close: true,
            resize: true,
            width:  format.width,
            height: format.height,
            id: eqID,
            position: "center",
            body:
            {
                view: "iframe",
                src: HELP.buildUrl(API.FUNC.schemeEqView, 'id=' + eqID + "&mode=layout")
            }
        });

        window.attachEvent('onHide', function ()
        {
            window.close();
            window.destructor();
        });
    }
    return window;
};

// export { 
//     ExportDialog, 
//     EditDiagramDialog, 
//     TextareaDialog, 
//     FilenameDialog, 
//     LayersWindow, 
//     SidebarWindow, 
//     FormatWindow,
//     OutlineWindow,
//     BindingsWindow,
//     ColorDialog,
//     OpenDialog,
//     LinkDialog,
//     EditDataDialog,
//     CameraWindow
// }

//Shapes.js


// Hook for custom constraints
mxShape.prototype.getConstraints = function (style, w, h)
{
    return null; // this.constraints;
};
mxShape.prototype.setTransparentBackgroundImage = function (node)
{
    node.style.backgroundImage = 'url(\'' + mxUtils.transparentImage + '\')';
};

/**
 * Registers shapes.
 */
(function ()
{
    // Cube Shape, supports size style
    function CubeShape()
    {
        mxCylinder.call(this);
    }
    mxUtils.extend(CubeShape, mxCylinder);
    CubeShape.prototype.size = 20;
    CubeShape.prototype.darkOpacity = 0;
    CubeShape.prototype.darkOpacity2 = 0;
    CubeShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        var s = Math.max(0, Math.min(w, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'size', this.size)))));
        var op = Math.max(-1, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'darkOpacity', this.darkOpacity))));
        var op2 = Math.max(-1, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'darkOpacity2', this.darkOpacity2))));
        c.translate(x, y);

        c.begin();
        c.moveTo(0, 0);
        c.lineTo(w - s, 0);
        c.lineTo(w, s);
        c.lineTo(w, h);
        c.lineTo(s, h);
        c.lineTo(0, h - s);
        c.lineTo(0, 0);
        c.close();
        c.end();
        c.fillAndStroke();

        if (!this.outline)
        {
            c.setShadow(false);

            if (op != 0)
            {
                c.setFillAlpha(Math.abs(op));
                c.setFillColor((op < 0) ? '#FFFFFF' : '#000000');
                c.begin();
                c.moveTo(0, 0);
                c.lineTo(w - s, 0);
                c.lineTo(w, s);
                c.lineTo(s, s);
                c.close();
                c.fill();
            }

            if (op2 != 0)
            {
                c.setFillAlpha(Math.abs(op2));
                c.setFillColor((op2 < 0) ? '#FFFFFF' : '#000000');
                c.begin();
                c.moveTo(0, 0);
                c.lineTo(s, s);
                c.lineTo(s, h);
                c.lineTo(0, h - s);
                c.close();
                c.fill();
            }

            c.begin();
            c.moveTo(s, h);
            c.lineTo(s, s);
            c.lineTo(0, 0);
            c.moveTo(s, s);
            c.lineTo(w, s);
            c.end();
            c.stroke();
        }
    };
    CubeShape.prototype.getLabelMargins = function (rect)
    {
        if (mxUtils.getValue(this.style, 'boundedLbl', false))
        {
            var s = parseFloat(mxUtils.getValue(this.style, 'size', this.size)) * this.scale;

            return new mxRectangle(s, s, 0, 0);
        }

        return null;
    };
    mxCellRenderer.registerShape('cube', CubeShape);

    var cylinderGetCylinderSize = mxCylinder.prototype.getCylinderSize;
    mxCylinder.prototype.getCylinderSize = function (x, y, w, h)
    {
        var size = mxUtils.getValue(this.style, 'size');
        if (size != null)
            return h * Math.max(0, Math.min(1, size));
        return cylinderGetCylinderSize.apply(this, arguments);
    };
    mxCylinder.prototype.getLabelMargins = function (rect)
    {
        if (mxUtils.getValue(this.style, 'boundedLbl', false))
        {
            var size = mxUtils.getValue(this.style, 'size', 0.15) * 2;
            return new mxRectangle(0, Math.min(this.maxHeight * this.scale, rect.height * size), 0, 0);
        }
        return null;
    };

    // Parallelogram shape
    function ParallelogramShape()
    {
        mxActor.call(this);
    }
    mxUtils.extend(ParallelogramShape, mxActor);
    ParallelogramShape.prototype.size = 0.2;
    ParallelogramShape.prototype.isRoundable = function ()
    {
        return true;
    };
    ParallelogramShape.prototype.redrawPath = function (c, x, y, w, h)
    {
        var dx = w * Math.max(0, Math.min(0.9, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
        var arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
        this.addPoints(c, [new mxPoint(0, h), new mxPoint(dx, 0), new mxPoint(w, 0), new mxPoint(w - dx, h)],
            this.isRounded, arcSize, true);
        c.end();
    };
    mxCellRenderer.registerShape('parallelogram', ParallelogramShape);

    // Trapezoid shape
    function TrapezoidShape()
    {
        mxActor.call(this);
    }
    mxUtils.extend(TrapezoidShape, mxActor);
    TrapezoidShape.prototype.size = 0.2;
    TrapezoidShape.prototype.isRoundable = function ()
    {
        return true;
    };
    TrapezoidShape.prototype.redrawPath = function (c, x, y, w, h)
    {
        var dx = w * Math.max(0, Math.min(0.5, parseFloat(mxUtils.getValue(this.style, 'size', this.size))));
        var arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
        this.addPoints(c, [new mxPoint(0, h), new mxPoint(dx, 0), new mxPoint(w - dx, 0), new mxPoint(w, h)],
            this.isRounded, arcSize, true);
    };
    mxCellRenderer.registerShape('trapezoid', TrapezoidShape); 

    // Overrides painting of rhombus shape to allow for double style
    var mxRhombusPaintVertexShape = mxRhombus.prototype.paintVertexShape;
    mxRhombus.prototype.getLabelBounds = function (rect)
    {
        if (this.style['double'] == 1)
        {
            var margin = (Math.max(2, this.strokewidth + 1) * 2 + parseFloat(
                this.style[mxConstants.STYLE_MARGIN] || 0)) * this.scale;

            return new mxRectangle(rect.x + margin, rect.y + margin,
                rect.width - 2 * margin, rect.height - 2 * margin);
        }

        return rect;
    };
    mxRhombus.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        mxRhombusPaintVertexShape.apply(this, arguments);

        if (!this.outline && this.style['double'] == 1)
        {
            var margin = Math.max(2, this.strokewidth + 1) * 2 +
                parseFloat(this.style[mxConstants.STYLE_MARGIN] || 0);
            x += margin;
            y += margin;
            w -= 2 * margin;
            h -= 2 * margin;

            if (w > 0 && h > 0)
            {
                c.setShadow(false);

                // Workaround for closure compiler bug where the lines with x and y above
                // are removed if arguments is used as second argument in call below.
                mxRhombusPaintVertexShape.apply(this, [c, x, y, w, h]);
            }
        }
    };

    // Perimeters
    mxPerimeter.OrthogonalPerimeter = function (bounds, vertex, next, orthogonal)
    {
        orthogonal = true;
        return mxPerimeter.RectanglePerimeter.apply(this, arguments);
    };
    mxStyleRegistry.putValue('orthogonalPerimeter', mxPerimeter.OrthogonalPerimeter);

    mxPerimeter.ParallelogramPerimeter = function (bounds, vertex, next, orthogonal)
    {
        var size = ParallelogramShape.prototype.size;

        if (vertex != null)
            size = mxUtils.getValue(vertex.style, 'size', size);

        var x = bounds.x;
        var y = bounds.y;
        var w = bounds.width;
        var h = bounds.height;

        var direction = (vertex != null) ? mxUtils.getValue(
            vertex.style, mxConstants.STYLE_DIRECTION,
            mxConstants.DIRECTION_EAST) : mxConstants.DIRECTION_EAST;
        var vertical = direction == mxConstants.DIRECTION_NORTH ||
            direction == mxConstants.DIRECTION_SOUTH;
        var points;

        if (vertical)
        {
            var dy = h * Math.max(0, Math.min(1, size));
            points = [new mxPoint(x, y), new mxPoint(x + w, y + dy),
            new mxPoint(x + w, y + h), new mxPoint(x, y + h - dy), new mxPoint(x, y)];
        }
        else
        {
            var dx = w * Math.max(0, Math.min(1, size));
            points = [new mxPoint(x + dx, y), new mxPoint(x + w, y),
            new mxPoint(x + w - dx, y + h), new mxPoint(x, y + h), new mxPoint(x + dx, y)];
        }

        var cx = bounds.getCenterX();
        var cy = bounds.getCenterY();

        var p1 = new mxPoint(cx, cy);

        if (orthogonal)
        {
            if (next.x < x || next.x > x + w)
            {
                p1.y = next.y;
            }
            else
            {
                p1.x = next.x;
            }
        }

        return mxUtils.getPerimeterPoint(points, p1, next);
    };
    mxStyleRegistry.putValue('parallelogramPerimeter', mxPerimeter.ParallelogramPerimeter);

    mxPerimeter.TrapezoidPerimeter = function (bounds, vertex, next, orthogonal)
    {
        var size = TrapezoidShape.prototype.size;

        if (vertex != null)
            size = mxUtils.getValue(vertex.style, 'size', size);

        var x = bounds.x;
        var y = bounds.y;
        var w = bounds.width;
        var h = bounds.height;

        var direction = (vertex != null) ? mxUtils.getValue(
            vertex.style, mxConstants.STYLE_DIRECTION,
            mxConstants.DIRECTION_EAST) : mxConstants.DIRECTION_EAST;
        var points;

        if (direction == mxConstants.DIRECTION_EAST)
        {
            var dx = w * Math.max(0, Math.min(1, size));
            points = [new mxPoint(x + dx, y), new mxPoint(x + w - dx, y),
            new mxPoint(x + w, y + h), new mxPoint(x, y + h), new mxPoint(x + dx, y)];
        }
        else if (direction == mxConstants.DIRECTION_WEST)
        {
            var dx = w * Math.max(0, Math.min(1, size));
            points = [new mxPoint(x, y), new mxPoint(x + w, y),
            new mxPoint(x + w - dx, y + h), new mxPoint(x + dx, y + h), new mxPoint(x, y)];
        }
        else if (direction == mxConstants.DIRECTION_NORTH)
        {
            var dy = h * Math.max(0, Math.min(1, size));
            points = [new mxPoint(x, y + dy), new mxPoint(x + w, y),
            new mxPoint(x + w, y + h), new mxPoint(x, y + h - dy), new mxPoint(x, y + dy)];
        }
        else
        {
            var dy = h * Math.max(0, Math.min(1, size));
            points = [new mxPoint(x, y), new mxPoint(x + w, y + dy),
            new mxPoint(x + w, y + h - dy), new mxPoint(x, y + h), new mxPoint(x, y)];
        }

        var cx = bounds.getCenterX();
        var cy = bounds.getCenterY();

        var p1 = new mxPoint(cx, cy);

        if (orthogonal)
        {
            if (next.x < x || next.x > x + w)
            {
                p1.y = next.y;
            }
            else
            {
                p1.x = next.x;
            }
        }

        return mxUtils.getPerimeterPoint(points, p1, next);
    };
    mxStyleRegistry.putValue('trapezoidPerimeter', mxPerimeter.TrapezoidPerimeter);

    // Link shape
    function LinkShape()
    {
        mxArrowConnector.call(this);
        this.spacing = 0;
    }
    mxUtils.extend(LinkShape, mxArrowConnector);
    LinkShape.prototype.defaultWidth = 4;
    LinkShape.prototype.isOpenEnded = function ()
    {
        return true;
    };
    LinkShape.prototype.getEdgeWidth = function ()
    {
        return mxUtils.getNumber(this.style, 'width', this.defaultWidth) + Math.max(0, this.strokewidth - 1);
    };
    LinkShape.prototype.isArrowRounded = function ()
    {
        return this.isRounded;
    };
    mxCellRenderer.registerShape('link', LinkShape);

    // Generic arrow
    function FlexArrowShape()
    {
        mxArrowConnector.call(this);
        this.spacing = 0;
    }
    mxUtils.extend(FlexArrowShape, mxArrowConnector);
    FlexArrowShape.prototype.defaultWidth = 10;
    FlexArrowShape.prototype.defaultArrowWidth = 20;
    FlexArrowShape.prototype.getStartArrowWidth = function ()
    {
        return this.getEdgeWidth() + mxUtils.getNumber(this.style, 'startWidth', this.defaultArrowWidth);
    };
    FlexArrowShape.prototype.getEndArrowWidth = function ()
    {
        return this.getEdgeWidth() + mxUtils.getNumber(this.style, 'endWidth', this.defaultArrowWidth);
    };
    FlexArrowShape.prototype.getEdgeWidth = function ()
    {
        return mxUtils.getNumber(this.style, 'width', this.defaultWidth) + Math.max(0, this.strokewidth - 1);
    };
    mxCellRenderer.registerShape('flexArrow', FlexArrowShape);

    // Single Arrow
    function SingleArrowShape()
    {
        mxActor.call(this);
    }
    mxUtils.extend(SingleArrowShape, mxActor);
    SingleArrowShape.prototype.arrowWidth = 0.3;
    SingleArrowShape.prototype.arrowSize = 0.2;
    SingleArrowShape.prototype.redrawPath = function (c, x, y, w, h)
    {
        var aw = h * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowWidth', this.arrowWidth))));
        var as = w * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowSize', this.arrowSize))));
        var at = (h - aw) / 2;
        var ab = at + aw;

        var arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
        this.addPoints(c, [new mxPoint(0, at), new mxPoint(w - as, at), new mxPoint(w - as, 0), new mxPoint(w, h / 2),
        new mxPoint(w - as, h), new mxPoint(w - as, ab), new mxPoint(0, ab)],
            this.isRounded, arcSize, true);
        c.end();
    };
    mxCellRenderer.registerShape('singleArrow', SingleArrowShape);

    // Double Arrow
    function DoubleArrowShape()
    {
        mxActor.call(this);
    }
    mxUtils.extend(DoubleArrowShape, mxActor);
    DoubleArrowShape.prototype.redrawPath = function (c, x, y, w, h)
    {
        var aw = h * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowWidth', SingleArrowShape.prototype.arrowWidth))));
        var as = w * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowSize', SingleArrowShape.prototype.arrowSize))));
        var at = (h - aw) / 2;
        var ab = at + aw;

        var arcSize = mxUtils.getValue(this.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
        this.addPoints(c, [new mxPoint(0, h / 2), new mxPoint(as, 0), new mxPoint(as, at), new mxPoint(w - as, at),
        new mxPoint(w - as, 0), new mxPoint(w, h / 2), new mxPoint(w - as, h),
        new mxPoint(w - as, ab), new mxPoint(as, ab), new mxPoint(as, h)],
            this.isRounded, arcSize, true);
        c.end();
    };
    mxCellRenderer.registerShape('doubleArrow', DoubleArrowShape);

    // FilledEdge shape
    function FilledEdge()
    {
        mxConnector.call(this);
    };
    mxUtils.extend(FilledEdge, mxConnector);
    FilledEdge.prototype.origPaintEdgeShape = FilledEdge.prototype.paintEdgeShape;
    FilledEdge.prototype.paintEdgeShape = function (c, pts, rounded)
    {
        // Markers modify incoming points array
        var temp = [];

        for (var i = 0; i < pts.length; i++)
        {
            temp.push(mxUtils.clone(pts[i]));
        }

        // paintEdgeShape resets dashed to false
        var dashed = c.state.dashed;
        var fixDash = c.state.fixDash;
        FilledEdge.prototype.origPaintEdgeShape.apply(this, [c, temp, rounded]);

        if (c.state.strokeWidth >= 3)
        {
            var fillClr = mxUtils.getValue(this.style, 'fillColor', null);
            if (fillClr != null)
            {
                c.setStrokeColor(fillClr);
                c.setStrokeWidth(c.state.strokeWidth - 2);
                c.setDashed(dashed, fixDash);
                FilledEdge.prototype.origPaintEdgeShape.apply(this, [c, pts, rounded]);
            }
        }
    };
    mxCellRenderer.registerShape('filledEdge', FilledEdge);

    // Arc Shape
    function ArcShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(ArcShape, mxShape);
    ArcShape.prototype.isRoundable = function ()
    {
        return false;
    };
    ArcShape.prototype.paintBackground = function (c, x, y, w, h)
    {
        c.translate(x, y);

        c.begin();
        c.moveTo(0, 0);
        c.arcTo(w, h/2, 0, 1, 1, 0, h);
        c.end();
        c.stroke();
    };
    ArcShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0, 0),   false, 'N'),
        new mxConnectionConstraint(new mxPoint(1, 0.5), false, 'E'),
        new mxConnectionConstraint(new mxPoint(0, 1),   false, 'S')
    ];
    mxCellRenderer.registerShape('arc', ArcShape);

    // Sound Shape
    function SoundShape()
    {
        mxImage.call(this);
    }
    mxUtils.extend(SoundShape, mxImageShape);
    SoundShape.prototype.isRoundable = function ()
    {
        return false;
    };
    SoundShape.prototype.isConnectable = function ()
    {
        return false;
    };
    SoundShape.prototype.constraints = [];
    mxCellRenderer.registerShape('sound', SoundShape);

    // Table Shape
    function TableShape()
    {
        mxSwimlane.call(this);
    }
    mxUtils.extend(TableShape, mxSwimlane);
    TableShape.prototype.isRoundable = function ()
    {
        return true;
    };
    TableShape.prototype.isConnectable = function ()
    {
        return true;
    };
    TableShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S'),
        new mxConnectionConstraint(new mxPoint(0, 0.5), false, 'W'),
        new mxConnectionConstraint(new mxPoint(1, 0.5), false, 'E')
    ];
    mxCellRenderer.registerShape('table', TableShape);

    // Button Shape
    function ButtonShape()
    {
        mxLabel.call(this);
    }
    mxUtils.extend(ButtonShape, mxLabel);
    ButtonShape.prototype.isRoundable = function ()
    {
        return true;
    };
    ButtonShape.prototype.isConnectable = function ()
    {
        return true;
    };
    ButtonShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S'),
        new mxConnectionConstraint(new mxPoint(0, 0.5), false, 'W'),
        new mxConnectionConstraint(new mxPoint(1, 0.5), false, 'E')
    ];
    mxCellRenderer.registerShape('button', ButtonShape);

    // Bus Shape
    function BusShape()
    {
        mxRectangleShape.call(this);
    }
    mxUtils.extend(BusShape, mxRectangleShape);
    BusShape.prototype.isRoundable = function ()
    {
        return false;
    };
    BusShape.prototype.isSizerVisible = function (index)
    {
        return index != 0 && index != 2 && index != 5 && index != 7;
    };
    BusShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        mxRectangleShape.prototype.paintVertexShape.apply(this, arguments);
        //c.begin();
        //c.moveTo(x + (w / 2), y + 0 + ((h / 8) * 2));
        //c.lineTo(x + (w / 2), y + h - ((h / 8) * 2));
        //c.end();
        //c.stroke();
    };
    BusShape.prototype.paintBackground = function (c, x, y, w, h)
    {
        mxRectangleShape.prototype.paintBackground.apply(this, arguments);
    };
    BusShape.prototype.paintForeground = function (c, x, y, w, h)
    {
        mxRectangleShape.prototype.paintForeground.apply(this, arguments);
    };
    BusShape.prototype.getConstraints = function (style, w, h)
    {
        var constr = [];
        // left side
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, "W"));
        // right side
        constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false, "E"));

        var graph = this.state.view.graph;
        var step = graph.gridEnabled ? graph.gridSize || 5 : 5;
        if (w > step)
        {
            var i = 0;
            for (var dx = step; dx < w; dx += step)
                constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false, "P" + i, dx, 0));
        }

        return (constr);
    };
    mxCellRenderer.registerShape('bus', BusShape);

    // Switch Shape
    function SwitchShape()
    {
        mxRectangleShape.call(this);
    }
    mxUtils.extend(SwitchShape, mxRectangleShape);
    SwitchShape.prototype.isRoundable = function ()
    {
        return true;
    };
    SwitchShape.prototype.on = true;
    SwitchShape.prototype.position = true;
    SwitchShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        mxRectangleShape.prototype.paintVertexShape.apply(this, arguments);
    };
    SwitchShape.prototype.paintBackground = function (c, x, y, w, h)
    {
        mxRectangleShape.prototype.paintBackground.apply(this, arguments);
    };
    SwitchShape.prototype.paintForeground = function (c, x, y, w, h)
    {
        if (this.position)
        {
            c.begin();
            if (this.on)
            {
                c.moveTo(x + (w / 2), y + 0 + ((h / 8) * 2));
                c.lineTo(x + (w / 2), y + h - ((h / 8) * 2));
            }
            else
            {
                c.moveTo(x + (w / 8) * 2, y + (h / 2));
                c.lineTo(x + w - ((w / 8) * 2), y + (h / 2));
            }
            c.end();
            c.fillAndStroke();
        }
        mxRectangleShape.prototype.paintForeground.apply(this, arguments);
    };
    SwitchShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S'),
        new mxConnectionConstraint(new mxPoint(0, 0.5), false, 'W'),
        new mxConnectionConstraint(new mxPoint(1, 0.5), false, 'E')
    ];
    mxCellRenderer.registerShape('switch', SwitchShape);

    // RollSwitch Shape
    function RollSwitchShape()
    {
        mxRectangleShape.call(this);
    }
    mxUtils.extend(RollSwitchShape, mxRectangleShape);
    RollSwitchShape.prototype.isRoundable = function ()
    {
        return true;
    };
    RollSwitchShape.prototype.on = true;
    RollSwitchShape.prototype.position = true;
    RollSwitchShape.prototype.roll = 'UNKNOWN';
    RollSwitchShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        // draw roll state
        c.begin();

        c.setLineCap('round');
        c.setLineJoin('round');

        // top
        c.moveTo(x + (w / 2), y + 0);
        c.lineTo(x, y + h / 9);
        c.moveTo(x + (w / 2), y + 0);
        c.lineTo(x + w, y + h / 9);

        if (this.roll == "UNKNOWN" || this.roll == "IN")
        {
            c.moveTo(x + (w / 2), y + (h / 15));
            c.lineTo(x, y + h / 9 + (h / 15));
            c.moveTo(x + (w / 2), y + (h / 15));
            c.lineTo(x + w, y + h / 9 + (h / 15));

            c.moveTo(x + (w / 2), y + (h / 15));
            c.lineTo(x + (w / 2), y + h / 3);
        }
        
        // bottom
        c.moveTo(x + (w / 2), y + h);
        c.lineTo(x, y + h - h / 9);
        c.moveTo(x + (w / 2), y + h);
        c.lineTo(x + w, y + h - h / 9);

        if (this.roll == "UNKNOWN" || this.roll == "IN")
        {
            c.moveTo(x + (w / 2), y + h - (h / 15));
            c.lineTo(x, y + h - h / 9 - (h / 15));
            c.moveTo(x + (w / 2), y + h - (h / 15));
            c.lineTo(x + w, y + h - h / 9 - (h / 15));

            c.moveTo(x + (w / 2), y + h - (h / 15));
            c.lineTo(x + (w / 2), y + h - h / 3);
        }

        c.fillAndStroke();
        c.end();

        mxRectangleShape.prototype.paintVertexShape.apply(this, arguments);
    };
    RollSwitchShape.prototype.paintBackground = function (c, x, y, w, h)
    {
        if (this.roll == 'DAMAGE')
        {
            c.setStrokeColor('#FFFFFF');
            c.setFillColor(this.on ? '#FFFFFF' : 'none');
        }
        if (this.roll == "DAMAGE|DAMAGE")
        {
            c.setStrokeColor('#FF0000');
            c.setFillColor('none');
        }
        mxRectangleShape.prototype.paintBackground.apply(this, [c, x, y + h / 3, w, h / 3]);
    };
    RollSwitchShape.prototype.paintForeground = function (c, x, y, w, h)
    {
        if (this.position)
        {
            c.begin();
            c.setStrokeColor('#000000');
            if (this.on)
            {
                c.moveTo(x + (w / 2), y + (h / 3) + ((h / 24) * 2));
                c.lineTo(x + (w / 2), y + (h / 3) * 2 - ((h / 24) * 2));
            }
            else
            {
                c.moveTo(x + (w / 8) * 2, y + (h / 2));
                c.lineTo(x + w - ((w / 8) * 2), y + (h / 2));
            }
            c.fillAndStroke();
            c.end();
        }
        mxRectangleShape.prototype.paintForeground.apply(this, arguments);
    };
    RollSwitchShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('rollswitch', RollSwitchShape);

    // RollDisconnector Shape
    function RollDisconnectorShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(RollDisconnectorShape, mxShape);
    RollDisconnectorShape.prototype.isRoundable = function ()
    {
        return false;
    };
    RollDisconnectorShape.prototype.roll = 'UNKNOWN';
    RollDisconnectorShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        // draw roll state
        c.begin();

        c.setLineCap('round');
        c.setLineJoin('round');

        // top
        c.moveTo(x + (w / 2), y + 0);
        c.lineTo(x, y + h / 9);
        c.moveTo(x + (w / 2), y + 0);
        c.lineTo(x + w, y + h / 9);

        if (this.roll != "CONTROL")
        {
            // top
            c.moveTo(x + (w / 2), y + (h / 15));
            c.lineTo(x, y + h / 9 + (h / 15));
            c.moveTo(x + (w / 2), y + (h / 15));
            c.lineTo(x + w, y + h / 9 + (h / 15));

            // line
            c.moveTo(x + (w / 2), y + (h / 15));
            c.lineTo(x + (w / 2), y + h - (h / 15));

            // bottom
            c.moveTo(x + (w / 2), y + h - (h / 15));
            c.lineTo(x, y + h - h / 9 - (h / 15));
            c.moveTo(x + (w / 2), y + h - (h / 15));
            c.lineTo(x + w, y + h - h / 9 - (h / 15));
        }

        // bottom
        c.moveTo(x + (w / 2), y + h);
        c.lineTo(x, y + h - h / 9);
        c.moveTo(x + (w / 2), y + h);
        c.lineTo(x + w, y + h - h / 9);

        c.fillAndStroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    RollDisconnectorShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('rolldisconnector', RollDisconnectorShape);

    // Disconnector Shape
    function DisconnectorShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(DisconnectorShape, mxShape);
    DisconnectorShape.prototype.isRoundable = function ()
    {
        return false;
    };
    DisconnectorShape.prototype._state = 'UNKNOWN';
    DisconnectorShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        // draw roll state
        c.begin();

        c.setLineCap('round');
        c.setLineJoin('round');

        // top
        let space = (w / 10);
        c.moveTo(x + space, y + 0);
        c.lineTo(x + w - space, y + 0);

        // middle
        if (this._state == "UNKNOWN" || this._state == "ON")
        {
            c.moveTo(x + (w / 2), y + (h / 8));
            c.lineTo(x + (w / 2), y + h - (h / 8));
        }
        else if (this._state == "OFF")
        {
            c.moveTo(x, y + (h / 2));
            c.lineTo(x + w, y + (h / 2));
        }
        else if (this._state == "MIDDLE")
        {
            c.moveTo(x, y + h - (h / 4));
            c.lineTo(x + w, y + (h / 4));
        }

        // bottom
        c.moveTo(x + space, y + h);
        c.lineTo(x + w - space, y + h);

        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    DisconnectorShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('disconnector', DisconnectorShape);

    // Separator Shape
    function SeparatorShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(SeparatorShape, mxShape);
    SeparatorShape.prototype.isRoundable = function ()
    {
        return false;
    };
    SeparatorShape.prototype._state = 'UNKNOWN';
    SeparatorShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');
        c.setFillColor('#000000');

        let rsize = h / 10;
        let space = (w / 10);

        // top
        c.begin();
        c.moveTo(x + space, y + 0);
        c.lineTo(x + w - space, y + 0);
        c.stroke();
        c.end();

        // middle
        if (this._state == "UNKNOWN" || this._state == "ON")
        {
            c.begin();

            c.moveTo(x + (w / 2), y + (h / 8));
            c.lineTo(x + (w / 2), y + h - (h / 8));

            c.moveTo(x + (w / 2), y + h / 2 - rsize);
            c.lineTo(x + (w / 2) + rsize / 2, y + h / 2 - rsize);
            c.lineTo(x + (w / 2) + rsize / 2, y + h / 2 + rsize);
            c.lineTo(x + (w / 2), y + h / 2 + rsize);
            c.rotate(0, false, false, x + (w / 2), y + (h / 2));

            c.close();
            c.fillAndStroke();
            c.end();
        }
        else if (this._state == "OFF")
        {
            c.begin();
            c.moveTo(x, y + (h / 2));
            c.lineTo(x + w, y + (h / 2));
            c.stroke();
            c.end();

            c.save();
            c.begin();

            c.moveTo(x + (w / 2), y + h / 2 - rsize);
            c.lineTo(x + (w / 2) + rsize / 2, y + h / 2 - rsize);
            c.lineTo(x + (w / 2) + rsize / 2, y + h / 2 + rsize);
            c.lineTo(x + (w / 2), y + h / 2 + rsize);
            c.rotate(90, false, false, x + (w / 2), y + (h / 2));

            c.close();
            c.fillAndStroke();
            c.end();
            c.restore();
        }
        else if (this._state == "MIDDLE")
        {
            c.save();
            c.begin();

            c.moveTo(x + (w / 2), y + (h / 8));
            c.lineTo(x + (w / 2), y + h - (h / 8));

            c.moveTo(x + (w / 2), y + h / 2 - rsize);
            c.lineTo(x + (w / 2) + rsize / 2, y + h / 2 - rsize);
            c.lineTo(x + (w / 2) + rsize / 2, y + h / 2 + rsize);
            c.lineTo(x + (w / 2), y + h / 2 + rsize);
            c.rotate(45, false, false, x + (w / 2), y + (h / 2));

            c.close();
            c.fillAndStroke();
            c.end();
            c.restore();
        }

        // bottom
        c.begin();
        c.moveTo(x + space, y + h);
        c.lineTo(x + w - space, y + h);
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    SeparatorShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('separator', SeparatorShape);

    // Ground Shape
    function GroundShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(GroundShape, mxShape);
    GroundShape.prototype.isRoundable = function ()
    {
        return false;
    };
    GroundShape.prototype._state = 'UNKNOWN';
    GroundShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.begin();

        c.setLineCap('round');
        c.setLineJoin('round');

        let space = (w / 10);
        let gsize = (h / 3);
        let gstep = gsize / 3;

        let height = h - gsize;

        // top
        c.moveTo(x + space, y + 0);
        c.lineTo(x + w - space, y + 0);

        // middle
        if (this._state == "UNKNOWN" || this._state == "ON")
        {
            c.moveTo(x + (w / 2), y + (height / 8));
            c.lineTo(x + (w / 2), y + height - (height / 8));
        }
        else if (this._state == "OFF")
        {
            c.moveTo(x, y + (height / 2));
            c.lineTo(x + w, y + (height / 2));
        }
        else if (this._state == "MIDDLE")
        {
            c.moveTo(x, y + height - (height / 4));
            c.lineTo(x + w, y + (height / 4));
        }

        // bottom
        c.moveTo(x + space, y + height);
        c.lineTo(x + w - space, y + height);

        // ground
        c.moveTo(x + w / 2, y + height);
        c.lineTo(x + w / 2, y + height + gstep * 1);

        // 1
        c.moveTo(x + space * 0, y + height + gstep * 1);
        c.lineTo(x + w - space * 0, y + height + gstep * 1);

        // 2
        c.moveTo(x + space * 2, y + height + gstep * 2);
        c.lineTo(x + w - space * 2, y + height + gstep * 2);

        // 3
        c.moveTo(x + space * 3, y + height + gstep * 3);
        c.lineTo(x + w - space * 3, y + height + gstep * 3);

        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    GroundShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('ground', GroundShape);

    // Contactor Shape
    function ContactorShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(ContactorShape, mxShape);
    ContactorShape.prototype.isRoundable = function ()
    {
        return false;
    };
    ContactorShape.prototype._state = 'UNKNOWN';
    ContactorShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');
        c.setFillColor('#000000');

        let rsize  = h / 10;
        let space  = (w / 10);
        let gsize  = (h / 3);
        let gstep  = gsize / 3;
        let height = h - gsize;

        // top
        c.begin();  
        c.moveTo(x + space, y + 0);
        c.lineTo(x + w - space, y + 0);
        c.stroke();
        c.end();

        // middle
        if (this._state == "UNKNOWN" || this._state == "ON")
        {
            //c.moveTo(x + (w / 2), y + (height / 8));
            //c.lineTo(x + (w / 2), y + height - (height / 8));

            c.begin();

            c.moveTo(x + (w / 2), y + (height / 8));
            c.lineTo(x + (w / 2), y + height - (height / 8));

            c.moveTo(x + (w / 2), y + height / 2 - rsize);
            c.lineTo(x + (w / 2) + rsize / 2, y + height / 2 - rsize);
            c.lineTo(x + (w / 2) + rsize / 2, y + height / 2 + rsize);
            c.lineTo(x + (w / 2), y + height / 2 + rsize);
            c.rotate(0, false, false, x + (w / 2), y + (height / 2));

            c.close();
            c.fillAndStroke();
            c.end();
        }
        else if (this._state == "OFF")
        {
            //c.moveTo(x, y + (height / 2));
            //c.lineTo(x + w, y + (height / 2));
            c.begin();
            c.moveTo(x, y + (height / 2));
            c.lineTo(x + w, y + (height / 2));
            c.stroke();
            c.end();

            c.save();
            c.begin();

            c.moveTo(x + (w / 2), y + height / 2 - rsize);
            c.lineTo(x + (w / 2) + rsize / 2, y + height / 2 - rsize);
            c.lineTo(x + (w / 2) + rsize / 2, y + height / 2 + rsize);
            c.lineTo(x + (w / 2), y + height / 2 + rsize);
            c.rotate(90, false, false, x + (w / 2), y + (height / 2));

            c.close();
            c.fillAndStroke();
            c.end();
            c.restore();
        }
        else if (this._state == "MIDDLE")
        {
            //c.moveTo(x, y + height - (height / 4));
            //c.lineTo(x + w, y + (height / 4));
            c.save();
            c.begin();

            c.moveTo(x + (w / 2), y + (height / 8));
            c.lineTo(x + (w / 2), y + height - (height / 8));

            c.moveTo(x + (w / 2), y + height / 2 - rsize);
            c.lineTo(x + (w / 2) + rsize / 2, y + height / 2 - rsize);
            c.lineTo(x + (w / 2) + rsize / 2, y + height / 2 + rsize);
            c.lineTo(x + (w / 2), y + height / 2 + rsize);
            c.rotate(45, false, false, x + (w / 2), y + (height / 2));

            c.close();
            c.fillAndStroke();
            c.end();
            c.restore();
        }

        c.begin();

        // bottom
        c.moveTo(x + space, y + height);
        c.lineTo(x + w - space, y + height);

        // ground
        c.moveTo(x + w / 2, y + height);
        c.lineTo(x + w / 2, y + height + gstep * 1);

        // 1
        c.moveTo(x + space * 0, y + height + gstep * 1);
        c.lineTo(x + w - space * 0, y + height + gstep * 1);

        // 2
        c.moveTo(x + space * 2, y + height + gstep * 2);
        c.lineTo(x + w - space * 2, y + height + gstep * 2);

        // 3
        c.moveTo(x + space * 3, y + height + gstep * 3);
        c.lineTo(x + w - space * 3, y + height + gstep * 3);

        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    ContactorShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('contactor', ContactorShape);

    // Roll element Shape
    function RollElementShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(RollElementShape, mxShape);
    RollElementShape.prototype.isRoundable = function ()
    {
        return false;
    };
    RollElementShape.prototype._state = 'UNKNOWN';
    RollElementShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        // draw roll state
        c.begin();

        c.setLineCap('round');
        c.setLineJoin('round');

        // top
        c.moveTo(x + (w / 2), y + 0);
        c.lineTo(x, y + h / 2);
        c.moveTo(x + (w / 2), y + 0);
        c.lineTo(x + w, y + h / 2);

        if (this._state == "UNKNOWN" || this._state == "IN")
        {
            c.moveTo(x + (w / 2), y + (h / 2));
            c.lineTo(x, y + h);
            c.moveTo(x + (w / 2), y + (h / 2));
            c.lineTo(x + w, y + h);
        }

        c.fillAndStroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    RollElementShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N')
    ];
    mxCellRenderer.registerShape('rollelement', RollElementShape);

    // Actuator Shape
    function ActuatorShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(ActuatorShape, mxShape);
    ActuatorShape.prototype.isRoundable = function ()
    {
        return false;
    };
    ActuatorShape.prototype._state = 'UNKNOWN';
    ActuatorShape.prototype.fill_1 = null;
    ActuatorShape.prototype.fill_2 = null;
    ActuatorShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        // left
        c.save();
        c.begin();
        if (this.fill_1 != null)
            c.setFillColor(this.fill_1);
        c.moveTo(x, y);
        c.lineTo(x + w / 2, y + h / 2);
        c.lineTo(x, y + h);
        c.close();
        c.fillAndStroke();
        c.end();
        c.restore();

        // right
        c.save();
        c.begin();
        if (this.fill_2 != null)
            c.setFillColor(this.fill_2);
        c.moveTo(x + w, y);
        c.lineTo(x + w / 2, y + h / 2);
        c.lineTo(x + w, y + h);
        c.close();
        c.fillAndStroke();
        c.end();
        c.restore();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    ActuatorShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0, 0.5),   false, 'W'),
        new mxConnectionConstraint(new mxPoint(0.5, 0.5), false, 'M'),
        new mxConnectionConstraint(new mxPoint(1, 0.5),   false, 'E')
    ];
    mxCellRenderer.registerShape('actuator', ActuatorShape);

    // Simple switch Shape
    function SimpleSwitchShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(SimpleSwitchShape, mxShape);
    SimpleSwitchShape.prototype.isRoundable = function ()
    {
        return false;
    };
    SimpleSwitchShape.prototype._state = 'UNKNOWN';
    SimpleSwitchShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');
        c.setFillColor(c.state.strokeColor);

        let size  = w / 2;
        let csize = w / 4;

        // top
        c.begin();
        c.moveTo(x + (w / 2) - size / 2, y + 0);
        c.lineTo(x + (w / 2) + size / 2, y + 0);
        c.stroke();
        c.end();

        // middle
        if (this._state == "UNKNOWN" || this._state == "OFF")
        {
            c.begin();
            c.moveTo(x, y + (h / 8));
            c.lineTo(x + (w / 2), y + h);
            c.stroke();
            c.end();
        }
        else if (this._state == "ON")
        {
            c.begin();
            c.moveTo(x + (w / 2), y + (h / 10));
            c.lineTo(x + (w / 2), y + h);
            c.stroke();
            c.end();
        }
        
        // bottom
        c.begin();
        //c.moveTo(x + (w / 2), y + h);
        c.ellipse(x + (w / 2) - csize / 2, y + h - csize / 2, csize, csize);
        c.fillAndStroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    SimpleSwitchShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('simpleswitch', SimpleSwitchShape);

    // Chart Shape
    function ChartShape()
    {
        mxLabel.call(this);
    }
    mxUtils.extend(ChartShape, mxLabel);
    ChartShape.prototype.isRoundable = function ()
    {
        return true;
    };
    ChartShape.prototype.isConnectable = function ()
    {
        return true;
    };
    ChartShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S'),
        new mxConnectionConstraint(new mxPoint(0, 0.5), false, 'W'),
        new mxConnectionConstraint(new mxPoint(1, 0.5), false, 'E')
    ];
    mxCellRenderer.registerShape('chart', ChartShape);

    // BMRZ Shape
    function BmrzShape()
    {
        mxImage.call(this);
    }
    mxUtils.extend(BmrzShape, mxImageShape);
    BmrzShape.prototype.isRoundable = function ()
    {
        return false;
    };
    BmrzShape.prototype.isConnectable = function ()
    {
        return true;
    };
    BmrzShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S'),
        new mxConnectionConstraint(new mxPoint(0, 0.5), false, 'W'),
        new mxConnectionConstraint(new mxPoint(1, 0.5), false, 'E')
    ];
    mxCellRenderer.registerShape('bmrz', BmrzShape);

    //--------- static elements ------------//

    // WINDING STAR
    function WStarShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(WStarShape, mxShape);
    WStarShape.prototype.isRoundable = function ()
    {
        return false;
    };
    WStarShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');
        
        c.begin();
        // left
        c.moveTo(x + (w / 2), y + (h / 3));
        c.lineTo(x, y + 0);
        // right
        c.moveTo(x + (w / 2), y + (h / 3));
        c.lineTo(x + w, y + 0);
        // bottom
        c.moveTo(x + (w / 2), y + (h / 3));
        c.lineTo(x + w / 2, y + h);
        // stroke
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    WStarShape.prototype.constraints = [];
    mxCellRenderer.registerShape('wstar', WStarShape);

    // WINDING TRIANGLE
    function WTriangleShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(WTriangleShape, mxShape);
    WTriangleShape.prototype.isRoundable = function ()
    {
        return false;
    };
    WTriangleShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        c.begin();
        c.moveTo(x + (w / 2), y + 0);
        c.lineTo(x, y + h);
        c.lineTo(x + w, y + h);
        c.close();
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    WTriangleShape.prototype.constraints = [];
    mxCellRenderer.registerShape('wtriangle', WTriangleShape);

    // WINDING TORN TRIANGLE
    function WTornShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(WTornShape, mxShape);
    WTornShape.prototype.isRoundable = function ()
    {
        return false;
    };
    WTornShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        c.begin();
        c.moveTo(x + (w / 4), y + 0);
        c.lineTo(x, y + h);
        c.lineTo(x + w, y + h);
        c.lineTo(x + w - (w / 4), y + 0);
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    WTornShape.prototype.constraints = [];
    mxCellRenderer.registerShape('wtorn', WTornShape);

    // FUSE
    function FuseShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(FuseShape, mxShape);
    FuseShape.prototype.isRoundable = function ()
    {
        return false;
    };
    FuseShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        c.begin();
        c.moveTo(x, y);
        c.rect(x, y, w, h);
        c.stroke();
        c.end();

        c.begin();        
        c.moveTo(x + w / 2, y);
        c.lineTo(x + w / 2, y + h);
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    FuseShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('fuse', FuseShape);

    // CURRENT_TRANSFORMER
    function CurrentTransformerShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(CurrentTransformerShape, mxShape);
    CurrentTransformerShape.prototype.isRoundable = function ()
    {
        return false;
    };
    CurrentTransformerShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');
        c.setFillColor(c.state.strokeColor);

        let csize = w / 6;

        // ellipse
        c.begin();
        c.ellipse(x, y + h / 7, w, (h / 7) * 5);
        c.stroke();
        c.end();

        // line
        c.begin();
        c.moveTo(x + w / 2, y);
        c.lineTo(x + w / 2, y + h);
        c.stroke();
        c.end();

        // c1
        c.begin();
        c.ellipse(x + w / 2 - csize / 2, y - csize / 2, csize, csize);
        c.fill();
        c.end();

        // c2
        c.begin();
        c.ellipse(x + w / 2 - csize / 2, y + h - csize / 2, csize, csize);
        c.fill();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    CurrentTransformerShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('current_transformer', CurrentTransformerShape);

    // CURRENT_TRANSFORMER_RU
    function CurrentTransformerRUShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(CurrentTransformerRUShape, mxShape);
    CurrentTransformerRUShape.prototype.isRoundable = function ()
    {
        return false;
    };
    CurrentTransformerRUShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');
        
        // vline
        c.begin();
        c.moveTo(x + w - w / 4, y);
        c.lineTo(x + w - w / 4, y + h);
        c.stroke();
        c.end();

        // line1
        c.begin();
        c.moveTo(x + w - (w / 4) * 2, y);
        c.lineTo(x + w, y);
        c.stroke();
        c.end();

        // line2
        c.begin();
        c.moveTo(x + w - (w / 4) * 2, y + h);
        c.lineTo(x + w, y + h);
        c.stroke();
        c.end();

        // arc1
        c.begin();
        c.moveTo(x + w - (w / 4) * 2, y);
        c.arcTo(h / 4, w / 2, 90, 0, 0, x + w - (w / 4) * 2, y + h / 2);
        c.stroke();
        c.end();

        // arc2
        c.begin();
        c.moveTo(x + w - (w / 4) * 2, y + h);
        c.arcTo(h / 4, w / 2, 90, 0, 1, x + w - (w / 4) * 2, y + h / 2);
        c.stroke();
        c.end();
        
        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    CurrentTransformerRUShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.75, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.75, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('current_transformer_ru', CurrentTransformerRUShape);

    // CURRENT_TRANSFORMER_FSK
    function CurrentTransformerFSKShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(CurrentTransformerFSKShape, mxShape);
    CurrentTransformerFSKShape.prototype.isRoundable = function ()
    {
        return false;
    };
    CurrentTransformerFSKShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        // vline
        c.begin();
        c.ellipse(x, y, (w / 4) * 3, h);
        c.stroke();
        c.end();

        // line1
        c.begin();
        c.moveTo(x + w - (w / 8) * 2, y + (h / 6) * 2);
        c.lineTo(x + w, y + (h / 6) * 2);
        c.stroke();
        c.end();

        // line2
        c.begin();
        c.moveTo(x + w - (w / 8) * 2, y + h - (h / 6) * 2);
        c.lineTo(x + w, y + h - (h / 6) * 2);
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    CurrentTransformerFSKShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.375, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.375, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('current_transformer_fsk', CurrentTransformerFSKShape);

    // Reactor
    function ReactorShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(ReactorShape, mxShape);
    ReactorShape.prototype.isRoundable = function ()
    {
        return false;
    };
    ReactorShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        // arc
        c.begin();
        c.moveTo(x + w / 2, y);
        c.arcTo(h / 2, w / 2, 0, 1, 1, x, y + h / 2);
        c.stroke();
        c.end();

        // line1
        c.begin();
        c.moveTo(x, y + h / 2);
        c.lineTo(x + w / 2, y + h / 2);
        c.stroke();
        c.end();

        // line2
        c.begin();
        c.moveTo(x + w / 2, y + h / 2);
        c.lineTo(x + w / 2, y + h);
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    ReactorShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('reactor', ReactorShape);

    // OPN
    function OPNShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(OPNShape, mxShape);
    OPNShape.prototype.isRoundable = function ()
    {
        return false;
    };
    OPNShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        let space  = w / 5;
        let vspace = h / 8;

        // rect
        c.begin();
        c.rect(x + space, y, w - space * 2, h);
        c.stroke();
        c.end();

        // line
        c.begin();
        c.moveTo(x + w, y);
        c.lineTo(x, y + h - vspace * 2);
        c.lineTo(x, y + h);
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    OPNShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('opn', OPNShape);

    // OPN non linear
    function OPNLShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(OPNLShape, mxShape);
    OPNLShape.prototype.isRoundable = function ()
    {
        return false;
    };
    OPNLShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        let space  = w / 5;
        let vspace = h / 8;

        // rect
        c.begin();
        c.rect(x + space, y, w - space * 2, h);
        c.stroke();
        c.end();

        // line
        c.begin();
        c.moveTo(x + w, y + h);
        c.lineTo(x, y + vspace * 2);
        c.lineTo(x, y);
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    OPNLShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('opn_nl', OPNLShape);

    // Rezistor
    function RezistorShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(RezistorShape, mxShape);
    RezistorShape.prototype.isRoundable = function ()
    {
        return false;
    };
    RezistorShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        // rect
        c.begin();
        c.rect(x, y, w, h);
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    RezistorShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('rezistor', RezistorShape);

    // Condensator
    function CondensatorShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(CondensatorShape, mxShape);
    CondensatorShape.prototype.isRoundable = function ()
    {
        return false;
    };
    CondensatorShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        let vspace = h / 3;

        c.begin();

        c.moveTo(x + w / 2, y);
        c.lineTo(x + w / 2, y + vspace);

        c.moveTo(x, y + vspace);
        c.lineTo(x + w, y + vspace);

        c.moveTo(x, y + vspace * 2);
        c.lineTo(x + w, y + vspace * 2);

        c.moveTo(x + w / 2, y + vspace * 2);
        c.lineTo(x + w / 2, y + h);

        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    CondensatorShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('condensator', CondensatorShape);

    // Inductance
    function InductanceShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(InductanceShape, mxShape);
    InductanceShape.prototype.isRoundable = function ()
    {
        return false;
    };
    InductanceShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        let vstep = h / 3;

        // arcs
        c.begin();
        c.moveTo(x, y);
        c.arcTo(vstep / 2, w, 90, 0, 1, x, y + vstep * 1);
        c.arcTo(vstep / 2, w, 90, 0, 1, x, y + vstep * 2);
        c.arcTo(vstep / 2, w, 90, 0, 1, x, y + h);
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    InductanceShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0, 1), false, 'S')
    ];
    mxCellRenderer.registerShape('inductance', InductanceShape);

    // Ground1 Shape
    function Ground1Shape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(Ground1Shape, mxShape);
    Ground1Shape.prototype.isRoundable = function ()
    {
        return false;
    };
    Ground1Shape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.begin();

        c.setLineCap('round');
        c.setLineJoin('round');

        let space = (w / 8);

        // 1
        c.moveTo(x, y);
        c.lineTo(x + w, y);

        // 2
        c.moveTo(x + space * 1, y + h / 2);
        c.lineTo(x + w - space * 1, y + h / 2);

        // 3
        c.moveTo(x + space * 2, y + h);
        c.lineTo(x + w - space * 2, y + h);

        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    Ground1Shape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N')
    ];
    mxCellRenderer.registerShape('ground1', Ground1Shape);

    // CABLE_CONE
    function CableConeShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(CableConeShape, mxShape);
    CableConeShape.prototype.isRoundable = function ()
    {
        return false;
    };
    CableConeShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.begin();

        c.setLineCap('round');
        c.setLineJoin('round');

        // triangle
        c.moveTo(x, y);
        c.lineTo(x + w, y);
        c.lineTo(x + w / 2, y + h);
        c.close();
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    CableConeShape.prototype.constraints = [];
    mxCellRenderer.registerShape('cable_cone', CableConeShape);

    // AC shape
    function ACShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(ACShape, mxShape);
    ACShape.prototype.isRoundable = function ()
    {
        return false;
    };
    ACShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        // arcs
        c.begin();
        c.moveTo(x, y + h / 3);
        c.arcTo(w / 4, h / 2, 0, 0, 0, x + w / 2, y + h / 2);
        c.arcTo(w / 4, h / 2, 0, 0, 1, x + w, y + h - h / 3);
        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    ACShape.prototype.constraints = [];
    mxCellRenderer.registerShape('ac', ACShape);

    // Load shape
    function LoadShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(LoadShape, mxShape);
    LoadShape.prototype.isRoundable = function ()
    {
        return false;
    };
    LoadShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');
        c.setFillColor(c.state.strokeColor);

        // arcs
        c.begin();
        c.moveTo(x + w / 2, y);
        c.lineTo(x + w / 2, y + h / 2);
        c.moveTo(x, y + h / 2);
        c.lineTo(x + w, y + h / 2);
        c.lineTo(x + w / 2, y + h);
        c.close();
        c.fillAndStroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    LoadShape.prototype.constraints = [];
    mxCellRenderer.registerShape('load', LoadShape);

    // Compensator shape
    function CompensatorShape()
    {
        mxShape.call(this);
    }
    mxUtils.extend(CompensatorShape, mxShape);
    CompensatorShape.prototype.isRoundable = function ()
    {
        return false;
    };
    CompensatorShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        c.setLineCap('round');
        c.setLineJoin('round');

        let step = w / 5;

        c.begin();
        c.ellipse(x, y, w, h);
        c.stroke();
        c.end();

        c.begin();

        // line1
        c.moveTo(x + step, y + h / 2 - h / 8);
        c.lineTo(x + w - step, y + h / 2 - h / 8);
        // line2
        c.moveTo(x + step, y + h / 2 + h / 8);
        c.lineTo(x + w - step, y + h / 2 + h / 8);

        c.stroke();
        c.end();

        mxShape.prototype.paintVertexShape.apply(this, arguments);
    };
    CompensatorShape.prototype.constraints = [
        new mxConnectionConstraint(new mxPoint(0.5, 0), false, 'N'),
        new mxConnectionConstraint(new mxPoint(0.5, 1), false, 'S'),
        new mxConnectionConstraint(new mxPoint(0, 0.5), false, 'W'),
        new mxConnectionConstraint(new mxPoint(1, 0.5), false, 'E')
    ];
    mxCellRenderer.registerShape('compensator', CompensatorShape);

    // Poster shape
    function PosterShape() {
        mxImageShape.call(this);
    }
    mxUtils.extend(PosterShape, mxImageShape);
    PosterShape.prototype.isRoundable = function ()
    {
        return false;
    };
    /**
     * https://stackoverflow.com/questions/35969656
     * @param {*} hex - color
     * @param {*} bw - black and white mode
     * @returns hex color string
     */
    PosterShape.prototype.getContrastColor = function invertColor(hex, bw) {
        const padZero = (str, len) => {
            len = len || 2;
            var zeros = new Array(len).join('0');
            return (zeros + str).slice(-len);
        };

        if (hex.indexOf('#') === 0) {
            hex = hex.slice(1);
        }
        // convert 3-digit hex to 6-digits.
        if (hex.length === 3) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        if (hex.length !== 6) {
            throw new Error('Invalid HEX color.');
        }
        var r = parseInt(hex.slice(0, 2), 16),
            g = parseInt(hex.slice(2, 4), 16),
            b = parseInt(hex.slice(4, 6), 16);
        if (bw) {
            // http://stackoverflow.com/a/3943023/112731
            return (r * 0.299 + g * 0.587 + b * 0.114) > 186
                ? '#000000'
                : '#FFFFFF';
        }
        // invert color components
        r = (255 - r).toString(16);
        g = (255 - g).toString(16);
        b = (255 - b).toString(16);
        // pad each with zeros and return
        return "#" + padZero(r) + padZero(g) + padZero(b);
    };
    PosterShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        const cell = this.state.cell;
        const poster = this.state.cell._model;
        const graph = this.state.view.graph;
        const renderEmtyShape = () => {
            const backgroundColor = graph.background ? graph.background : "#FFFFFF";
            const contrastColor = this.getContrastColor(backgroundColor === "none" ? "#FFFFFF" : backgroundColor);
            c.setStrokeColor(contrastColor);
            c.setFontColor(contrastColor);
            c.setFontSize(Math.round(h / 3));
            c.text(x + w/2, y + h/2, w, h, "Плакатов\nнет", mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, false, "", true, false, 0);
            mxRectangleShape.prototype.paintVertexShape.apply(this, arguments);
        };
        if (!poster) {
            renderEmtyShape();
            return;
        }
        const resData = poster.data.type.split("-") || [];
        const settedPosters = API.POSTERS.metadata.filter(meta => resData.includes(meta.key));
        const xOffset = w / 10;
        const yOffset = h / 10;
        /* check if this function has ben called from tracker process */
        if (cell._isHighlightRender) {
            /* render highlight rect */
            const steps = settedPosters.length > 1 ? settedPosters.length - 1 : 0;
            const rectWidth = w + xOffset * steps;
            const rectHeight = h + yOffset * steps;
            mxRectangleShape.prototype.paintVertexShape.call(this, c, x, y, rectWidth, rectHeight);
            /* reset hacking property */
            cell._isHighlightRender = false;
        } else {
            /* normal poster images render */
            for (let i = settedPosters.length - 1; i >= 0; i--) {
                this.image = settedPosters[i].src;
                mxImageShape.prototype.paintVertexShape.call(this, c, x + i * xOffset, y + i * yOffset, w, h);
            }
            if (settedPosters.length === 0) {
                renderEmtyShape();
            }
        }
    };
    PosterShape.prototype.constraints = [];
    mxCellRenderer.registerShape("poster", PosterShape);

    // Dispatcher mark shapes
    function DispatcherMarkShape() {
        mxImageShape.call(this);
    }
    mxUtils.extend(DispatcherMarkShape, mxImageShape);
    DispatcherMarkShape.prototype.isRoundable = function ()
    {
        return false;
    };
    DispatcherMarkShape.prototype.paintVertexShape = function (c, x, y, w, h)
    {
        const cell = this.state.cell;
        const dispatcherMark = cell._model;

        const renderDefaultShape = () => {
            this.image = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgd2lkdGg9IjEwMCIKICAgaGVpZ2h0PSIxMDAiCiAgIHZpZXdCb3g9IjAgMCAyNi40NTgzMzMgMjYuNDU4MzM0IgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmc4IgogICBzb2RpcG9kaTpkb2NuYW1lPSJpbmZvLnN2ZyIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMS4wLjItMiAoZTg2Yzg3MDg3OSwgMjAyMS0wMS0xNSkiPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMSIKICAgICBvYmplY3R0b2xlcmFuY2U9IjEwIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwMDAwIgogICAgIGd1aWRldG9sZXJhbmNlPSIxMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTkyMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSIxMDAxIgogICAgIGlkPSJuYW1lZHZpZXc5IgogICAgIHNob3dncmlkPSJ0cnVlIgogICAgIGlua3NjYXBlOnpvb209IjQuNDI3NDY3MyIKICAgICBpbmtzY2FwZTpjeD0iMTUuNzI1NjEzIgogICAgIGlua3NjYXBlOmN5PSI2Mi4xMjE2NTYiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9Ii05IgogICAgIGlua3NjYXBlOndpbmRvdy15PSItOSIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImxheWVyMSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC1yb3RhdGlvbj0iMCIKICAgICBpbmtzY2FwZTpzbmFwLWdsb2JhbD0idHJ1ZSI+CiAgICA8aW5rc2NhcGU6Z3JpZAogICAgICAgdHlwZT0ieHlncmlkIgogICAgICAgaWQ9ImdyaWQ4MzMiCiAgICAgICBzcGFjaW5neD0iMC4yNjQ1ODMzMyIKICAgICAgIHNwYWNpbmd5PSIwLjI2NDU4MzMzIgogICAgICAgZW1wc3BhY2luZz0iMTAiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPGRlZnMKICAgICBpZD0iZGVmczIiIC8+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNSI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGUgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpZD0ibGF5ZXIxIgogICAgIHN0eWxlPSJzdHJva2Utd2lkdGg6MS4wNTgzMztzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZSIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLjI2NDU4MzMyLDAuMjY0NTgxNTMpIj4KICAgIDx0ZXh0CiAgICAgICB4bWw6c3BhY2U9InByZXNlcnZlIgogICAgICAgc3R5bGU9ImZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtd2VpZ2h0Om5vcm1hbDtmb250LXNpemU6MjIuNTc3OHB4O2xpbmUtaGVpZ2h0OjEuMjU7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjtmaWxsOiNlNjQ2ZTY7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjAuMjgwMDE2IgogICAgICAgeD0iOS43MDQ5MDE3IgogICAgICAgeT0iMjAuODY5MDM0IgogICAgICAgaWQ9InRleHQ4NTEiPjx0c3BhbgogICAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgICBpZD0idHNwYW44NDkiCiAgICAgICAgIHg9IjkuNzA0OTAxNyIKICAgICAgICAgeT0iMjAuODY5MDM0IgogICAgICAgICBzdHlsZT0iZm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpib2xkO2ZvbnQtc3RyZXRjaDpub3JtYWw7Zm9udC1zaXplOjIyLjU3NzhweDtmb250LWZhbWlseTonVGltZXMgTmV3IFJvbWFuJzstaW5rc2NhcGUtZm9udC1zcGVjaWZpY2F0aW9uOidUaW1lcyBOZXcgUm9tYW4sIEJvbGQnO2ZpbGw6I2U2NDZlNjtmaWxsLW9wYWNpdHk6MTtzdHJva2Utd2lkdGg6MC4yODAwMTYiPmk8L3RzcGFuPjwvdGV4dD4KICA8L2c+Cjwvc3ZnPgo=";
            mxImageShape.prototype.paintVertexShape.apply(this, arguments);
        };
        const renderGroundingNumber = () => {
            c.setFontColor("#000000");
            const length = dispatcherMark.data.number.length;
            if (length <= 5) {
                c.setFontSize(Math.round(h / 3));
            } else {
                c.setFontSize(Math.round(h * 1.5 / length));
            }
            c.text(x + w / 2, y + h / 2, w, h, dispatcherMark.data.number, mxConstants.ALIGN_CENTER, mxConstants.ALIGN_MIDDLE, false, "", true, false, 0);
        };

        if (!dispatcherMark) {
            renderDefaultShape();
            return;
        }
        let mark = null;
        for (const meta of API.DISPATCHER_MARKS.metadata) {
            if (meta.key === dispatcherMark.data.type) {
                mark = meta;
                break;
            }
        }
        /* check if this function has ben called from tracker process */
        if (cell._isHighlightRender) {
            /* render highlight rect */
            mxRectangleShape.prototype.paintVertexShape.call(this, c, x, y, w, h);
            /* reset hacking property */
            cell._isHighlightRender = false;
        } else {
            /* normal mark image render */
            if (mark) {
                this.image = mark.src;
                mxImageShape.prototype.paintVertexShape.apply(this, arguments);
                if (mark.key === "numPortableGrounding")
                    renderGroundingNumber();
            } else {
                renderDefaultShape();
            }
        }
    };
    DispatcherMarkShape.prototype.constraints = [];
    mxCellRenderer.registerShape("dispatcher_mark", DispatcherMarkShape);

    // Registers and defines the custom markers
    mxMarker.addMarker('dash', function (c, shape, type, pe, unitX, unitY, size, source, sw, filled)
    {
        var nx = unitX * (size + sw + 1);
        var ny = unitY * (size + sw + 1);

        return function ()
        {
            c.begin();
            c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
            c.lineTo(pe.x + ny / 2 - 3 * nx / 2, pe.y - 3 * ny / 2 - nx / 2);
            c.stroke();
        };
    });
    mxMarker.addMarker('cross', function (c, shape, type, pe, unitX, unitY, size, source, sw, filled)
    {
        var nx = unitX * (size + sw + 1);
        var ny = unitY * (size + sw + 1);

        return function ()
        {
            c.begin();
            c.moveTo(pe.x - nx / 2 - ny / 2, pe.y - ny / 2 + nx / 2);
            c.lineTo(pe.x + ny / 2 - 3 * nx / 2, pe.y - 3 * ny / 2 - nx / 2);
            c.moveTo(pe.x - nx / 2 + ny / 2, pe.y - ny / 2 - nx / 2);
            c.lineTo(pe.x - ny / 2 - 3 * nx / 2, pe.y - 3 * ny / 2 + nx / 2);
            c.stroke();
        };
    });

    function circleMarker(c, shape, type, pe, unitX, unitY, size, source, sw, filled)
    {
        var a = size / 2;
        var size = size + sw;

        var pt = pe.clone();

        pe.x -= unitX * (2 * size + sw);
        pe.y -= unitY * (2 * size + sw);

        unitX = unitX * (size + sw);
        unitY = unitY * (size + sw);

        return function ()
        {
            c.ellipse(pt.x - unitX - size, pt.y - unitY - size, 2 * size, 2 * size);

            if (filled)
            {
                c.fillAndStroke();
            }
            else
            {
                c.stroke();
            }
        };
    }
    mxMarker.addMarker('circle', circleMarker);
    mxMarker.addMarker('circlePlus', function (c, shape, type, pe, unitX, unitY, size, source, sw, filled)
    {
        var pt = pe.clone();
        var fn = circleMarker.apply(this, arguments);
        var nx = unitX * (size + 2 * sw); // (size + sw + 1);
        var ny = unitY * (size + 2 * sw); //(size + sw + 1);

        return function ()
        {
            fn.apply(this, arguments);

            c.begin();
            c.moveTo(pt.x - unitX * (sw), pt.y - unitY * (sw));
            c.lineTo(pt.x - 2 * nx + unitX * (sw), pt.y - 2 * ny + unitY * (sw));
            c.moveTo(pt.x - nx - ny + unitY * sw, pt.y - ny + nx - unitX * sw);
            c.lineTo(pt.x + ny - nx - unitY * sw, pt.y - ny - nx + unitX * sw);
            c.stroke();
        };
    });
    mxMarker.addMarker('halfCircle', function (c, shape, type, pe, unitX, unitY, size, source, sw, filled)
    {
        var nx = unitX * (size + sw + 1);
        var ny = unitY * (size + sw + 1);
        var pt = pe.clone();

        pe.x -= nx;
        pe.y -= ny;

        return function ()
        {
            c.begin();
            c.moveTo(pt.x - ny, pt.y + nx);
            c.quadTo(pe.x - ny, pe.y + nx, pe.x, pe.y);
            c.quadTo(pe.x + ny, pe.y - nx, pt.x + ny, pt.y - nx);
            c.stroke();
        };
    });

    mxMarker.addMarker('async', function (c, shape, type, pe, unitX, unitY, size, source, sw, filled)
    {
        // The angle of the forward facing arrow sides against the x axis is
        // 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 ( / 2 allows for
        // only half the strokewidth is processed ).
        var endOffsetX = unitX * sw * 1.118;
        var endOffsetY = unitY * sw * 1.118;

        unitX = unitX * (size + sw);
        unitY = unitY * (size + sw);

        var pt = pe.clone();
        pt.x -= endOffsetX;
        pt.y -= endOffsetY;

        var f = 1;
        pe.x += -unitX * f - endOffsetX;
        pe.y += -unitY * f - endOffsetY;

        return function ()
        {
            c.begin();
            c.moveTo(pt.x, pt.y);

            if (source)
            {
                c.lineTo(pt.x - unitX - unitY / 2, pt.y - unitY + unitX / 2);
            }
            else
            {
                c.lineTo(pt.x + unitY / 2 - unitX, pt.y - unitY - unitX / 2);
            }

            c.lineTo(pt.x - unitX, pt.y - unitY);
            c.close();

            if (filled)
            {
                c.fillAndStroke();
            }
            else
            {
                c.stroke();
            }
        };
    });

    function createOpenAsyncArrow(widthFactor)
    {
        widthFactor = (widthFactor != null) ? widthFactor : 2;

        return function (c, shape, type, pe, unitX, unitY, size, source, sw, filled)
        {
            unitX = unitX * (size + sw);
            unitY = unitY * (size + sw);

            var pt = pe.clone();

            return function ()
            {
                c.begin();
                c.moveTo(pt.x, pt.y);

                if (source)
                {
                    c.lineTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);
                }
                else
                {
                    c.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);
                }

                c.stroke();
            };
        }
    }
    mxMarker.addMarker('openAsync', createOpenAsyncArrow(2));

    function arrow(canvas, shape, type, pe, unitX, unitY, size, source, sw, filled)
    {
        // The angle of the forward facing arrow sides against the x axis is 26.565 degrees, 1/sin(26.565) = 2.236 / 2 = 1.118 
        // (/ 2 allows for only half the strokewidth is processed ).
        var endOffsetX = unitX * sw * 1.118;
        var endOffsetY = unitY * sw * 1.118;

        unitX = unitX * (size + sw);
        unitY = unitY * (size + sw);

        var pt = pe.clone();
        pt.x -= endOffsetX;
        pt.y -= endOffsetY;

        var f = (type != mxConstants.ARROW_CLASSIC && type != mxConstants.ARROW_CLASSIC_THIN) ? 1 : 3 / 4;
        pe.x += -unitX * f - endOffsetX;
        pe.y += -unitY * f - endOffsetY;

        return function ()
        {
            canvas.begin();
            canvas.moveTo(pt.x, pt.y);
            canvas.lineTo(pt.x - unitX - unitY / widthFactor, pt.y - unitY + unitX / widthFactor);

            if (type == mxConstants.ARROW_CLASSIC || type == mxConstants.ARROW_CLASSIC_THIN)
            {
                canvas.lineTo(pt.x - unitX * 3 / 4, pt.y - unitY * 3 / 4);
            }

            canvas.lineTo(pt.x + unitY / widthFactor - unitX, pt.y - unitY - unitX / widthFactor);
            canvas.close();

            if (filled)
            {
                canvas.fillAndStroke();
            }
            else
            {
                canvas.stroke();
            }
        };
    }

    // Handlers are only added if mxVertexHandler is defined (ie. not in embedded graph)
    if (typeof mxVertexHandler !== 'undefined')
    {
        function createHandle(state, keys, getPositionFn, setPositionFn, ignoreGrid, redrawEdges)
        {
            var handle = new mxHandle(state, null, mxVertexHandler.prototype.secondaryHandleImage);

            handle.execute = function ()
            {
                for (var i = 0; i < keys.length; i++)
                {
                    this.copyStyle(keys[i]);
                }
            };

            handle.getPosition = getPositionFn;
            handle.setPosition = setPositionFn;
            handle.ignoreGrid = (ignoreGrid != null) ? ignoreGrid : true;

            // Overridden to update connected edges
            if (redrawEdges)
            {
                var positionChanged = handle.positionChanged;
                handle.positionChanged = function ()
                {
                    positionChanged.apply(this, arguments);

                    // Redraws connected edges TODO: Include child edges
                    state.view.invalidate(this.state.cell);
                    state.view.validate();
                };
            }

            return handle;
        }
        function createArcHandle(state, yOffset)
        {
            return createHandle(state, [mxConstants.STYLE_ARCSIZE], function (bounds)
            {
                var tmp = (yOffset != null) ? yOffset : bounds.height / 8;
                if (mxUtils.getValue(state.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0) == '1')
                {
                    var arcSize = mxUtils.getValue(state.style, mxConstants.STYLE_ARCSIZE, mxConstants.LINE_ARCSIZE) / 2;
                    return new mxPoint(bounds.x + bounds.width - Math.min(bounds.width / 2, arcSize), bounds.y + tmp);
                }
                else
                {
                    var arcSize = Math.max(0, parseFloat(mxUtils.getValue(state.style,
                        mxConstants.STYLE_ARCSIZE, mxConstants.RECTANGLE_ROUNDING_FACTOR * 100))) / 100;
                    return new mxPoint(bounds.x + bounds.width - Math.min(Math.max(bounds.width / 2, bounds.height / 2),
                        Math.min(bounds.width, bounds.height) * arcSize), bounds.y + tmp);
                }
            }, function (bounds, pt, me)
                {
                    if (mxUtils.getValue(state.style, mxConstants.STYLE_ABSOLUTE_ARCSIZE, 0) == '1')
                    {
                        this.state.style[mxConstants.STYLE_ARCSIZE] = Math.round(Math.max(0, Math.min(bounds.width, (bounds.x + bounds.width - pt.x) * 2)));
                    }
                    else
                    {
                        var f = Math.min(50, Math.max(0, (bounds.width - pt.x + bounds.x) * 100 / Math.min(bounds.width, bounds.height)));
                        this.state.style[mxConstants.STYLE_ARCSIZE] = Math.round(f);
                    }
                });
        }
        function createArcHandleFunction()
        {
            return function (state)
            {
                var handles = [];

                if (mxUtils.getValue(state.style, mxConstants.STYLE_ROUNDED, false))
                {
                    handles.push(createArcHandle(state));
                }

                return handles;
            };
        }
        function createParallelogramHandleFunction()
        {
            var max = 1;
            return function (state)
            {
                var handles = [createHandle(state, ['size'], function (bounds)
                {
                    var size = Math.max(0, Math.min(max, parseFloat(mxUtils.getValue(this.state.style, 'size', TrapezoidShape.prototype.size))));

                    return new mxPoint(bounds.x + size * bounds.width * 0.75, bounds.y + bounds.height / 4);
                }, function (bounds, pt)
                    {
                        this.state.style['size'] = Math.max(0, Math.min(max, (pt.x - bounds.x) / (bounds.width * 0.75)));
                    }, null, true)];

                if (mxUtils.getValue(state.style, mxConstants.STYLE_ROUNDED, false))
                {
                    handles.push(createArcHandle(state));
                }

                return handles;
            };
        }
        function createTrapezoidHandleFunction()
        {
            var max = 0.5;
            return function (state)
            {
                var handles = [createHandle(state, ['size'], function (bounds)
                {
                    var size = Math.max(0, Math.min(max, parseFloat(mxUtils.getValue(this.state.style, 'size', TrapezoidShape.prototype.size))));

                    return new mxPoint(bounds.x + size * bounds.width * 0.75, bounds.y + bounds.height / 4);
                }, function (bounds, pt)
                    {
                        this.state.style['size'] = Math.max(0, Math.min(max, (pt.x - bounds.x) / (bounds.width * 0.75)));
                    }, null, true)];

                if (mxUtils.getValue(state.style, mxConstants.STYLE_ROUNDED, false))
                {
                    handles.push(createArcHandle(state));
                }

                return handles;
            };
        }
        function createCubeHandleFunction(factor, defaultValue, allowArcHandle)
        {
            var factor = 1;
            var defaultValue = CubeShape.prototype.size;
            var allowArcHandle = false;

            return function (state)
            {
                var handles = [createHandle(state, ['size'], function (bounds)
                {
                    var size = Math.max(0, Math.min(bounds.width, Math.min(bounds.height, parseFloat(
                        mxUtils.getValue(this.state.style, 'size', defaultValue))))) * factor;

                    return new mxPoint(bounds.x + size, bounds.y + size);
                }, function (bounds, pt)
                    {
                        this.state.style['size'] = Math.round(Math.max(0, Math.min(Math.min(bounds.width, pt.x - bounds.x),
                            Math.min(bounds.height, pt.y - bounds.y))) / factor);
                    })];

                if (allowArcHandle && mxUtils.getValue(state.style, mxConstants.STYLE_ROUNDED, false))
                {
                    handles.push(createArcHandle(state));
                }

                return handles;
            };
        }
        function createArrowHandleFunction(maxSize)
        {
            return function (state)
            {
                return [createHandle(state, ['arrowWidth', 'arrowSize'], function (bounds)
                {
                    var aw = Math.max(0, Math.min(1, mxUtils.getValue(this.state.style, 'arrowWidth', SingleArrowShape.prototype.arrowWidth)));
                    var as = Math.max(0, Math.min(maxSize, mxUtils.getValue(this.state.style, 'arrowSize', SingleArrowShape.prototype.arrowSize)));

                    return new mxPoint(bounds.x + (1 - as) * bounds.width, bounds.y + (1 - aw) * bounds.height / 2);
                }, function (bounds, pt)
                    {
                        this.state.style['arrowWidth'] = Math.max(0, Math.min(1, Math.abs(bounds.y + bounds.height / 2 - pt.y) / bounds.height * 2));
                        this.state.style['arrowSize'] = Math.max(0, Math.min(maxSize, (bounds.x + bounds.width - pt.x) / (bounds.width)));
                    })];
            };
        }
        function createEdgeHandle(state, keys, start, getPosition, setPosition)
        {
            return createHandle(state, keys, function (bounds)
            {
                var pts = state.absolutePoints;
                var n = pts.length - 1;

                var tr = state.view.translate;
                var s = state.view.scale;

                var p0 = (start) ? pts[0] : pts[n];
                var p1 = (start) ? pts[1] : pts[n - 1];
                var dx = (start) ? p1.x - p0.x : p1.x - p0.x;
                var dy = (start) ? p1.y - p0.y : p1.y - p0.y;

                var dist = Math.sqrt(dx * dx + dy * dy);

                var pt = getPosition.call(this, dist, dx / dist, dy / dist, p0, p1);

                return new mxPoint(pt.x / s - tr.x, pt.y / s - tr.y);
            }, function (bounds, pt, me)
                {
                    var pts = state.absolutePoints;
                    var n = pts.length - 1;

                    var tr = state.view.translate;
                    var s = state.view.scale;

                    var p0 = (start) ? pts[0] : pts[n];
                    var p1 = (start) ? pts[1] : pts[n - 1];
                    var dx = (start) ? p1.x - p0.x : p1.x - p0.x;
                    var dy = (start) ? p1.y - p0.y : p1.y - p0.y;

                    var dist = Math.sqrt(dx * dx + dy * dy);
                    pt.x = (pt.x + tr.x) * s;
                    pt.y = (pt.y + tr.y) * s;

                    setPosition.call(this, dist, dx / dist, dy / dist, p0, p1, pt, me);
                });
        }
        function createEdgeWidthHandle(state, start, spacing)
        {
            return createEdgeHandle(state, ['width'], start, function (dist, nx, ny, p0, p1)
            {
                var w = state.shape.getEdgeWidth() * state.view.scale + spacing;
                return new mxPoint(p0.x + nx * dist / 4 + ny * w / 2, p0.y + ny * dist / 4 - nx * w / 2);
            }, function (dist, nx, ny, p0, p1, pt)
                {
                    var w = Math.sqrt(mxUtils.ptSegDistSq(p0.x, p0.y, p1.x, p1.y, pt.x, pt.y));
                    state.style['width'] = Math.round(w * 2) / state.view.scale - spacing;
                });
        }

        var handleFactory = {
            'link': function (state)
            {
                var spacing = 10;
                return [createEdgeWidthHandle(state, true, spacing), createEdgeWidthHandle(state, false, spacing)];
            },
            'flexArrow': function (state)
            {
                // Do not use state.shape.startSize/endSize since it is cached
                var tol = state.view.graph.gridSize / state.view.scale;
                var handles = [];

                if (mxUtils.getValue(state.style, mxConstants.STYLE_STARTARROW, mxConstants.NONE) != mxConstants.NONE)
                {
                    handles.push(createEdgeHandle(state, ['width', mxConstants.STYLE_STARTSIZE, mxConstants.STYLE_ENDSIZE], true, function (dist, nx, ny, p0, p1)
                    {
                        var w = (state.shape.getEdgeWidth() - state.shape.strokewidth) * state.view.scale;
                        var l = mxUtils.getNumber(state.style, mxConstants.STYLE_STARTSIZE, mxConstants.ARROW_SIZE / 5) * 3 * state.view.scale;

                        return new mxPoint(p0.x + nx * (l + state.shape.strokewidth * state.view.scale) + ny * w / 2,
                            p0.y + ny * (l + state.shape.strokewidth * state.view.scale) - nx * w / 2);
                    }, function (dist, nx, ny, p0, p1, pt, me)
                        {
                            var w = Math.sqrt(mxUtils.ptSegDistSq(p0.x, p0.y, p1.x, p1.y, pt.x, pt.y));
                            var l = mxUtils.ptLineDist(p0.x, p0.y, p0.x + ny, p0.y - nx, pt.x, pt.y);

                            state.style[mxConstants.STYLE_STARTSIZE] = Math.round((l - state.shape.strokewidth) * 100 / 3) / 100 / state.view.scale;
                            state.style['width'] = Math.round(w * 2) / state.view.scale;

                            // Applies to opposite side
                            if (mxEvent.isControlDown(me.getEvent()))
                            {
                                state.style[mxConstants.STYLE_ENDSIZE] = state.style[mxConstants.STYLE_STARTSIZE];
                            }

                            // Snaps to end geometry
                            if (!mxEvent.isAltDown(me.getEvent()))
                            {
                                if (Math.abs(parseFloat(state.style[mxConstants.STYLE_STARTSIZE]) - parseFloat(state.style[mxConstants.STYLE_ENDSIZE])) < tol / 6)
                                {
                                    state.style[mxConstants.STYLE_STARTSIZE] = state.style[mxConstants.STYLE_ENDSIZE];
                                }
                            }
                        }));
                    handles.push(createEdgeHandle(state, ['startWidth', 'endWidth', mxConstants.STYLE_STARTSIZE, mxConstants.STYLE_ENDSIZE], true, function (dist, nx, ny, p0, p1)
                    {
                        var w = (state.shape.getStartArrowWidth() - state.shape.strokewidth) * state.view.scale;
                        var l = mxUtils.getNumber(state.style, mxConstants.STYLE_STARTSIZE, mxConstants.ARROW_SIZE / 5) * 3 * state.view.scale;

                        return new mxPoint(p0.x + nx * (l + state.shape.strokewidth * state.view.scale) + ny * w / 2,
                            p0.y + ny * (l + state.shape.strokewidth * state.view.scale) - nx * w / 2);
                    }, function (dist, nx, ny, p0, p1, pt, me)
                        {
                            var w = Math.sqrt(mxUtils.ptSegDistSq(p0.x, p0.y, p1.x, p1.y, pt.x, pt.y));
                            var l = mxUtils.ptLineDist(p0.x, p0.y, p0.x + ny, p0.y - nx, pt.x, pt.y);

                            state.style[mxConstants.STYLE_STARTSIZE] = Math.round((l - state.shape.strokewidth) * 100 / 3) / 100 / state.view.scale;
                            state.style['startWidth'] = Math.max(0, Math.round(w * 2) - state.shape.getEdgeWidth()) / state.view.scale;

                            // Applies to opposite side
                            if (mxEvent.isControlDown(me.getEvent()))
                            {
                                state.style[mxConstants.STYLE_ENDSIZE] = state.style[mxConstants.STYLE_STARTSIZE];
                                state.style['endWidth'] = state.style['startWidth'];
                            }

                            // Snaps to endWidth
                            if (!mxEvent.isAltDown(me.getEvent()))
                            {
                                if (Math.abs(parseFloat(state.style[mxConstants.STYLE_STARTSIZE]) - parseFloat(state.style[mxConstants.STYLE_ENDSIZE])) < tol / 6)
                                {
                                    state.style[mxConstants.STYLE_STARTSIZE] = state.style[mxConstants.STYLE_ENDSIZE];
                                }

                                if (Math.abs(parseFloat(state.style['startWidth']) - parseFloat(state.style['endWidth'])) < tol)
                                {
                                    state.style['startWidth'] = state.style['endWidth'];
                                }
                            }
                        }));
                }

                if (mxUtils.getValue(state.style, mxConstants.STYLE_ENDARROW, mxConstants.NONE) != mxConstants.NONE)
                {
                    handles.push(createEdgeHandle(state, ['width', mxConstants.STYLE_STARTSIZE, mxConstants.STYLE_ENDSIZE], false, function (dist, nx, ny, p0, p1)
                    {
                        var w = (state.shape.getEdgeWidth() - state.shape.strokewidth) * state.view.scale;
                        var l = mxUtils.getNumber(state.style, mxConstants.STYLE_ENDSIZE, mxConstants.ARROW_SIZE / 5) * 3 * state.view.scale;

                        return new mxPoint(p0.x + nx * (l + state.shape.strokewidth * state.view.scale) - ny * w / 2,
                            p0.y + ny * (l + state.shape.strokewidth * state.view.scale) + nx * w / 2);
                    }, function (dist, nx, ny, p0, p1, pt, me)
                        {
                            var w = Math.sqrt(mxUtils.ptSegDistSq(p0.x, p0.y, p1.x, p1.y, pt.x, pt.y));
                            var l = mxUtils.ptLineDist(p0.x, p0.y, p0.x + ny, p0.y - nx, pt.x, pt.y);

                            state.style[mxConstants.STYLE_ENDSIZE] = Math.round((l - state.shape.strokewidth) * 100 / 3) / 100 / state.view.scale;
                            state.style['width'] = Math.round(w * 2) / state.view.scale;

                            // Applies to opposite side
                            if (mxEvent.isControlDown(me.getEvent()))
                            {
                                state.style[mxConstants.STYLE_STARTSIZE] = state.style[mxConstants.STYLE_ENDSIZE];
                            }

                            // Snaps to start geometry
                            if (!mxEvent.isAltDown(me.getEvent()))
                            {
                                if (Math.abs(parseFloat(state.style[mxConstants.STYLE_ENDSIZE]) - parseFloat(state.style[mxConstants.STYLE_STARTSIZE])) < tol / 6)
                                {
                                    state.style[mxConstants.STYLE_ENDSIZE] = state.style[mxConstants.STYLE_STARTSIZE];
                                }
                            }
                        }));
                    handles.push(createEdgeHandle(state, ['startWidth', 'endWidth', mxConstants.STYLE_STARTSIZE, mxConstants.STYLE_ENDSIZE], false, function (dist, nx, ny, p0, p1)
                    {
                        var w = (state.shape.getEndArrowWidth() - state.shape.strokewidth) * state.view.scale;
                        var l = mxUtils.getNumber(state.style, mxConstants.STYLE_ENDSIZE, mxConstants.ARROW_SIZE / 5) * 3 * state.view.scale;

                        return new mxPoint(p0.x + nx * (l + state.shape.strokewidth * state.view.scale) - ny * w / 2,
                            p0.y + ny * (l + state.shape.strokewidth * state.view.scale) + nx * w / 2);
                    }, function (dist, nx, ny, p0, p1, pt, me)
                        {
                            var w = Math.sqrt(mxUtils.ptSegDistSq(p0.x, p0.y, p1.x, p1.y, pt.x, pt.y));
                            var l = mxUtils.ptLineDist(p0.x, p0.y, p0.x + ny, p0.y - nx, pt.x, pt.y);

                            state.style[mxConstants.STYLE_ENDSIZE] = Math.round((l - state.shape.strokewidth) * 100 / 3) / 100 / state.view.scale;
                            state.style['endWidth'] = Math.max(0, Math.round(w * 2) - state.shape.getEdgeWidth()) / state.view.scale;

                            // Applies to opposite side
                            if (mxEvent.isControlDown(me.getEvent()))
                            {
                                state.style[mxConstants.STYLE_STARTSIZE] = state.style[mxConstants.STYLE_ENDSIZE];
                                state.style['startWidth'] = state.style['endWidth'];
                            }

                            // Snaps to start geometry
                            if (!mxEvent.isAltDown(me.getEvent()))
                            {
                                if (Math.abs(parseFloat(state.style[mxConstants.STYLE_ENDSIZE]) - parseFloat(state.style[mxConstants.STYLE_STARTSIZE])) < tol / 6)
                                {
                                    state.style[mxConstants.STYLE_ENDSIZE] = state.style[mxConstants.STYLE_STARTSIZE];
                                }

                                if (Math.abs(parseFloat(state.style['endWidth']) - parseFloat(state.style['startWidth'])) < tol)
                                {
                                    state.style['endWidth'] = state.style['startWidth'];
                                }
                            }
                        }));
                }

                return handles;
            },
            'swimlane': function (state)
            {
                var handles = [createHandle(state, [mxConstants.STYLE_STARTSIZE], function (bounds)
                {
                    var size = parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));

                    if (mxUtils.getValue(state.style, mxConstants.STYLE_HORIZONTAL, 1) == 1)
                    {
                        return new mxPoint(bounds.getCenterX(), bounds.y + Math.max(0, Math.min(bounds.height, size)));
                    }
                    else
                    {
                        return new mxPoint(bounds.x + Math.max(0, Math.min(bounds.width, size)), bounds.getCenterY());
                    }
                }, function (bounds, pt)
                    {
                        state.style[mxConstants.STYLE_STARTSIZE] =
                            (mxUtils.getValue(this.state.style, mxConstants.STYLE_HORIZONTAL, 1) == 1) ?
                                Math.round(Math.max(0, Math.min(bounds.height, pt.y - bounds.y))) :
                                Math.round(Math.max(0, Math.min(bounds.width, pt.x - bounds.x)));
                    })];

                if (mxUtils.getValue(state.style, mxConstants.STYLE_ROUNDED))
                {
                    var size = parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
                    handles.push(createArcHandle(state, size / 2));
                }

                return handles;
            },
            'table': function (state)
            {
                var handles = [createHandle(state, [mxConstants.STYLE_STARTSIZE], function (bounds)
                {
                    var size = parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));

                    if (mxUtils.getValue(state.style, mxConstants.STYLE_HORIZONTAL, 1) == 1)
                    {
                        return new mxPoint(bounds.getCenterX(), bounds.y + Math.max(0, Math.min(bounds.height, size)));
                    }
                    else
                    {
                        return new mxPoint(bounds.x + Math.max(0, Math.min(bounds.width, size)), bounds.getCenterY());
                    }
                }, function (bounds, pt)
                    {
                        state.style[mxConstants.STYLE_STARTSIZE] =
                            (mxUtils.getValue(this.state.style, mxConstants.STYLE_HORIZONTAL, 1) == 1) ?
                                Math.round(Math.max(0, Math.min(bounds.height, pt.y - bounds.y))) :
                                Math.round(Math.max(0, Math.min(bounds.width, pt.x - bounds.x)));
                    })];

                if (mxUtils.getValue(state.style, mxConstants.STYLE_ROUNDED))
                {
                    var size = parseFloat(mxUtils.getValue(state.style, mxConstants.STYLE_STARTSIZE, mxConstants.DEFAULT_STARTSIZE));
                    handles.push(createArcHandle(state, size / 2));
                }

                return handles;
            },
            'label': createArcHandleFunction(),
            'rectangle': createArcHandleFunction(),
            'triangle': createArcHandleFunction(),
            'rhombus': createArcHandleFunction(),
            'singleArrow': createArrowHandleFunction(1),
            'doubleArrow': createArrowHandleFunction(0.5),
            'cube': createCubeHandleFunction(),
            'trapezoid': createTrapezoidHandleFunction(), 
            'parallelogram': createParallelogramHandleFunction()
        };

        // Exposes custom handles
        Graph.createHandle  = createHandle;
        Graph.handleFactory = handleFactory;

        mxVertexHandler.prototype.createCustomHandles = function ()
        {
            // Not rotatable means locked
            if (this.state.view.graph.getSelectionCount() == 1)
            {
                //if (this.graph.isCellRotatable(this.state.cell))
                // LATER: Make locked state independent of rotatable flag, fix toggle if default is false
                //if (this.graph.isCellResizable(this.state.cell) || this.graph.isCellMovable(this.state.cell))
                {
                    var name = this.state.style['shape'];
                    if (mxCellRenderer.defaultShapes[name] == null)
                        name = mxConstants.SHAPE_RECTANGLE;

                    var fn = handleFactory[name];
                    if (fn == null && this.state.shape != null && this.state.shape.isRoundable())
                        fn = handleFactory[mxConstants.SHAPE_RECTANGLE];

                    if (fn != null)
                        return fn(this.state);
                }
            }

            return null;
        };
        mxEdgeHandler.prototype.createCustomHandles = function ()
        {
            if (this.state.view.graph.getSelectionCount() == 1)
            {
                var name = this.state.style['shape'];
                if (mxCellRenderer.defaultShapes[name] == null)
                    name = mxConstants.SHAPE_CONNECTOR;

                var fn = handleFactory[name];
                if (fn != null)
                    return fn(this.state);
            }

            return null;
        };
    }

    mxEdgeStyle.IsometricConnector = function (state, source, target, points, result)
    {
        var isoHVector = new mxPoint(1, 0);
        var alpha1 = mxUtils.toRadians(-30);
        isoHVector = mxUtils.getRotatedPoint(isoHVector, Math.cos(alpha1), Math.sin(alpha1));

        var isoVVector = new mxPoint(1, 0);
        var alpha2 = mxUtils.toRadians(-150);
        isoVVector = mxUtils.getRotatedPoint(isoVVector, Math.cos(alpha2), Math.sin(alpha2));

        var view = state.view;
        var pt = (points != null && points.length > 0) ? points[0] : null;
        var pts = state.absolutePoints;
        var p0 = pts[0];
        var pe = pts[pts.length - 1];

        if (pt != null)
            pt = view.transformControlPoint(state, pt);

        if (p0 == null)
        {
            if (source != null)
                p0 = new mxPoint(source.getCenterX(), source.getCenterY());
        }

        if (pe == null)
        {
            if (target != null)
                pe = new mxPoint(target.getCenterX(), target.getCenterY());
        }

        var a1 = isoHVector.x;
        var a2 = isoHVector.y;

        var b1 = isoVVector.x;
        var b2 = isoVVector.y;

        var elbow = mxUtils.getValue(state.style, 'elbow', 'horizontal') == 'horizontal';

        if (pe != null && p0 != null)
        {
            var last = p0;
            function isoLineTo(x, y, ignoreFirst)
            {
                var c1 = x - last.x;
                var c2 = y - last.y;

                // Solves for isometric base vectors
                var h = (b2 * c1 - b1 * c2) / (a1 * b2 - a2 * b1);
                var v = (a2 * c1 - a1 * c2) / (a2 * b1 - a1 * b2);

                if (elbow)
                {
                    if (ignoreFirst)
                    {
                        last = new mxPoint(last.x + a1 * h, last.y + a2 * h);
                        result.push(last);
                    }

                    last = new mxPoint(last.x + b1 * v, last.y + b2 * v);
                    result.push(last);
                }
                else
                {
                    if (ignoreFirst)
                    {
                        last = new mxPoint(last.x + b1 * v, last.y + b2 * v);
                        result.push(last);
                    }

                    last = new mxPoint(last.x + a1 * h, last.y + a2 * h);
                    result.push(last);
                }
            }

            if (pt == null)
                pt = new mxPoint(p0.x + (pe.x - p0.x) / 2, p0.y + (pe.y - p0.y) / 2);

            isoLineTo(pt.x, pt.y, true);
            isoLineTo(pe.x, pe.y, false);
        }
    };
    mxStyleRegistry.putValue(mxConstants.EDGESTYLE_ISOMETRIC, mxEdgeStyle.IsometricConnector);

    var graphCreateEdgeHandler = Graph.prototype.createEdgeHandler;
    Graph.prototype.createEdgeHandler = function (state, edgeStyle)
    {
        if (edgeStyle == mxEdgeStyle.IsometricConnector)
        {
            var handler = new mxElbowEdgeHandler(state);
            handler.snapToTerminals = false;
            return handler;
        }
        return graphCreateEdgeHandler.apply(this, arguments);
    };

    // Defines connection points for all shapes
    mxRectangleShape.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0.5, 0), true, 'N'),
                                              new mxConnectionConstraint(new mxPoint(0, 0.5), true, 'W'),
                                              new mxConnectionConstraint(new mxPoint(1, 0.5), true, 'E'),
                                              new mxConnectionConstraint(new mxPoint(0.5, 1), true, 'S')];
    mxEllipse.prototype.constraints       = mxRectangleShape.prototype.constraints;
    mxLabel.prototype.constraints         = mxRectangleShape.prototype.constraints;
    mxImageShape.prototype.constraints    = mxRectangleShape.prototype.constraints;
    mxSwimlane.prototype.constraints      = mxRectangleShape.prototype.constraints;
    mxDoubleEllipse.prototype.constraints = mxRectangleShape.prototype.constraints;
    mxRhombus.prototype.constraints       = mxRectangleShape.prototype.constraints;

    mxTriangle.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                        new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                        new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                        new mxConnectionConstraint(new mxPoint(1, 0.5), true)];
    mxHexagon.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0.375, 0), true),
                                        new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                        new mxConnectionConstraint(new mxPoint(0.625, 0), true),
                                        new mxConnectionConstraint(new mxPoint(0, 0.25), true),
                                        new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                        new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                        new mxConnectionConstraint(new mxPoint(1, 0.25), true),
                                        new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                        new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                        new mxConnectionConstraint(new mxPoint(0.375, 1), true),
                                        new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                        new mxConnectionConstraint(new mxPoint(0.625, 1), true)];
    mxCloud.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0.25, 0.25), false),
                                    new mxConnectionConstraint(new mxPoint(0.4, 0.1), false),
                                    new mxConnectionConstraint(new mxPoint(0.16, 0.55), false),
                                    new mxConnectionConstraint(new mxPoint(0.07, 0.4), false),
                                    new mxConnectionConstraint(new mxPoint(0.31, 0.8), false),
                                    new mxConnectionConstraint(new mxPoint(0.13, 0.77), false),
                                    new mxConnectionConstraint(new mxPoint(0.8, 0.8), false),
                                    new mxConnectionConstraint(new mxPoint(0.55, 0.95), false),
                                    new mxConnectionConstraint(new mxPoint(0.875, 0.5), false),
                                    new mxConnectionConstraint(new mxPoint(0.96, 0.7), false),
                                    new mxConnectionConstraint(new mxPoint(0.625, 0.2), false),
                                    new mxConnectionConstraint(new mxPoint(0.88, 0.25), false)];
    mxCylinder.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                        new mxConnectionConstraint(new mxPoint(0, 0.5), true),
                                        new mxConnectionConstraint(new mxPoint(1, 0.5), true),
                                        new mxConnectionConstraint(new mxPoint(0.5, 1), true)];
    mxActor.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0.5, 0), true),
                                     new mxConnectionConstraint(new mxPoint(0.25, 0.2), false),
                                     new mxConnectionConstraint(new mxPoint(0.1, 0.5), false),
                                     new mxConnectionConstraint(new mxPoint(0, 0.75), true),
                                     new mxConnectionConstraint(new mxPoint(0.75, 0.25), false),
                                     new mxConnectionConstraint(new mxPoint(0.9, 0.5), false),
                                     new mxConnectionConstraint(new mxPoint(1, 0.75), true),
                                     new mxConnectionConstraint(new mxPoint(0.25, 1), true),
                                     new mxConnectionConstraint(new mxPoint(0.5, 1), true),
                                     new mxConnectionConstraint(new mxPoint(0.75, 1), true)];
    mxLine.prototype.constraints = [new mxConnectionConstraint(new mxPoint(0, 0.5), false),
                                    new mxConnectionConstraint(new mxPoint(0.25, 0.5), false),
                                    new mxConnectionConstraint(new mxPoint(0.75, 0.5), false),
                                    new mxConnectionConstraint(new mxPoint(1, 0.5), false)];

    mxArrow.prototype.constraints = null;

    TrapezoidShape.prototype.constraints     = mxRectangleShape.prototype.constraints;
    ParallelogramShape.prototype.constraints = mxRectangleShape.prototype.constraints;

    CubeShape.prototype.getConstraints = function (style, w, h)
    {
        var constr = [];
        var s = Math.max(0, Math.min(w, Math.min(h, parseFloat(mxUtils.getValue(this.style, 'size', this.size)))));

        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - s) * 0.5, 0));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - s, 0));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - s * 0.5, s * 0.5));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, s));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w, (h + s) * 0.5));
        constr.push(new mxConnectionConstraint(new mxPoint(1, 1), false));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w + s) * 0.5, h));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, s, h));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, s * 0.5, h - s * 0.5));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - s));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, (h - s) * 0.5));

        return (constr);
    };
    SingleArrowShape.prototype.getConstraints = function (style, w, h)
    {
        var constr = [];
        var aw = h * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowWidth', this.arrowWidth))));
        var as = w * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowSize', this.arrowSize))));
        var at = (h - aw) / 2;
        var ab = at + aw;

        constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, at));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - as) * 0.5, at));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - as, 0));
        constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - as, h));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, (w - as) * 0.5, h - at));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, 0, h - at));

        return (constr);
    };
    DoubleArrowShape.prototype.getConstraints = function (style, w, h)
    {
        var constr = [];
        var aw = h * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowWidth', SingleArrowShape.prototype.arrowWidth))));
        var as = w * Math.max(0, Math.min(1, parseFloat(mxUtils.getValue(this.style, 'arrowSize', SingleArrowShape.prototype.arrowSize))));
        var at = (h - aw) / 2;
        var ab = at + aw;

        constr.push(new mxConnectionConstraint(new mxPoint(0, 0.5), false));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, as, 0));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5, at));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - as, 0));
        constr.push(new mxConnectionConstraint(new mxPoint(1, 0.5), false));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w - as, h));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, w * 0.5, h - at));
        constr.push(new mxConnectionConstraint(new mxPoint(0, 0), false, null, as, h));

        return (constr);
    };
})();

//ViewMode.js



// import * as mxgraph from 'mxgraph';
// import { HELP, isNullOrEmpty } from './client'
// import ScriptHandler from './Scripts';
// import Chart from "chart.js"
// let { 
//     mxGraphModel, 
//     mxUtils, 
//     mxConstants,
//     mxPopupMenu,
//     mxCell,
//     mxEventSource,
//     mxCellTracker,
//     mxCodecRegistry,

// } = mxgraph();
/**
 * View mode logic
 */

function ViewModeHandler (editorUI)
//export default function ViewModeHandler (editorUI)
{
    mxEventSource.call(this);

    this.ui      = editorUI;
    this.marksService = editorUI.marksService;
    this.editor  = this.ui.editor;
    this.graph   = this.editor.graph;
    this.model   = this.graph.getModel();
    this.scripts = new ScriptHandler(this.ui);
    this.init();

// @if !LINKMT
    this.marksService.fetchPosters();
    this.marksService.fetchMarks();
    
    // @endif
   
};
mxUtils.extend(ViewModeHandler, mxEventSource);

ViewModeHandler.prototype.init = function()
{
    this.createMenubar();
    const _marksService = this.marksService;
    // Highlight cell in view mode
    const tracker = new mxCellTracker(this.graph, '#060606', function (me)
    {
        const specialElements = ["poster", "dispatcher_mark"];
        const cell = me.getCell();
     
        /* disable when dispatcher editing enabled */
        if (_marksService.isEnabled()) {
            const cellState = cell ? this.graph.view.getState(cell) : null;
            if (cellState && !specialElements.includes(cell.value.tagName)) {
                cellState.setCursor("default");
            }
            return null;
        }

        /* detect mouse enter on cell */
        if (cell != this._cell)
        {
            this._cell = cell;

            if (this._cell != null)
            {
                /* mouse entered on cell */
                /* hack for special elements highligt render */
                if (specialElements.includes(cell.value.tagName)) {
                    cell._isHighlightRender = true;
                }
            }
        }

        if (cell != null) 
        {
            if (cell.commands != null || cell.action != null || specialElements.includes(cell.value.tagName))
            {
                let cellState = this.graph.view.getState(cell);
                if (cellState == null) {
                    return null;
                }
                cellState.setCursor(mxConstants.CURSOR_CONNECT);
                return cell;
            }

            let parent = cell.getParent();
            if (parent != null && (parent.commands != null || parent.action != null))
            {
                let cellState = this.graph.view.getState(parent);
                if (cellState == null) {
                    return null;
                }
                cellState.setCursor(mxConstants.CURSOR_CONNECT);
                return cell;
            }
        }
        return null;
    });

    // Open outline window
    //var outlineAction = this.ui.actions.get('outline');
    //if (outlineAction)
    //    outlineAction.funct();

    mxPopupMenu.prototype.useLeftButtonForPopup = true;

    // Ignores canvas in codecs
    mxCell.prototype.mxTransient.push('chart', 'canvas', 'onBindingsUpdated');
    mxCodecRegistry.getCodec(mxCell).exclude.push('chart', 'canvas', 'onBindingsUpdated');
    mxCodecRegistry.getCodec(mxGraphModel).exclude.push('chart', 'canvas', 'onBindingsUpdated');

    Chart.defaults.global.animation.duration = 0;
    Chart.defaults.global.hover.animationDuration = 0;
    Chart.defaults.global.responsiveAnimationDuration = 0;
    Chart.defaults.global.tooltips.enabled = false;

    this.names   = [];          // tag names
    this.links   = {};          // equipmentID   <--> items's  map
    this.cellMap = new Map();   // binding value <--> cell map


    const cells = this.getSchemeCells();
   
    for (let i = 0; i < cells.length; i++)
    {
        
        let cell = cells[i];
       
        if (!cell)
            continue;

        // find scriptor
        this.scripts.setup(cell);
        if (cell.scriptor == null)
            continue;
        // save original cell params for dynamic changes
        if (cell.origin == null)
        {
            cell.origin = {};
            cell.origin.style = this.graph.getCellStyle(cell);
            cell.origin.state = this.graph.view.getState(cell, true).clone();
            let geom = this.graph.getCellGeometry(cell);
            cell.origin.geometry = geom != null ? geom.clone() : null;
        }
        
        // cell binding map
        if (cell.bindingMap == null)
            cell.bindingMap = {};

        let map = { tag: [], eq: [] };
        cell.scriptor.visit(cell, map);

        // process tags
        if (map.tag.length > 0)
        {
            for (let j = 0; j < map.tag.length; j++)
            {
                let bindValue = map.tag[j].id;
                if (this.names.indexOf(bindValue) < 0)
                    this.names.push(bindValue);
                this.updateCellMapping(cell, bindValue);
                this.updateBindMapping(cell, bindValue);
            }
        }
        // process equipments
        if (map.eq.length > 0)
        {
            for (let j = 0; j < map.eq.length; j++)
            {
                let bindValue = map.eq[j].id;
                let eqID = map.eq[j].parent;
                eqID = !isNullOrEmpty(eqID) ? eqID : bindValue;
                // update equipments map
                let eq_mapping = this.links[eqID] || [];
                if (eq_mapping.indexOf(bindValue) < 0)
                    eq_mapping.push(bindValue);
                this.links[eqID] = eq_mapping;
                this.updateCellMapping(cell, bindValue);
                this.updateBindMapping(cell, bindValue);
            }
        }

        this.graph.view.invalidate(cell, true);
    }

    this.findMappedCells = mxUtils.bind(this, function (link)
    {
        return this.cellMap.get(link) || [];
    });
    this.dataProcessor = mxUtils.bind(this, function (cell, item, initial)
    {
        this.proceessDataItem(cell, item, initial);
    });

    this.graph.view.validate();

    this.initialization = true;
    this.setupHubs();
};

ViewModeHandler.prototype.createMenubar = function ()
{
};

ViewModeHandler.prototype.updateBindMapping = function (cell, value)
{
    cell.bindingMap[value] = cell.bindingMap[value] || [];
   
    let bindings = cell.getBindingsByID(value);
    bindings.forEach(function (b)
    {
        if (cell.bindingMap[value].indexOf(b) < 0)
            cell.bindingMap[value].push(b);
    });
}

ViewModeHandler.prototype.updateCellMapping = function (cell, value)
{
    var mapping = this.cellMap.get(value) || [];
    if (!mapping.find(function (c) { return c.id == cell.id; }))
        mapping.push(cell);
    this.cellMap.set(value, mapping);
};

ViewModeHandler.prototype.setupHubs = function ()
{
    //------>fix<------//
    const template = {}
    template.setupHubConnection = function (){

    }
      //------>fix<------//
    if (template)
    {
        // tags
        if (!this.tagsHub)
        {
            template.setupHubConnection('tagsHub', mxUtils.bind(this, function (tagsHubProxy)
            {
                if (tagsHubProxy != null)
                {
                    tagsHubProxy.onHubConnectionSuccess = mxUtils.bind(this, this.onTagsHubConnect);

                    this.tagsHubHandler = mxUtils.bind(this, this.tagsChanged);
                    tagsHubProxy.on('updateData', this.tagsHubHandler);

                    this.tagsHub = tagsHubProxy;
                }
            }));
        }

        // scheme hub
        if (!this.schemeHub)
        {
            template.setupHubConnection('schemeHub', mxUtils.bind(this, function (schemeHubProxy)
            {
                if (schemeHubProxy != null)
                {
                    schemeHubProxy.initialization = true;
                    //schemeHubProxy.state.links = this.links;

                    schemeHubProxy.onHubConnectionSuccess = mxUtils.bind(this, this.onSchemeHubConnect);

                    this.schemeHubHandler = mxUtils.bind(this, this.schemeDataChanged);
                    this.posterEventHandler = mxUtils.bind(this, this.posterDataChanged);
                    this.dispatcherMarkEventHandler = mxUtils.bind(this, this.dispatcherMarkDataChanged);

                    schemeHubProxy.on('updateData', this.schemeHubHandler);
                    schemeHubProxy.on('posterEvent', this.posterEventHandler);
                    schemeHubProxy.on('dispatcherMarkEvent', this.dispatcherMarkEventHandler);

                    this.schemeHub = schemeHubProxy;
                }
            }));
        }
    }
};
ViewModeHandler.prototype.onTagsHubConnect = function ()
{
    if (this.tagsHub != null)
    {
        var self = this;

        const tagsFilter = {
            tags: this.names,
        };
        
        this.tagsHub.invoke('setup', tagsFilter)
            .then(function (data)
            {
                if (data)
                    self.tagsHubHandler(data, self.tagsHub.initialization);
            })
            .catch(function (err)
            {
                HELP.log('tagsHub.server.setup(): ' + err);
            })
            .finally(function ()
            {
                self.tagsHub.initialization = false;
            });
    }
};
ViewModeHandler.prototype.onSchemeHubConnect = function ()
{
    if (this.schemeHub != null)
    {
        var self = this;
        const payload = {
            filter: this.links,
            schemeId: this.ui.scheme.id,
        };
        this.schemeHub.invoke('setup', payload)
            .then(function (data)
            {
                if (data)
                    self.schemeHubHandler(data, self.schemeHub.initialization);
            })
            .catch(function (err)
            {
                HELP.log('schemeHub.server.setup(): ' + err);
            })
            .finally(function ()
            {
                self.schemeHub.initialization = false;
            });
    }
};

ViewModeHandler.prototype.tagsChanged = function (data, initial)
{
    if (data && data.length > 0)
    {
        this.model.beginUpdate();
        try
        {
            for (let i = 0; i < data.length; i++)
            {
                let item = data[i];
                if (item != null)
                {
                    // save equipment ID
                    item.id = item.n;
                    //HELP.log(item.n + ' => ' + API.FORMAT.getRawTimestamp(item.ts));
                    let targetCells = this.findMappedCells(item.id);
                    if (targetCells.length > 0)
                    {
                        for (let j = 0; j < targetCells.length; j++)
                            this.dataProcessor(targetCells[j], item, initial);
                    }
                }
            }
        }
        finally
        {
            this.model.endUpdate();
        }
    }
};
ViewModeHandler.prototype.schemeDataChanged = function (respData, initial)
{
    if (!respData)
        return;
    
    const data = Array.isArray(respData) ? respData : [respData];

    if (data && data.length > 0)
    {
        this.model.beginUpdate();
        try
        {
            for (let i = 0; i < data.length; i++)
            {
                var item = data[i];
                if (item != null)
                {
                    let eqItems = item.data;
                    if (eqItems && eqItems.length > 0)
                    {
                        for (let k = 0; k < eqItems.length; k++)
                        {
                            // save equipment ID
                            eqItems[k].eq = item.id;
                            //HELP.log(eqItems[k].n + ' => ' + API.FORMAT.getRawTimestamp(eqItems[k].ts));
                            let targetCells = this.findMappedCells(eqItems[k].id);
                            if (targetCells.length > 0)
                            {
                                for (let j = 0; j < targetCells.length; j++)
                                    this.dataProcessor(targetCells[j], eqItems[k], initial);
                            }
                        }
                    }
                }
            }
        }
        finally
        {
            this.model.endUpdate();
        }
    }
};
ViewModeHandler.prototype.posterDataChanged = function (eventType, poster)
{
    if (!poster) {
        return;
    }

    switch (eventType) {
        case 0: // created
            this.marksService.addPosters([poster]);
            break;
        case 1: // updated
            this.marksService.updatePoster(poster);
            break;
        case 2: // deleted
            this.marksService.removePoster(poster);
            break;
        default:
            return;
    }
};
ViewModeHandler.prototype.dispatcherMarkDataChanged = function (eventType, dispatcherMark)
{
    if (!dispatcherMark) {
        return;
    }

    switch (eventType) {
        case 0: // created
            this.marksService.addDispatcherMarks([dispatcherMark]);
            break;
        case 1: // updated
            this.marksService.updateDispatcherMark(dispatcherMark);
            break;
        case 2: // deleted
            this.marksService.removeDispatcherMark(dispatcherMark);
            break;
        default:
            return;
    }
};
ViewModeHandler.prototype.getSchemeCells = function ()
{
    if (this.graph == null)
        return [];
    var filter = mxUtils.bind(this, function (cell)
    {
        return !this.model.isLayer(cell) && !this.model.isRoot(cell);
    });
    return this.model.filterDescendants(filter);
};
ViewModeHandler.prototype.proceessDataItem = function (cell, item, initial)
{
    // изменение тега / equipment
    let bindID = item.id;
    if (bindID)
    {
        let bindings = cell.bindingMap[bindID] || [];
        if (bindings.length > 0)
        {
            for (let i = 0; i < bindings.length; i++)
            {
                bindings[i].initial = initial;
                cell.scriptor.exec(cell, bindings[i], item);
            }
        }
    }
};
ViewModeHandler.prototype.destroy = function ()
{
    this.tagsHub?.stop();
    this.schemeHub?.stop();
};

//Scripts.js

// import { $ } from 'jquery';
// import * as mxgraph from 'mxgraph';
// import { API } from './scada';
// import Chart from 'chart.js'
// import moment from 'moment';
// import { Howl } from 'howler';
// import Menus from './Menus';
// import BindingsHandler from './Bindings';
// import { CameraWindow } from './Dialogs';
// import { template } from './template';
// import { isNullOrEmpty, GUID, AJAX, parseNumber } from './client';
// import { VCLASS } from './Init';

// let { 
//     mxGraph, 
//     mxUtils, 
//     mxConstants,
//     mxImage,
//     mxEvent,
//     mxCellRenderer,
//     mxPopupMenu,
//     mxEventSource,
//     mxCellOverlay,

// } = mxgraph();
/**
 * Scripts support
 */
 //export default function ScriptHandler (editorUI) {

 function ScriptHandler (editorUI) {
    mxEventSource.call(this);
  
    this.ui = editorUI;
    this.editor = this.ui.editor;
    this.graph = this.editor.graph;
    this.view = this.ui.viewHandler;
    this.marksService = editorUI.marksService;
    this.scriptors = new Map();
    this.init();
    this.menus = editorUI.createMenus();
  };
  mxUtils.extend(ScriptHandler, mxEventSource);
  
  ScriptHandler.prototype.init = function () {
    var shapeBaseAPI = mxUtils.bind(this, function () {
      return new ShapeAPI(this.ui);
    });
    var linkBaseAPI = mxUtils.bind(this, function () {
      return new LinkScriptAPI(this.ui);
    });
    var switchBaseAPI = mxUtils.bind(this, function () {
      return new SwitchScriptAPI(this.ui);
    });
    var busBaseAPI = mxUtils.bind(this, function () {
      return new BusScriptAPI(this.ui);
    });
    var soundBaseAPI = mxUtils.bind(this, function () {
      return new SoundScriptAPI(this.ui);
    });
    var tableBaseAPI = mxUtils.bind(this, function () {
      return new TableScriptAPI(this.ui);
    });
    var buttonBaseAPI = mxUtils.bind(this, function () {
      return new ButtonScriptAPI(this.ui);
    });
    var chartBaseAPI = mxUtils.bind(this, function () {
      return new ChartScriptAPI(this.ui);
    });
    var rollSwitchBaseAPI = mxUtils.bind(this, function () {
      return new RollSwitchScriptAPI(this.ui);
    });
    var rollDisconnectorBaseAPI = mxUtils.bind(this, function () {
      return new RollDisconnectorScriptAPI(this.ui);
    });
    var disconnectorBaseAPI = mxUtils.bind(this, function () {
      return new DisconnectorScriptAPI(this.ui);
    });
    var separatorBaseAPI = mxUtils.bind(this, function () {
      return new SeparatorScriptAPI(this.ui);
    });
    var groundBaseAPI = mxUtils.bind(this, function () {
      return new GroundScriptAPI(this.ui);
    });
    var rollelementBaseAPI = mxUtils.bind(this, function () {
      return new RollElementScriptAPI(this.ui);
    });
    var actuatorBaseAPI = mxUtils.bind(this, function () {
      return new ActuatorScriptAPI(this.ui);
    });
    var simpleSwitchBaseAPI = mxUtils.bind(this, function () {
      return new SimpleSwitchScriptAPI(this.ui);
    });
    var bmrzBaseAPI = mxUtils.bind(this, function () {
      return new BMRZScriptAPI(this.ui);
    });
    var posterBaseAPI = mxUtils.bind(this, function () {
      return new PosterScriptAPI(this.ui);
    });
    var dispatcherMarkBaseAPI = mxUtils.bind(this, function () {
      return new DispatcherMarkScriptAPI(this.ui);
    });
  
    // simple shapes
    this.scriptors.set('label', shapeBaseAPI);
    this.scriptors.set('text', shapeBaseAPI);
    this.scriptors.set('rectangle', shapeBaseAPI);
    this.scriptors.set('ellipse', shapeBaseAPI);
    this.scriptors.set('triangle', shapeBaseAPI);
    this.scriptors.set('rhombus', shapeBaseAPI);
    this.scriptors.set('trapezoid', shapeBaseAPI);
    this.scriptors.set('parallelogram', shapeBaseAPI);
    this.scriptors.set('cylinder', shapeBaseAPI);
    this.scriptors.set('cube', shapeBaseAPI);
    this.scriptors.set('cloud', shapeBaseAPI);
    this.scriptors.set('actor', shapeBaseAPI);
    this.scriptors.set('singlearrow', shapeBaseAPI);
    this.scriptors.set('doublearrow', shapeBaseAPI);
    this.scriptors.set('image', shapeBaseAPI);
    this.scriptors.set('arc', shapeBaseAPI);
    this.scriptors.set('swimlane', shapeBaseAPI);
  
    this.scriptors.set('custom', shapeBaseAPI); // for hrefs
    this.scriptors.set('group', shapeBaseAPI); // for groups
  
    // custom shapes
    this.scriptors.set('button', buttonBaseAPI);
    this.scriptors.set('link', linkBaseAPI);
    this.scriptors.set('sound', soundBaseAPI);
    this.scriptors.set('table', tableBaseAPI);
    this.scriptors.set('chart', chartBaseAPI);
  
    // @if WEBSCADA
    this.scriptors.set('bus', busBaseAPI);
    this.scriptors.set('switch', switchBaseAPI);
    this.scriptors.set('separator', separatorBaseAPI);
    this.scriptors.set('rollswitch', rollSwitchBaseAPI);
    this.scriptors.set('rolldisconnector', rollDisconnectorBaseAPI);
    this.scriptors.set('disconnector', disconnectorBaseAPI);
    this.scriptors.set('ground', groundBaseAPI);
    this.scriptors.set('contactor', groundBaseAPI);
    this.scriptors.set('rollelement', rollelementBaseAPI);
    this.scriptors.set('actuator', actuatorBaseAPI);
    this.scriptors.set('simpleswitch', simpleSwitchBaseAPI);
    this.scriptors.set('poster', posterBaseAPI);
    this.scriptors.set('dispatcher_mark', dispatcherMarkBaseAPI);
    // @endif
  
    // @if LINKMT
    this.scriptors.set('bmrz', bmrzBaseAPI);
    // @endif
  
    //----> longTouch conextMenu
    const editor = this.ui.editor;
    const graph = editor.graph;
    let contextMenu = null;
  
    graph.addListener(
      mxEvent.TAP_AND_HOLD,
      function (sender, evt) {
        const cell = evt.getProperty('cell');
  
        //pick up active point
        graph.setSelectionCell(cell);
        if (!cell) {
          graph.clearSelection();
        }
        if (cell) {
          //create context menu
          contextMenu = new mxPopupMenu(document.createElement('div'));
          contextMenu.div.className = 'mxPopupMenu';
          this.menus.createPopupMenu(contextMenu, cell, evt);
  
          //-------> fix bug with extra divs. case: touch by touch
          const divs = document.querySelectorAll('.mxPopupMenu');
          let num = divs.length;
          for (let i = 0; i < divs.length; i++) {
            num -= 1;
            if (num == 0) {
              break;
            } else {
              divs[i].remove();
            }
          }
          //<------- fix bug with extra divs. case: touch by touch
  
          //add position for context menu touch by touch
          const x = evt.getProperty('event').clientX;
          const y = evt.getProperty('event').clientY;
          contextMenu.div.style.left = `${x}px`;
          contextMenu.div.style.top = `${y}px`;
          contextMenu.showMenu();
        }
      }.bind(this)
    );
  
    //-------> fix bug with empty tbody
    graph.addListener(mxEvent.TAP_AND_HOLD, function (sender, evt) {
      const div = document.querySelector('div.mxPopupMenu');
      const tbody = document.querySelector('div.mxPopupMenu tbody');
      if (tbody && tbody.innerHTML.trim() === '') {
        div.remove();
      }
    });
    //<------- fix bug with empty tbody
  
    document.addEventListener('click', function (event) {
      const menuContainer = document.querySelector('.mxPopupMenu');
      if (menuContainer) {
        contextMenu.hideMenu();
      }
    });
    //-------> fix bug with extra divs. case: touch switch mouse
    graph.addListener(mxEvent.CLICK, function (sender, evt) {
      const cell = evt.getProperty('cell');
      const menuContainer = document.querySelectorAll('div.mxPopupMenu');
  
      if (menuContainer && menuContainer.length > 1) {
        const divs = document.querySelectorAll('div.mxPopupMenu');
        divs[0].remove();
      }
      if (contextMenu && !cell) {
        contextMenu.hideMenu();
      }
    });
    //<------- fix bug with extra divs. case: touch switch mouse
  
    //<---- longTouch conextMenu
  
    // @if WEBSCADA
    var menusCreatePopupMenu = Menus.prototype.createPopupMenu;
    Menus.prototype.createPopupMenu = function (menu, cell, evt) {
      menusCreatePopupMenu.apply(this, arguments);
  
      const isLeftClick = mxEvent.isLeftMouseButton(evt);
      const isMiddleClick = mxEvent.isMiddleMouseButton(evt);
      if (!cell || isLeftClick || isMiddleClick) {
        return;
      }
  
      const editor = this.editorUi.editor;
      const graph = editor.graph;
      const marksService = this.editorUi.marksService;
      if (cell.manual || cell.blocked || cell.service || !API.USER.hasPermission('scheme.exec_cmd')) {
        return;
      }
  
      let target = cell.commands != null ? cell : cell.getParent();
      let commands = target != null ? target.commands : null;
      if (commands != null && commands.length > 0) {
        for (let i = 0; i < commands.length; i++) {
          let cmd = commands[i];
          menu.addItem(
            cmd.d,
            null,
            mxUtils.bind(cmd, function () {
              if (target.scriptor != null) target.scriptor.execCommand(target, this);
            }),
            null,
            null,
            true
          );
        }
      }
      // Poster actions
      if (cell.scriptor && cell.scriptor instanceof PosterScriptAPI && marksService.isEnabled()) {
        menu.addItem('Редактировать', null, () => {
          API.POSTERS.openPosterEditor(graph, cell, false);
        });
        menu.addItem('Удалить', null, () => {
          try {
            graph.model.beginUpdate();
            graph.removeCells([cell]);
          } finally {
            graph.model.endUpdate();
          }
        });
      }
      // Dispatcher mark actions
      if (cell.scriptor && cell.scriptor instanceof DispatcherMarkScriptAPI && marksService.isEnabled()) {
        menu.addItem('Редактировать', null, () => {
          API.DISPATCHER_MARKS.openMarkEditor(graph, cell, false);
        });
        menu.addItem('Удалить', null, () => {
          try {
            graph.model.beginUpdate();
            graph.removeCells([cell]);
          } finally {
            graph.model.endUpdate();
          }
        });
      }
    };
    // @endif
  
    this.graph.addListener(mxEvent.CLICK, (sender, evt) => {
      if (this.marksService.isEnabled()) return;
  
      const isRightClick = mxEvent.isRightMouseButton(evt.getProperty('event'));
      const cell = evt.getProperty('cell'); // cell may be null
  
      const onCellLeftClick = () => {
        const styles = cell.style.split(';');
  
        if (styles.includes('poster')) {
          /* cell is poster */
          API.POSTERS.openPosterViewer(cell._model, this.graph, cell);
          evt.consume();
        } else if (styles.includes('dispatcher_mark')) {
          /* cell is dispatcher mark */
          API.DISPATCHER_MARKS.openMarkViewer(cell._model, this.graph, cell);
          evt.consume();
        } else {
          /* generic cell - check and execute binded action */
          const target = cell.action != null ? cell : cell.getParent();
          if (target != null && target.action != null) {
            if (target.scriptor != null) {
              target.scriptor.execAction(cell);
            }
            evt.consume();
          }
        }
      };
  
      if (cell && !isRightClick) {
        /* left click on cell */
        onCellLeftClick();
        // } else if (!cell && !isRightClick) {
        //     /* left click on emty space */
        // } else if (!cell && isRightClick) {
        //     /* right click on emty space */
      }
  
      // if (cell != null && (cell.commands == null || cell.commands.length == 0))
      // {
      //     let target = (cell.action != null ? cell : cell.getParent());
      //     if (target != null && target.action != null)
      //     {
      //         if (target.scriptor != null)
      //             target.scriptor.execAction(cell);
      //         evt.consume();
      //     }
      // }
    });
  
    let graphConvertValueToString = this.graph.convertValueToString;
    this.graph.convertValueToString = function (cell) {
      if (this.model.isVertex(cell)) {
        let state = this.view.getState(cell);
        if (state != null) {
          switch (state.style[mxConstants.STYLE_SHAPE]) {
            case 'chart': {
              // remove image
              if (state.shape.image != null) {
                delete state.shape.image;
                this.cellRenderer.doRedrawShape(state);
              }
              return cell.canvas;
            }
          }
        }
      }
      return graphConvertValueToString.apply(this, arguments);
    };
  };
  
  ScriptHandler.prototype.register = function (name, script) {
    if (isNullOrEmpty(name) || isNullOrEmpty(script)) return;
    var scriptor = this.scriptors.get(name);
    if (scriptor == null) {
      let evalResult = mxUtils.eval(script);
      if (evalResult != null && typeof evalResult == 'function')
        this.scriptors.set(
          name.toLowerCase(),
          mxUtils.bind(this, function () {
            return new evalResult(this.ui);
          })
        );
    }
  };
  ScriptHandler.prototype.setup = function (cell) {
   
    if (cell == null || !mxUtils.isNode(cell.value)) return null;
    if (!cell.scriptor) {
      let name = cell.value.nodeName.toLowerCase();
      if (isNullOrEmpty(name)) return null;
  
      // check binding
    
      let scriptBinding = cell.getBinding('script');
      if (scriptBinding != null) {
        let scriptName = $(scriptBinding).attr('value');
        if (!isNullOrEmpty(scriptName)) name = scriptName.toLowerCase();
      }
  
      let factory = this.scriptors.get(name) || this.scriptors.get('custom');
      if (factory == null || typeof factory != 'function') return null;
  
      cell.scriptor = new factory();
    }
    return cell.scriptor;
  };
  ScriptHandler.prototype.destroy = function () {};
  
  function ShapeAPI(editorUI) {
    mxEventSource.call(this);
    this.ui = editorUI;
    this.editor = this.ui.editor;
    this.graph = this.editor.graph;
    this.init();
  }
  mxUtils.extend(ShapeAPI, mxEventSource);
  
  ShapeAPI.prototype.init = function () {};
  ShapeAPI.prototype.setup = function (cell) {
    // hide tooltip
    cell.getTooltip = function () {};
    // set cursor
    if (cell.bindings != null && cell.bindings.length > 0) {
      let cellState = this.graph.view.getState(cell);
      if (cellState == null) return;
  
      if (cell.commands == null) {
        let commandsBinding = cell.getBinding('commands');
        if (commandsBinding != null && !isNullOrEmpty(commandsBinding.value)) cell.commands = JSON.parse(commandsBinding.value);
      }
      if (cell.action == null) {
        let actionBinding = cell.getBinding('action');
        if (actionBinding != null && !isNullOrEmpty(actionBinding.value)) {
          cell.action = JSON.parse(actionBinding.value);
          let argsBinding = cell.getBinding('action.args');
          cell.action_args = argsBinding != null ? JSON.parse(argsBinding.value) : null;
        }
      }
  
      if ((cell.commands != null && cell.commands.length > 0) || cell.action != null) cellState.setCursor(mxConstants.CURSOR_CONNECT);
    }
  };
  ShapeAPI.prototype.visit = function (cell, map, resolver) {
    this.setup(cell);
    if (cell.bindings != null && cell.bindings.length > 0) {
      for (var i = 0; i < cell.bindings.length; i++) {
        var item = cell.bindings[i];
        if (item != null && !isNullOrEmpty(item.value)) {
          let bind = JSON.parse(item.value);
          if (bind == null) continue;
  
          // common bindings
          switch (item.name) {
            case 'state':
            case 'link':
            case 'visibility':
            case 'label':
            case 'command':
            case 'blink':
            case 'rotation':
            case 'turn':
            case 'shift':
            case 'move':
            case 'play':
            case 'color.fill.$1': // colors
            case 'color.fill.$2':
            case 'color.fill.$3':
            case 'color.fill.$4':
            case 'color.fill.$5':
            case 'color.brd.$1':
            case 'color.brd.$2':
            case 'color.brd.$3':
            case 'color.brd.$4':
            case 'color.brd.$5':
            case 'color.font.$1':
            case 'color.font.$2':
            case 'color.font.$3':
            case 'color.font.$4':
            case 'color.font.$5':
            case 'action.trigger':
              {
                if (GUID.isValid(bind.id)) map.eq.push(bind);
                else map.tag.push(bind);
              }
              break;
            default:
              {
                // custom resolve
                if (resolver != null && resolver(item)) break;
                // process as static
                this.exec(cell, item);
              }
              break;
          }
        }
      }
    }
  };
  ShapeAPI.prototype.checkValue = function (value) {
    return value != null && value.q >= API.ENUMS.QualityValue.Good;
  };
  ShapeAPI.prototype.processValue = function (cell, value) {
    let result = {
      src: value,
      get bad() {
        return !shapeCheckValue(this.src);
      },
    };
  
    if (result.src != null) {
      result.isbool = result.src.vtype == API.ENUMS.TagValueType.Boolean;
      // eq state
      if (result.src.eq && result.src.eq == result.src.id) {
        result.state = {
          values: result.src.v.split('|'),
          has: function (val) {
            return this.values.indexOf(val) >= 0;
          },
          get service() {
            return this.has('SERVICE');
          },
          get blocked() {
            return this.has('BLOCK');
          },
          get manual() {
            return this.has('MANUAL');
          },
        };
        result.value = this.resolveState(result);
      } else result.value = this.resolveValue(result);
    }
  
    // check blocked & manual & service states
    if (result.state != null) {
      cell.manual = null;
      cell.blocked = null;
      this.graph.removeCellOverlays(cell);
  
      cell.service = result.state.service;
  
      if (result.state.blocked) {
        cell.blocked = true;
        this.graph.addCellOverlay(cell, new mxCellOverlay(new mxImage(mxConstants.BLOCKED_IMAGE, 16, 16), 'Оперативная блокировка', null, mxConstants.ALIGN_TOP));
      }
      if (result.state.manual) {
        cell.manual = true;
        this.graph.addCellOverlay(cell, new mxCellOverlay(new mxImage(mxConstants.MANUAL_IMAGE, 16, 16), 'Ручное управление', null, mxConstants.ALIGN_BOTTOM));
      }
    }
  
    return result;
  };
  ShapeAPI.prototype.resolveState = function (result) {
    let defaultState = 'UNKNOWN';
    if (result == null || result.bad) return defaultState;
    else return result.state.service ? 'SERVICE' : result.state.values.length > 0 ? result.state.values[0] : defaultState;
  };
  ShapeAPI.prototype.resolveValue = function (result) {
      if (result == null || result.src == null) return null;
    return API.FORMAT.getValue(result.src);
  };
  ShapeAPI.prototype.stateToBit = function (state) {
    if (isNullOrEmpty(state)) return false;
    return ['ON', 'ROLL_IN', 'ROLL_IN_SWITCH_ON', 'OPEN'].indexOf(state) >= 0;
  };
  ShapeAPI.prototype.exec = function (cell, binding, item) {
    if (cell == null || binding == null) return;
  
    let actionName = binding.name;
    if (isNullOrEmpty(actionName)) return;
  
    let actionPath = actionName.split('.');
    if (actionPath.length > 1) actionName = actionPath[0];
  
    let targetAction = this[actionName];
    if (targetAction == null) return;
  
    return targetAction.apply(this, [cell, binding, item]);
  };
  ShapeAPI.prototype.action = function (cell, binding, value) {
    if (cell == null || binding == null || value == null) return;
  
    if (binding.initial) return;
  
    let actionPath = binding.name.split('.');
    if (actionPath.length == 0 || actionPath[0] != 'action') return;
  
    switch (actionPath[1]) {
      case 'trigger':
        {
          let result = this.processValue(cell, value);
          let on = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
          if (on) this.execAction(cell);
        }
        break;
      default:
        break;
    }
  };
  ShapeAPI.prototype.execCommand = function (cell, cmd) {
    if (cell == null || cmd == null) return;
  
    if (cell.manual || cell.blocked || cell.service || !API.USER.hasPermission('scheme.exec_cmd')) {
      console.log('Управление запрещено')
      //messageError('Управление запрещено');
      return;
    }
  
    let postCommand = function (cmd) {
      // subscribe to execution result
      if (template != null && template.execHubProxy != null) template.execHubProxy.invoke('subscribe', cmd);
  
      // exec command
      AJAX.post(
        API.FUNC.schemeExecCmd,
        null,
        { id: cmd.id, parent: cmd.parent },
        function (xhr, resp) {
          if (resp === true) 
          //messageDebug(translate('common.messages.command_sent_to_server'));
          console.log('common.messages.command_sent_to_server')
          //else messageError(translate('common.errors.command_execution'));
          else console.log('common.errors.command_execution');
        },
        function (xhr, err) {
          console.log('common.errors.command_execution')
          //messageError(translate('common.errors.command_execution'));
        }
      );
    };
  
    if (cmd.confirm != false) {
      console.log('common.execute_command' + " '" + (isNullOrEmpty(cmd.d) ? cmd.val : cmd.d) + "'", function (result) {
        if (result === true) postCommand(cmd);
      })
      // messageConfirm(translate('common.execute_command') + " '" + (isNullOrEmpty(cmd.d) ? cmd.val : cmd.d) + "'", function (result) {
      //   if (result === true) postCommand(cmd);
      // });
    } else postCommand(cmd);
  };
  ShapeAPI.prototype.execAction = function (cell) {
    if (cell == null || cell.action == null || cell.action_args == null) return;
  
    let cellState = this.graph.view.getState(cell);
    if (cellState == null) return null;
  
    switch (cell.action) {
      case 'exec':
        {
          cell.action_args.confirm = false;
          this.execCommand(cell, cell.action_args);
        }
        break;
      case 'open':
        {
          this.graph.openLink(cell.action_args.text, '_blank');
        }
        break;
      case 'goto':
        {
          this.graph.openLink(cell.action_args.text, '_self');
        }
        break;
      case 'camera':
        {
          let cam = new CameraWindow(this.ui, cell.action_args.text);
          if (cam != null) {
            if (cam.isVisible()) cam.show();
            else cam.show(cellState.shape.node, { x: 10, y: 10 });
          }
        }
        break;
      case 'eq':
        {
          window.open(`/equipments/view?id=${cell.action_args.id}&mode=subwindow`, '_blank', 'location=yes,height=600,width=800,scrollbars=yes,status=yes');
        }
        break;
      default:
        break;
    }
  };
  
  ShapeAPI.prototype.vclass = function (cell, binding) {
    if (cell == null || binding == null) return;
    // get vclass
    if (binding.name == 'vclass' && !isNullOrEmpty(binding.value)) cell.vclass = JSON.parse(binding.value);
    // apply vclass
    if (!VCLASS.isDefaultValue(cell.vclass)) {
      let targetColor = VCLASS.getColor(cell.vclass);
      // apply color
      this.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, targetColor, [cell]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, targetColor, [cell]);
    }
  };
  ShapeAPI.prototype.visibility = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
    let visible = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    this.graph.cellsToggled([cell], visible || false);
  
    //let originOpacity     = cell.origin.style.opacity     || 100;
    //let originTextOpacity = cell.origin.style.textOpacity || 100;
  
    //// remove opacity
    //this.graph.setCellStyles(mxConstants.STYLE_OPACITY, originOpacity, [cell]);
    //this.graph.setCellStyles(mxConstants.STYLE_TEXT_OPACITY, originTextOpacity, [cell]);
  
    //let cellState = this.graph.view.getState(cell);
    //if (cellState != null)
    //{
    //    let opacity     = visible ? (cell.origin.style.opacity     || 100) : 0;
    //    let textopacity = visible ? (cell.origin.style.textOpacity || 100) : 0;
    //    this.graph.setCellStyles(mxConstants.STYLE_OPACITY, opacity, [cell]);
    //    this.graph.setCellStyles(mxConstants.STYLE_TEXT_OPACITY, textopacity, [cell]);
    //}
  };
  ShapeAPI.prototype.blink = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
    let blinking = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    if (cell.blinkingID) {
      window.clearInterval(cell.blinkingID);
      delete cell.blinkingID;
    }
  
    //let originOpacity     = cell.origin.style.opacity     || 100;
    //let originTextOpacity = cell.origin.style.textOpacity || 100;
  
    // reset visibility
    this.graph.cellsToggled([cell], true);
    //this.graph.setCellStyles(mxConstants.STYLE_OPACITY, originOpacity, [cell]);
    //this.graph.setCellStyles(mxConstants.STYLE_TEXT_OPACITY, originTextOpacity, [cell]);
  
    // run
    if (blinking) {
      if (cell.blinkSpeed == null) {
        cell.blinkSpeed = 500;
        let speedBinding = cell.getBinding('blink.speed');
        if (speedBinding != null) cell.blinkSpeed = parseInt(JSON.parse(speedBinding.value));
      }
  
      cell.blinkingID = window.setInterval(
        mxUtils.bind(this, function (cell) {
          //this.graph.toggleCells(!cell.isVisible(), [cell], false);
          this.graph.cellsToggled([cell], !cell.isVisible());
          //let style   = this.graph.getCellStyle(cell);
          //let opValue = style.opacity == 100 ? 0 : 100;
          //this.graph.setCellStyles(mxConstants.STYLE_TEXT_OPACITY, opValue, [cell]);
          //this.graph.setCellStyles(mxConstants.STYLE_OPACITY, opValue, [cell]);
        }),
        cell.blinkSpeed,
        cell
      );
    }
  };
  ShapeAPI.prototype.label = function (cell, binding, value) {
    if (cell == null || value == null) return;
    let result = this.processValue(cell, value);
    this.graph.setAttributeForCell(cell, 'label', result.value);
  };
  ShapeAPI.prototype.state = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
    let stateON = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    let targetColor = cell.origin.style.fillColor || 'none';
  
    // если задан класс напряжения
    if (!VCLASS.isDefaultValue(cell.vclass)) {
      if (stateON) targetColor = VCLASS.getColor(cell.vclass);
    }
  
    // проверяем динамические цвета заливки
    if (cell.fill_colors && Object.keys(cell.fill_colors).length > 0) {
      let firstIndex = Object.keys(cell.fill_colors).sort()[0];
      targetColor = cell.fill_colors[firstIndex];
    }
  
    // apply color
    this.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, targetColor, [cell]);
  };
  ShapeAPI.prototype.rotation = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
    let rotate = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    if (cell.rotationID) {
      window.clearInterval(cell.rotationID);
      delete cell.rotationID;
    }
  
    // reset rotation
    this.graph.setCellStyles(mxConstants.STYLE_ROTATION, cell.origin.style.rotation || 0, [cell]);
  
    // run
    if (rotate) {
      if (cell.rotationSpeed == null) {
        cell.rotationSpeed = 100;
        let speedBinding = cell.getBinding('rotation.speed');
        if (speedBinding != null) cell.rotationSpeed = parseInt(JSON.parse(speedBinding.value));
      }
  
      cell.rotationID = window.setInterval(
        mxUtils.bind(this, function (cell) {
          let style = this.graph.getCellStyle(cell);
          let rValue = (style.rotation || 0) + 10; // 10 град.
          this.graph.setCellStyles(mxConstants.STYLE_ROTATION, rValue, [cell]);
        }),
        cell.rotationSpeed,
        cell
      );
    }
  };
  ShapeAPI.prototype.turn = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
    let turning = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    // reset rotation
    this.graph.setCellStyles(mxConstants.STYLE_ROTATION, cell.origin.style.rotation || 0, [cell]);
  
    // run
    if (turning) {
      if (cell.turnAngle == null) {
        cell.turnAngle = 90;
        let angleBinding = cell.getBinding('turn.angle');
        if (angleBinding != null) cell.turnAngle = parseInt(JSON.parse(angleBinding.value));
      }
      // apply
      this.graph.setCellStyles(mxConstants.STYLE_ROTATION, cell.turnAngle, [cell]);
    }
  };
  ShapeAPI.prototype.shift = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
    let shifting = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    let geo = this.graph.getCellGeometry(cell).clone();
  
    // reset cell position
    geo.x = cell.origin.geometry.x;
    geo.y = cell.origin.geometry.y;
    this.graph.getModel().setGeometry(cell, geo);
  
    // run
    if (shifting) {
      if (cell.dx == null) {
        let dxBinding = cell.getBinding('shift.dx');
        cell.dx = dxBinding != null ? parseInt(JSON.parse(dxBinding.value)) : 0;
      }
      if (cell.dy == null) {
        let dyBinding = cell.getBinding('shift.dy');
        cell.dy = dyBinding != null ? parseInt(JSON.parse(dyBinding.value)) : 0;
      }
      // apply
      geo.x += cell.dx;
      geo.y += cell.dy;
      this.graph.getModel().setGeometry(cell, geo);
    }
  };
  ShapeAPI.prototype.move = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
    let moving = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    let geo = this.graph.getCellGeometry(cell).clone();
  
    // reset cell position
    geo.x = cell.origin.geometry.x;
    geo.y = cell.origin.geometry.y;
    this.graph.getModel().setGeometry(cell, geo);
  
    // run
    if (moving) {
      if (cell.x == null) {
        let xBinding = cell.getBinding('move.x');
        cell.x = xBinding != null ? parseInt(JSON.parse(xBinding.value)) : geo.x;
      }
      if (cell.y == null) {
        let yBinding = cell.getBinding('move.y');
        cell.y = yBinding != null ? parseInt(JSON.parse(yBinding.value)) : geo.y;
      }
      // apply
      geo.x = cell.x;
      geo.y = cell.y;
      this.graph.getModel().setGeometry(cell, geo);
    }
  };
  
  ShapeAPI.prototype.color = function (cell, binding, value) {
    if (cell == null || binding == null || value == null) return null;
  
    let actionName = binding.name.split('.');
    if (actionName.length == 0 || actionName[0] != 'color') return null;
  
    let color = null;
    switch (actionName[1]) {
      case 'fill':
        color = this.color_fill(cell, binding, value);
        break;
      case 'brd':
        color = this.color_border(cell, binding, value);
        break;
      case 'font':
        color = this.color_font(cell, binding, value);
        break;
    }
  
    return color;
  };
  ShapeAPI.prototype.color_fill = function (cell, binding, value) {
    if (cell == null || binding == null || value == null) return null;
  
    // check vclass
    if (!VCLASS.isDefaultValue(cell.vclass)) return null;
  
    let result = this.processValue(cell, value);
    let coloring = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    let color = null;
  
    // for dynamic colors
    if (cell.fill_colors == null) cell.fill_colors = {};
  
    let actionName = binding.name;
    let match = actionName.split('.')[2].match(/\d+$/);
    let index = match != null && match.length > 0 ? match[0] : 0;
  
    let colorValueBinding = cell.getBinding(actionName + '.val');
    if (index == 0 || colorValueBinding == null) delete cell.fill_colors[index];
    else {
      color = JSON.parse(colorValueBinding.value);
      // get value
      if (coloring) cell.fill_colors[index] = color;
      else {
        // bad quality
        if (result.bad) cell.fill_colors[index] = VCLASS.UNRELIABLE_INFO;
        else delete cell.fill_colors[index];
      }
    }
  
    // get first color or reset
    if (Object.keys(cell.fill_colors).length > 0) {
      let firstIndex = Object.keys(cell.fill_colors).sort()[0];
      color = cell.fill_colors[firstIndex];
    } else {
      // for reset
      color = null;
    }
  
    // apply
    cell.color_fill = color || cell.origin.style.fillColor || 'none';
    this.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, cell.color_fill, [cell]);
  
    return cell.color_fill;
  };
  ShapeAPI.prototype.color_border = function (cell, binding, value) {
    if (cell == null || binding == null || value == null) return null;
  
    if (!VCLASS.isDefaultValue(cell.vclass)) return null;
  
    let result = this.processValue(cell, value);
    let coloring = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    let color = null;
  
    // for dynamic colors
    if (cell.brd_colors == null) cell.brd_colors = {};
  
    let actionName = binding.name;
    let match = actionName.split('.')[2].match(/\d+$/);
    let index = match != null && match.length > 0 ? match[0] : 0;
  
    let colorValueBinding = cell.getBinding(actionName + '.val');
    if (index == 0 || colorValueBinding == null) delete cell.brd_colors[index];
    else {
      color = JSON.parse(colorValueBinding.value);
      // check value
      if (coloring) cell.brd_colors[index] = color;
      else delete cell.brd_colors[index];
    }
  
    // get first color or reset
    if (Object.keys(cell.brd_colors).length > 0) {
      let firstIndex = Object.keys(cell.brd_colors).sort()[0];
      color = cell.brd_colors[firstIndex];
    } else {
      // for reset
      color = null;
    }
  
    // apply
    if (color != null) {
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, color, [cell]);
    } else {
      // reset to defaults
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, cell.origin.style.strokeColor || 'none', [cell]);
    }
  
    return color;
  };
  ShapeAPI.prototype.color_font = function (cell, binding, value) {
    if (cell == null || binding == null || value == null) return null;
  
    let result = this.processValue(cell, value);
    let coloring = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    let color = null;
  
    // for dynamic colors
    if (cell.font_colors == null) cell.font_colors = {};
  
    let actionName = binding.name;
    let match = actionName.split('.')[2].match(/\d+$/);
    let index = match != null && match.length > 0 ? match[0] : 0;
  
    let colorValueBinding = cell.getBinding(actionName + '.val');
    if (index == 0 || colorValueBinding == null) delete cell.font_colors[index];
    else {
      color = JSON.parse(colorValueBinding.value);
      // check value
      if (coloring) cell.font_colors[index] = color;
      else delete cell.font_colors[index];
    }
  
    // get first color or reset
    if (Object.keys(cell.font_colors).length > 0) {
      let firstIndex = Object.keys(cell.font_colors).sort()[0];
      color = cell.font_colors[firstIndex];
    } else {
      // for reset
      color = null;
    }
  
    // apply
    if (color != null) {
      this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, color, [cell]);
    } else {
      // reset to defaults
      this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, cell.origin.style.fontColor || 'none', [cell]);
    }
  
    return color;
  };
  
  // save base implementation
  var shapeInit = ShapeAPI.prototype.init;
  var shapeSetup = ShapeAPI.prototype.setup;
  var shapeVisit = ShapeAPI.prototype.visit;
  var shapeCheckValue = ShapeAPI.prototype.checkValue;
  var shapeProcessValue = ShapeAPI.prototype.processValue;
  var shapeResolveState = ShapeAPI.prototype.resolveState;
  var shapeResolveValue = ShapeAPI.prototype.resolveValue;
  var shapeStateToBit = ShapeAPI.prototype.stateToBit;
  var shapeExec = ShapeAPI.prototype.exec;
  
  var shapeVisibility = ShapeAPI.prototype.visibility;
  var shapeBlink = ShapeAPI.prototype.blink;
  var shapeLabel = ShapeAPI.prototype.label;
  var shapeState = ShapeAPI.prototype.state;
  var shapeRotation = ShapeAPI.prototype.rotation;
  var shapeTurn = ShapeAPI.prototype.turn;
  var shapeShift = ShapeAPI.prototype.shift;
  var shapeMove = ShapeAPI.prototype.move;
  var shapeColor = ShapeAPI.prototype.color;
  var shapeColorFill = ShapeAPI.prototype.color_fill;
  var shapeColorBorder = ShapeAPI.prototype.color_border;
  var shapeColorFont = ShapeAPI.prototype.color_font;
  
  function LinkScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(LinkScriptAPI, ShapeAPI);
  LinkScriptAPI.prototype.state = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
  
    let current = result.bad ? 'UNKNOWN' : result.value;
    if (result.state == null && current != 'UNKNOWN') current = result.value != null && result.value ? 'ON' : 'OFF';
  
    let borderColor = cell.origin.style.strokeColor || 'none';
  
    // если задан класс напряжения
    switch (current) {
      case 'ON':
        borderColor = !VCLASS.isDefaultValue(cell.vclass) ? VCLASS.getColor(cell.vclass) : borderColor;
        break;
      case 'OFF':
        borderColor = VCLASS.UOFF;
        break;
      case 'SERVICE':
        borderColor = VCLASS.SERVICE;
        break;
      default:
        borderColor = VCLASS.UNRELIABLE_INFO;
        break;
    }
  
    // apply color
    this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  };
  
  function BusScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(BusScriptAPI, ShapeAPI);
  BusScriptAPI.prototype.state = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
  
    let current = result.bad ? 'UNKNOWN' : result.value;
    if (result.state == null && current != 'UNKNOWN') current = result.value != null && result.value ? 'ON' : 'OFF';
  
    let fillColor = cell.origin.style.fillColor || 'none';
  
    switch (current) {
      case 'ON':
        fillColor = !VCLASS.isDefaultValue(cell.vclass) ? VCLASS.getColor(cell.vclass) : fillColor;
        break;
      case 'OFF':
        fillColor = VCLASS.UOFF;
        break;
      case 'SERVICE':
        fillColor = VCLASS.SERVICE;
        break;
      default:
        fillColor = VCLASS.UNRELIABLE_INFO;
        break;
    }
  
    // apply color
    this.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, fillColor, [cell]);
  };
  
  function SwitchScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(SwitchScriptAPI, ShapeAPI);
  SwitchScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
  
    let geo = this.graph.getCellGeometry(cell);
    if (cell.question == null) {
      cell.question = this.graph.insertVertex(cell, null, '?', 0, 0, geo.width, geo.height, 'text;align=center;verticalAlign=middle;pointerEvents=0;fontSize=' + (geo.height / 10) * 7, false);
      cell.question.getTooltip = function () {};
    }
    if (cell.damage == null) {
      cell.damage = this.graph.insertVertex(cell, null, '', -0.5, -0.5, geo.width * 2, geo.height * 2, 'line;strokeColor=#FF0000;strokeWidth=2;fillColor=none;pointerEvents=0;rotation=-45;', true);
      cell.damage.getTooltip = function () {};
    }
  };
  SwitchScriptAPI.prototype.position = function (cell, binding) {
    let pos = binding != null ? JSON.parse(binding.value) : mxCellRenderer.defaultShapes['switch'].prototype.position == true ? '1' : '0';
    let state = this.graph.view.getState(cell);
    if (state != null && state.shape != null) cell.position = state.shape.position = pos == '1';
  };
  SwitchScriptAPI.prototype.state = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
  
    let current = result.bad ? 'UNKNOWN' : result.value;
    if (result.state == null && current != 'UNKNOWN') current = result.value != null && result.value ? 'ON' : 'OFF';
  
    // hide question
    cell.question.setVisible(false);
    // hide damage
    cell.damage.setVisible(false);
  
    var cellState = this.graph.view.getState(cell);
    if (cellState != null && cellState.shape != null) {
      let shape = cellState.shape;
      // check position
      if (cell.position == null) cell.position = mxCellRenderer.defaultShapes['switch'].prototype.position;
      shape.position = cell.position;
  
      let fontColor = cell.origin.style.fontColor || 'none';
      let fillColor = cell.origin.style.fillColor || 'none';
      let borderColor = cell.origin.style.strokeColor || 'none';
  
      // reset colors
      this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, fontColor, [cell.question]);
      this.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, fillColor, [cell]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      // если задан класс напряжения
      if (!VCLASS.isDefaultValue(cell.vclass)) {
        let vclassColor = VCLASS.getColor(cell.vclass);
        switch (current) {
          case 'ON':
            shape.on = true;
            fillColor = vclassColor;
            break;
          case 'OFF':
            shape.on = false;
            fillColor = 'none';
            borderColor = vclassColor;
            break;
          case 'DAMAGE':
            fillColor = 'none';
            borderColor = vclassColor;
            cell.damage.setVisible(true);
            // update cell.damage
            let damageCellState = this.graph.view.getState(cell.damage);
            if (damageCellState != null) damageCellState.setCursor(mxConstants.CURSOR_CONNECT);
            break;
          case 'SERVICE':
            // hide position if exists
            shape.position = false;
            fillColor = 'none';
            borderColor = VCLASS.SERVICE;
            break;
          default:
            // hide position if exists
            shape.position = false;
            // apply colors
            fillColor = VCLASS.UNRELIABLE_INFO;
            borderColor = vclassColor;
            // show question mark
            cell.question.setVisible(true);
            this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, vclassColor, [cell.question]);
            // update cell.question
            let questionCellState = this.graph.view.getState(cell.question, true);
            if (questionCellState != null) questionCellState.setCursor(mxConstants.CURSOR_CONNECT);
            break;
        }
      } else {
        switch (current) {
          case 'ON':
            shape.on = true;
            break;
          case 'OFF':
            shape.on = false;
            break;
          case 'DAMAGE':
            shape.on = false;
            cell.damage.setVisible(true);
            // update cell.damage
            let damageCellState = this.graph.view.getState(cell.damage);
            if (damageCellState != null) damageCellState.setCursor(mxConstants.CURSOR_CONNECT);
            break;
          case 'SERVICE':
            // hide position if exists
            shape.position = false;
            fillColor = 'none';
            borderColor = VCLASS.SERVICE;
            break;
          default:
            // hide position if exists
            shape.position = false;
            // apply colors
            fillColor = VCLASS.UNRELIABLE_INFO;
            // show question mark
            cell.question.setVisible(true);
            // update cell.question
            let questionCellState = this.graph.view.getState(cell.question);
            if (questionCellState != null) questionCellState.setCursor(mxConstants.CURSOR_CONNECT);
            break;
        }
      }
  
      // apply colors
      this.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, fillColor, [cell]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      // update cell
      this.graph.cellRenderer.redrawShape(cellState, true);
    }
  };
  
  function SoundScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(SoundScriptAPI, ShapeAPI);
  SoundScriptAPI.prototype.setup = function (cell) {
    if (cell.audio == null) {
      let dataBinding = cell.getBinding('play.data');
      let data = dataBinding != null ? JSON.parse(dataBinding.value) : null;
      if (data != null) {
        let cycleBinding = cell.getBinding('play.cycle');
        let loop = (cycleBinding != null ? JSON.parse(cycleBinding.value) : '0') == '1';
        cell.audio = new Howl({
          src: [data],
          autoplay: false,
          preload: true,
          mute: false,
          loop: loop,
          volume: 1,
        });
      }
    }
  };
  SoundScriptAPI.prototype.playSound = function () {
    if (this.audio != null) this.audio.play();
  };
  SoundScriptAPI.prototype.stopSound = function () {
    if (this.audio != null) this.audio.stop();
  };
  SoundScriptAPI.prototype.play = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    if (binding.initial) return;
  
    let result = this.processValue(cell, value);
    let playing = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    if (playing) this.playSound.call(cell);
    else this.stopSound.call(cell);
  };
  
  function TableScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
    this.ui = editorUI;
  }
  mxUtils.extend(TableScriptAPI, ShapeAPI);
  TableScriptAPI.prototype.visit = function (cell, map) {
    let args = Array.prototype.slice.call(arguments);
    // add custom resolver
    args.push(function (item) {
      if (item != null && !isNullOrEmpty(item.value)) {
        let bind = JSON.parse(item.value);
        if (bind == null) return;
  
        switch (item.name) {
          case 'color.font.name':
          case 'color.font.name.bad':
          case 'color.fill.name':
          case 'color.fill.name.bad':
          case 'color.font.value':
          case 'color.font.value.bad':
          case 'color.fill.value':
          case 'color.fill.value.bad':
          case 'color.font.measure':
          case 'color.font.measure.bad':
          case 'color.fill.measure':
          case 'color.fill.measure.bad':
            {
              cell[item.name] = bind;
            }
            break;
  
          case 'color.font.name.$1':
          case 'color.font.name.$2':
          case 'color.font.name.$3':
          case 'color.fill.name.$1':
          case 'color.fill.name.$2':
          case 'color.fill.name.$3':
          case 'color.font.value.$1':
          case 'color.font.value.$2':
          case 'color.font.value.$3':
          case 'color.fill.value.$1':
          case 'color.fill.value.$2':
          case 'color.fill.value.$3':
          case 'color.font.measure.$1':
          case 'color.font.measure.$2':
          case 'color.font.measure.$3':
          case 'color.fill.measure.$1':
          case 'color.fill.measure.$2':
          case 'color.fill.measure.$3':
            {
              if (GUID.isValid(bind.id)) map.eq.push(bind);
              else map.tag.push(bind);
            }
            break;
        }
      }
    });
  
    shapeVisit.apply(this, args);
  
    let itemsBinding = cell.getBinding('items');
    if (itemsBinding != null && !isNullOrEmpty(itemsBinding.value)) {
      let bind = JSON.parse(itemsBinding.value);
      if (bind != null && bind.length > 0) {
        for (let j = 0; j < bind.length; j++) {
          let id = bind[j].id;
          if (GUID.isValid(id)) map.eq.push(bind[j]);
          else map.tag.push(bind[j]);
        }
      }
    }
  };
  TableScriptAPI.prototype.setup = function (cell) {
    // find tables
    if (cell.tables == null) {
      cell.tables = $('table.tbl' + cell.id);
      cell.container = cell.children[0];
    }
  };
  TableScriptAPI.prototype.color = function (cell, binding, value) {
    if (cell == null || binding == null || value == null) return null;
  
    let actionName = binding.name.split('.');
    if (actionName.length < 2 || actionName[0] != 'color') return null;
  
    let color = null;
    switch (actionName[1]) {
      case 'font':
        color = this.color_font(cell, binding, value, actionName[2]);
        break;
      case 'fill':
        color = this.color_fill(cell, binding, value, actionName[2]);
        break;
    }
  
    return color;
  };
  TableScriptAPI.prototype.color_font = function (cell, binding, value, target) {
    if (cell == null || binding == null || value == null || isNullOrEmpty(target)) return null;
  
    let result = this.processValue(cell, value);
    let coloring = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    let color = null;
    let key = 'font_colors_' + target;
  
    // for dynamic colors
    cell[key] = cell[key] || {};
  
    let actionName = binding.name;
    let match = actionName.split('.')[3].match(/\d+$/);
    let index = match != null && match.length > 0 ? match[0] : 0;
  
    let colorValueBinding = cell.getBinding(actionName + '.val');
    if (index == 0 || colorValueBinding == null || !coloring) delete cell[key][index];
    else {
      color = JSON.parse(colorValueBinding.value);
      // set value
      if (coloring) cell[key][index] = color;
    }
  
    // get first color or reset
    if (Object.keys(cell[key]).length > 0) {
      let firstIndex = Object.keys(cell[key]).sort()[0];
      color = cell[key][firstIndex];
    } else {
      // for reset
      color = null;
    }
  
    // apply
    cell['current.color.font.' + target] = color;
  
    return color;
  };
  TableScriptAPI.prototype.color_fill = function (cell, binding, value, target) {
    if (cell == null || binding == null || value == null || isNullOrEmpty(target)) return null;
  
    let result = this.processValue(cell, value);
    let coloring = !result.bad && (result.state ? this.stateToBit(result.value) : result.value);
  
    let color = null;
    let key = 'fill_colors_' + target;
  
    // for dynamic colors
    cell[key] = cell[key] || {};
  
    let actionName = binding.name;
    let match = actionName.split('.')[3].match(/\d+$/);
    let index = match != null && match.length > 0 ? match[0] : 0;
  
    let colorValueBinding = cell.getBinding(actionName + '.val');
    if (index == 0 || colorValueBinding == null || !coloring) delete cell[key][index];
    else {
      color = JSON.parse(colorValueBinding.value);
      // set value
      if (coloring) cell[key][index] = color;
    }
  
    // get first color or reset
    if (Object.keys(cell[key]).length > 0) {
      let firstIndex = Object.keys(cell[key]).sort()[0];
      color = cell[key][firstIndex];
    } else {
      // for reset
      color = null;
    }
  
    // apply
    cell['current.color.fill.' + target] = color;
  
    return color;
  };
  TableScriptAPI.prototype.resolveColor = function () {
    let args = Array.prototype.slice.call(arguments);
    for (let i = 0; i < args.length; i++) {
      if (args[i] != null) return args[i];
    }
    return null;
  };
  
  TableScriptAPI.prototype.items = function (cell, binding, value) {
      if (cell == null || value == null) return;
      const fractionLengthBinding = cell.getBinding('fractionLength')
      let fractionLength = fractionLengthBinding != null ? JSON.parse($(fractionLengthBinding).attr('value')) : null;
      
    if (cell.tables != null) {
      let result = this.processValue(cell, value);
      for (var i = 0; i < cell.tables.length; i++) {
        let table = cell.tables[i];
  
        if (result.src != null) {
          let row = document.querySelector(`#${CSS.escape(result.src.id)}`);
          if (row != null) {
            let cname = $(row).find('td.c-name');
            let cvalue = $(row).find('td.c-value');
            let cmeasure = $(row).find('td.c-measure');
            if (cname == null || cvalue == null || cmeasure == null) return;
  
            ////////// resolve colors (dynamic || fixed || default) & check for bad //////////
  
            // font name
            let target_font_color_name = this.resolveColor(cell['current.color.font.name'], cell['color.font.name'], '#000000');
            if (result.bad) target_font_color_name = this.resolveColor(cell['color.font.name.bad'], target_font_color_name);
  
            // font value
            let target_font_color_value = this.resolveColor(cell['current.color.font.value'], cell['color.font.value'], '#90EE90');
            if (result.bad) target_font_color_value = this.resolveColor(cell['color.font.value.bad'], VCLASS.UNRELIABLE_INFO);
  
            // font measure
            let target_font_color_measure = this.resolveColor(cell['current.color.font.measure'], cell['color.font.measure'], '#000000');
            if (result.bad) target_font_color_measure = this.resolveColor(cell['color.font.measure.bad'], target_font_color_measure);
  
            // fill name
            let target_fill_color_name = this.resolveColor(cell['current.color.fill.name'], cell['color.fill.name'], 'transparent');
            if (result.bad) target_fill_color_name = this.resolveColor(cell['color.fill.name.bad'], target_fill_color_name);
  
            // fill value
            let target_fill_color_value = this.resolveColor(cell['current.color.fill.value'], cell['color.fill.value'], '#000000');
            if (result.bad) target_fill_color_value = this.resolveColor(cell['color.fill.value.bad'], '#808080');
  
            // fill measure
            let target_fill_color_measure = this.resolveColor(cell['current.color.fill.measure'], cell['color.fill.measure'], 'transparent');
            if (result.bad) target_fill_color_measure = this.resolveColor(cell['color.fill.measure.bad'], target_fill_color_measure);
  
            // value
              if (result.isbool) {
                  if (row.box == null) {
                      let chBox = $(document.createElement('input'));
                      chBox.attr('type', 'checkbox');
                      chBox.attr('readOnly', true);
                      row.box = chBox;
                  }
                  row.box.attr('checked', result.value == true);
                  row.box.attr('disabled', result.bad);
                  cvalue.html(row.box[0].outerHTML);
              } else fractionLength
                  ?
                  cvalue.html(API.FORMAT.getValue(value).toFixed(Number(fractionLength)))
                  :
                  cvalue.html(API.FORMAT.getValue(value));
                
  
            // measure
            if (!row.measure) {
              cmeasure.html(result.src.m);
              row.measure = true;
            }
  
            // apply colors
            cname.css('color', target_font_color_name || 'transparent');
            cname.css('background-color', target_fill_color_name || 'transparent');
  
            cvalue.css('color', target_font_color_value || 'transparent');
            cvalue.css('background-color', target_fill_color_value || 'transparent');
  
            cmeasure.css('color', target_font_color_measure || 'transparent');
            cmeasure.css('background-color', target_fill_color_measure || 'transparent');
          }
        }
        // update cell HTML value for printing !!!
        if (cell.container != null) cell.container.setValue(table.outerHTML);
      }
    }
  };
  
  function ButtonScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(ButtonScriptAPI, ShapeAPI);
  ButtonScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
  };
  
  function ChartScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(ChartScriptAPI, ShapeAPI);
  ChartScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
    // setup chart
    if (cell.canvas == null) {
      let chartColors = {
        red: 'rgb(255, 99, 132)',
        blue: 'rgb(54, 162, 235)',
        max: 'rgb(255, 0, 255)',
        min: 'rgb(0, 255, 000)',
      };
      let randomData = function (unit, add, min, max) {
        if (min == null) min = -100;
        if (max == null) max = +100;
        if (unit == null) unit = 'second';
  
        let randomTime = function () {
          switch (unit) {
            case 'millisecond':
              return new Date().addMilliseconds(add || 0);
            case 'second':
              return new Date().addSeconds(add || 0);
            case 'minute':
              return new Date().addMinutes(add || 0);
            case 'hour':
              return new Date().addHours(add || 0);
            case 'day':
              return new Date().addDays(add || 0);
            case 'week':
              return new Date().addWeeks(add || 0);
            case 'month':
              return new Date().addMonths(add || 0);
            case 'year':
              return new Date().addWeeks(add || 0);
            default:
              return new Date().addSeconds(add || 0);
          }
        };
  
        return {
          x: randomTime(),
          y: Math.random() * (max - min) + min,
        };
      };
      var createMaxAnnotation = function (value) {
        return {
          id: 'y-max',
          type: 'line',
          mode: 'horizontal',
          scaleID: 'y-axis-1',
          value: value,
          borderColor: 'rgba(255, 0, 0, 1)',
          borderWidth: 1.5,
          borderDash: [5, 5],
          label: {
            enabled: true,
            backgroundColor: 'transparent',
            fontColor: '#ff0000',
            content: 'Макс.',
            position: 'left',
            fontSize: 10,
            yAdjust: +8,
            cornerRadius: 3,
          },
        };
      };
      var createMinAnnotation = function (value) {
        return {
          id: 'y-min',
          type: 'line',
          mode: 'horizontal',
          scaleID: 'y-axis-1',
          value: value,
          borderColor: 'rgba(0, 0, 255, 1)',
          borderWidth: 1.5,
          borderDash: [5, 5],
          label: {
            enabled: true,
            backgroundColor: 'transparent',
            fontColor: '#0000ff',
            content: 'Мин.',
            position: 'left',
            fontSize: 10,
            yAdjust: -8,
            cornerRadius: 3,
          },
        };
      };
      let getChartConfig = function () {
        return {
          type: 'scatter',
          data: {
            datasets: [
              {
                label: 'Тренд 1',
                fill: false,
                showLine: true,
                lineTension: 0,
                backgroundColor: chartColors.red,
                borderColor: chartColors.red,
                data: [],
              },
              {
                label: 'Тренд 2',
                fill: false,
                showLine: true,
                lineTension: 0,
                backgroundColor: chartColors.blue,
                borderColor: chartColors.blue,
                data: [],
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            //{
            //    duration: 300
            //},
            title: {
              display: true,
              text: 'График',
            },
            legend: {
              display: true,
              position: 'top',
              labels: {
                boxWidth: 15,
                fontFamily: 'Arial',
                fontSize: 8,
                padding: 5,
                usePointStyle: false,
              },
            },
            scales: {
              xAxes: [
                {
                  display: true,
                  type: 'time',
                  autoSkip: false,
                  position: 'bottom',
                  distribution: 'linear',
                  bounds: 'ticks',
                  time: {
                    isoWeekday: true,
                    unit: 'second',
                    //unitStepSize: 10,
                    //stepSize: 1,
                    //precision: 1,
                    //round: true,
                    //minUnit: 'hour',
                    displayFormats: {
                      millisecond: 'ss.SSS',
                      second: 'mm:ss.SSS',
                      minute: 'HH:mm:ss',
                      hour: 'DD.MM HH:mm',
                      day: 'DD.MM',
                      week: 'WW.YYYY',
                      month: 'DD.MM.YYYY',
                      quarter: 'Q YYYY',
                      year: 'YYYY',
                    },
                  },
                  scaleLabel: {
                    display: true,
                    labelString: 'Время',
                    lineHeight: 1,
                    fontFamily: 'Arial',
                    fontSize: 10,
                    padding: { bootom: 5 },
                  },
                  //ticks:
                  //{
                  //    source: "auto",
                  //    //maxTicksLimit: 10,
                  //    //autoSkip: true,
                  //    stepSize: 5,
                  //    //precision: 1,
  
                  //    lineHeight: 1,
                  //    fontFamily: 'Arial',
                  //    fontSize: 10,
                  //    padding: 0,
                  //    maxRotation: 45,
                  //    //callback: function (value, index, values)
                  //    //{
                  //    //    //return API.FORMAT.getDateTimeString(value);
                  //    //    return moment(value).format('HH:mm:ss');
                  //    //}
                  //}
                },
              ],
              yAxes: [
                {
                  display: true,
                  scaleLabel: {
                    display: true,
                    labelString: 'Значение',
                    lineHeight: 1,
                    fontFamily: 'Arial',
                    fontSize: 10,
                    padding: { top: 5 },
                  },
                  ticks: {
                    source: 'data',
                    maxTicksLimit: 10,
                    //stepSize: 1.1,
                    precision: 3,
                    lineHeight: 1,
                    fontFamily: 'Arial',
                    fontSize: 10,
                  },
                },
              ],
            },
            layout: {
              padding: 0,
            },
            annotation: {
              drawTime: 'afterDraw',
              annotations: [createMaxAnnotation(90), createMinAnnotation(-90)],
            },
          },
        };
      };
  
      let geom = this.graph.getCellGeometry(cell);
      // build chart
      var node = document.createElement('canvas');
      node.setAttribute('id', cell.mxObjectId);
      node.setAttribute('class', 'chart');
      node.setAttribute('width', geom.width);
      node.setAttribute('height', geom.height);
      // Document for empty output if not in DOM
      document.body.appendChild(node);
      cell.canvas = node;
      cell.chart = new Chart.Scatter(node.getContext('2d'), getChartConfig());
  
      (function () {
        if (this.chart != null) {
          // header
          this.chart.options.title.display = false;
          let hdrBinding = this.getBinding('header');
          if (hdrBinding != null) {
            let hdr = JSON.parse(hdrBinding.value);
            if (hdr != null && hdr.text != null) {
              this.chart.options.title.text = hdr.text;
              this.chart.options.title.display = true;
            }
          }
          // legend
          let legendBinding = this.getBinding('legend');
          this.chart.options.legend.display = legendBinding == null || JSON.parse(legendBinding.value) != '0';
  
          // axisX.label
          this.chart.options.scales.xAxes[0].scaleLabel.display = false;
          let axisXLabelBinding = this.getBinding('axisX.label');
          if (axisXLabelBinding != null) {
            let axisXLabel = JSON.parse(axisXLabelBinding.value);
            if (axisXLabel != null && axisXLabel.text != null) {
              this.chart.options.scales.xAxes[0].scaleLabel.labelString = axisXLabel.text;
              this.chart.options.scales.xAxes[0].scaleLabel.display = true;
            }
          }
  
          // axisX.measure
          let xUnit = 'second';
          let axisXMeasureBinding = this.getBinding('axisX.measure');
          if (axisXMeasureBinding != null) {
            let axisXMeasure = JSON.parse(axisXMeasureBinding.value);
            switch (axisXMeasure) {
              case 'ms':
                xUnit = 'millisecond';
                break;
              case 's':
                xUnit = 'second';
                break;
              case 'mn':
                xUnit = 'minute';
                break;
              case 'h':
                xUnit = 'hour';
                break;
              case 'd':
                xUnit = 'day';
                break;
              case 'w':
                xUnit = 'week';
                break;
              case 'm':
                xUnit = 'month';
                break;
              case 'y':
                xUnit = 'year';
                break;
              default:
                xUnit = 'second';
                break;
            }
          }
          this.chart.options.scales.xAxes[0].time.unit = xUnit;
  
          // axisX.step
          let xStep = 1;
          this.chart.options.scales.xAxes[0].time.stepSize = xStep;
          let axisXStepBinding = this.getBinding('axisX.step');
          if (axisXStepBinding != null) {
            let axisXStep = JSON.parse(axisXStepBinding.value);
            xStep = parseNumber(axisXStep) || 1;
            this.chart.options.scales.xAxes[0].time.stepSize = xStep;
          }
  
          // axisX.scale
          let xScale = 30;
          let axisXScaleBinding = this.getBinding('axisX.scale');
          if (axisXScaleBinding != null) {
            let axisXScale = JSON.parse(axisXScaleBinding.value);
            xScale = parseNumber(axisXScale) || 30;
          }
  
          // axisY.label
          this.chart.options.scales.yAxes[0].scaleLabel.display = false;
          let axisYLabelBinding = this.getBinding('axisY.label');
          if (axisYLabelBinding != null) {
            let axisYLabel = JSON.parse(axisYLabelBinding.value);
            if (axisYLabel != null && axisYLabel.text != null) {
              this.chart.options.scales.yAxes[0].scaleLabel.labelString = axisYLabel.text;
              this.chart.options.scales.yAxes[0].scaleLabel.display = true;
            }
          }
  
          // clear axisY annotations
          this.chart.options.annotation.annotations.length = 0;
          this.chart.annotation.elements = {};
          this.chart.annotation.options.annotations.length = 0;
  
          // axisY.max
          let maxValue = null;
          let axisYMaxBinding = this.getBinding('axisY.max.show');
          if (axisYMaxBinding != null) {
            let axisYMaxShow = JSON.parse(axisYMaxBinding.value);
            if (axisYMaxShow != null && axisYMaxShow != '0') {
              let axisYMaxValueBinding = this.getBinding('axisY.max.value');
              if (axisYMaxValueBinding != null) {
                let axisYMaxValue = JSON.parse(axisYMaxValueBinding.value);
                if (axisYMaxValue != null) maxValue = parseNumber(axisYMaxValue, 0, 3);
              }
              let annotation = createMaxAnnotation(maxValue);
              this.chart.options.annotation.annotations.push(annotation); // show
            }
          }
          // axisY.min
          let minValue = null;
          let axisYMinBinding = this.getBinding('axisY.min.show');
          if (axisYMinBinding != null) {
            let axisYMinShow = JSON.parse(axisYMinBinding.value);
            if (axisYMinShow != null && axisYMinShow != '0') {
              let axisYMinValueBinding = this.getBinding('axisY.min.value');
              if (axisYMinValueBinding != null) {
                let axisYMinValue = JSON.parse(axisYMinValueBinding.value);
                if (axisYMinValue != null) minValue = parseNumber(axisYMinValue, 0, 3);
              }
              let annotation = createMinAnnotation(minValue);
              this.chart.options.annotation.annotations.push(annotation); // show
            }
          }
  
          // items
          this.chart.data.datasets = [];
          let itemsBinding = this.getBinding('items');
          if (itemsBinding != null) {
            let getType = function (item) {
              switch (item.view) {
                case '4': // bars
                  return 'bar';
                default:
                  return 'scatter';
              }
            };
            let getShowLine = function (item) {
              switch (item.view) {
                case '1': // points
                  return false;
                default:
                  return true;
              }
            };
  
            let items = JSON.parse(itemsBinding.value);
            if (items != null && items.length > 0) {
              for (let i = 0; i < items.length; i++) {
                let item = items[i];
                if (item != null) {
                  this.chart.data.datasets.push({
                    id: item.id,
                    label: item.d,
                    fill: false,
                    showLine: getShowLine(item),
                    lineTension: 0,
                    backgroundColor: item.color,
                    borderColor: item.color,
                    type: getType(item),
                    steppedLine: item.view == '3' ? 'before' : false, // stepped line
                    data: [
                      //randomData(xUnit, 0, minValue, maxValue),
                      //randomData(xUnit, 1, minValue, maxValue),
                      //randomData(xUnit, 2, minValue, maxValue),
                      //randomData(xUnit, 3, minValue, maxValue),
                      //randomData(xUnit, 4, minValue, maxValue)
                    ],
                  });
                }
              }
            }
          }
  
          this.chart.update();
  
          this.chart.validateRange = mxUtils.bind(cell, function () {
            // update x-axis width
            if (xScale > 0 && xStep > 0) {
              let xAxis = this.chart.scales['x-axis-1'];
              let minDate = moment(xAxis.min).toDate();
              let maxDate = moment(xAxis.max).toDate();
  
              switch (xUnit) {
                case 'millisecond':
                  minDate = maxDate.addMilliseconds(-xScale || 0);
                  break;
                case 'second':
                  minDate = maxDate.addSeconds(-xScale || 0);
                  break;
                case 'minute':
                  minDate = maxDate.addMinutes(-xScale || 0);
                  break;
                case 'hour':
                  minDate = maxDate.addHours(-xScale || 0);
                  break;
                case 'day':
                  minDate = maxDate.addDays(-xScale || 0);
                  break;
                case 'week':
                  minDate = maxDate.addWeeks(-xScale || 0);
                  break;
                case 'month':
                  minDate = maxDate.addMonths(-xScale || 0);
                  break;
                case 'year':
                  minDate = maxDate.addWeeks(-xScale || 0);
                  break;
                default:
                  break;
              }
  
              if (minDate != null) this.chart.options.scales.xAxes[0].ticks.min = minDate.getTime(); //moment(minDate);
  
              this.chart.update();
            }
          });
          this.chart.validateRange();
        }
      }).apply(cell);
    }
  };
  ChartScriptAPI.prototype.visit = function (cell, map) {
    shapeVisit.apply(this, arguments);
    let itemsBinding = cell.getBinding('items');
    if (itemsBinding != null && !isNullOrEmpty(itemsBinding.value)) {
      let bind = JSON.parse(itemsBinding.value);
      if (bind == null) return;
      if (bind.length) {
        for (let j = 0; j < bind.length; j++) {
          let id = bind[j].id;
          if (GUID.isValid(id)) map.eq.push(bind[j]);
          else map.tag.push(bind[j]);
        }
      }
    }
  };
  ChartScriptAPI.prototype.items = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
  
    let ds = cell.chart.data.datasets.find(function (x) {
      return x.id == value.id;
    });
    if (ds != null) {
      if (ds.data.length > 100) ds.data.shift();
  
      ds.data.push({
        x: API.FORMAT.getDate(value.ts).getTime(),
        y: value.v,
      });
    }
  
    cell.chart.validateRange();
  };
  
  function RollSwitchScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(RollSwitchScriptAPI, ShapeAPI);
  RollSwitchScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
  
    let geo = this.graph.getCellGeometry(cell);
    if (cell.question == null) {
      cell.question = this.graph.insertVertex(cell, null, '?', 0, geo.height / 3, geo.width, geo.height / 3, 'text;align=center;verticalAlign=middle;pointerEvents=0;fontSize=' + (geo.height / 3 / 10) * 7, false);
      cell.question.getTooltip = function () {};
    }
    if (cell.damage == null) {
      cell.damage = this.graph.insertVertex(cell, null, '', -0.5, -0.5, geo.width * 2, geo.height * 2, 'line;strokeColor=#FF0000;strokeWidth=2;fillColor=none;pointerEvents=0;rotation=-45;', true);
      cell.damage.getTooltip = function () {};
    }
    if (cell.roll_damage == null) {
      cell.roll_damage = this.graph.insertVertex(cell, null, '', -1, 0, geo.width * 3, geo.height, 'line;strokeColor=#FF0000;strokeWidth=2;fillColor=none;pointerEvents=0;rotation=-45;', true);
      cell.roll_damage.getTooltip = function () {};
    }
  };
  RollSwitchScriptAPI.prototype.position = function (cell, binding) {
    let pos = binding != null ? JSON.parse(binding.value) : mxCellRenderer.defaultShapes['rollswitch'].prototype.position == true ? '1' : '0';
    let state = this.graph.view.getState(cell);
    if (state != null && state.shape != null) cell.position = state.shape.position = pos == '1';
  };
  RollSwitchScriptAPI.prototype.state = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
  
    let current = result.bad ? 'UNKNOWN' : result.value;
    if (result.state == null && current != 'UNKNOWN') current = result.value != null && result.value ? 'ROLL_IN_SWITCH_ON' : 'ROLL_IN_SWITCH_OFF';
  
    // hide question
    cell.question.setVisible(false);
    // hide damage
    cell.damage.setVisible(false);
    // hide roll_damage
    cell.roll_damage.setVisible(false);
  
    var cellState = this.graph.view.getState(cell);
    if (cellState != null && cellState.shape != null) {
      let shape = cellState.shape;
      // check position
      if (cell.position == null) cell.position = mxCellRenderer.defaultShapes['rollswitch'].prototype.position;
      shape.position = cell.position;
  
      let fontColor = cell.origin.style.fontColor || 'none';
      let fillColor = cell.origin.style.fillColor || 'none';
      let borderColor = cell.origin.style.strokeColor || 'none';
  
      // reset colors
      this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, fontColor, [cell.question]);
      this.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, fillColor, [cell]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      // если задан класс напряжения
      if (!VCLASS.isDefaultValue(cell.vclass)) {
        let vclassColor = VCLASS.getColor(cell.vclass);
        switch (current) {
          case 'ROLL_IN_SWITCH_ON':
            {
              shape.on = true;
              shape.roll = 'IN';
              fillColor = vclassColor;
              borderColor = vclassColor;
            }
            break;
          case 'ROLL_IN_SWITCH_OFF':
            {
              shape.on = false;
              shape.roll = 'IN';
              fillColor = 'none';
              borderColor = vclassColor;
            }
            break;
          case 'ROLL_IN_SWITCH_ERROR':
            {
              // hide position if exists
              shape.position = false;
              shape.roll = 'IN';
              // apply colors
              fillColor = VCLASS.UNRELIABLE_INFO;
              borderColor = vclassColor;
              // show question mark
              cell.question.setVisible(true);
              this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, vclassColor, [cell.question]);
              // update cell.question
              //let questionCellState = this.graph.view.getState(cell.question, true);
              //if (questionCellState != null)
              //    questionCellState.setCursor(mxConstants.CURSOR_CONNECT);
            }
            break;
          case 'ROLL_IN_SWITCH_DAMAGE':
            {
              // hide position if exists
              shape.position = false;
              shape.roll = 'IN';
              // apply colors
              fillColor = 'none';
              borderColor = vclassColor;
              cell.damage.setVisible(true);
            }
            break;
          case 'ROLL_CONTROL_SWITCH_ON':
            {
              shape.on = true;
              shape.roll = 'CONTROL';
              fillColor = vclassColor;
              borderColor = vclassColor;
            }
            break;
          case 'ROLL_CONTROL_SWITCH_OFF':
            {
              shape.on = false;
              shape.roll = 'CONTROL';
              fillColor = 'none';
              borderColor = vclassColor;
            }
            break;
          case 'ROLL_CONTROL_SWITCH_ERROR':
            {
              // hide position if exists
              shape.position = false;
              shape.roll = 'CONTROL';
              // apply colors
              fillColor = VCLASS.UNRELIABLE_INFO;
              borderColor = vclassColor;
              // show question mark
              cell.question.setVisible(true);
              this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, vclassColor, [cell.question]);
              // update cell.question
              //let questionCellState = this.graph.view.getState(cell.question, true);
              //if (questionCellState != null)
              //    questionCellState.setCursor(mxConstants.CURSOR_CONNECT);
            }
            break;
          case 'ROLL_CONTROL_SWITCH_DAMAGE':
            {
              // hide position if exists
              shape.position = false;
              shape.roll = 'CONTROL';
              // apply colors
              fillColor = 'none';
              borderColor = vclassColor;
              cell.damage.setVisible(true);
            }
            break;
          case 'ROLL_DAMAGE_SWITCH_ON':
            {
              // hide position if exists
              shape.on = true;
              shape.position = false;
              shape.roll = 'DAMAGE';
              // apply colors
              borderColor = vclassColor;
              cell.roll_damage.setVisible(true);
            }
            break;
          case 'ROLL_DAMAGE_SWITCH_OFF':
            {
              // hide position if exists
              shape.on = false;
              shape.position = false;
              shape.roll = 'DAMAGE';
              // apply colors
              borderColor = vclassColor;
              cell.roll_damage.setVisible(true);
            }
            break;
          case 'ROLL_DAMAGE_SWITCH_ERROR':
            {
              // hide position if exists
              shape.position = false;
              shape.roll = 'DAMAGE';
              // apply colors
              fillColor = VCLASS.UNRELIABLE_INFO;
              borderColor = vclassColor;
              // show question mark
              cell.question.setVisible(true);
              this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, vclassColor, [cell.question]);
              cell.roll_damage.setVisible(true);
            }
            break;
          case 'ROLL_DAMAGE_SWITCH_DAMAGE':
            {
              // hide position if exists
              shape.position = false;
              shape.roll = 'DAMAGE|DAMAGE';
              // apply colors
              fillColor = 'none';
              borderColor = vclassColor;
              cell.roll_damage.setVisible(true);
            }
            break;
          case 'SERVICE':
            // hide position if exists
            shape.position = false;
            fillColor = 'none';
            borderColor = VCLASS.SERVICE;
            break;
          default:
            {
              // hide position if exists
              shape.position = false;
              // apply colors
              fillColor = VCLASS.UNRELIABLE_INFO;
              borderColor = vclassColor;
              // show question mark
              cell.question.setVisible(true);
              this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, vclassColor, [cell.question]);
              // update cell.question
              //let questionCellState = this.graph.view.getState(cell.question, true);
              //if (questionCellState != null)
              //    questionCellState.setCursor(mxConstants.CURSOR_CONNECT);
            }
            break;
        }
      } else {
        switch (current) {
          case 'ROLL_IN_SWITCH_ON':
            {
              shape.on = true;
              shape.roll = 'IN';
            }
            break;
          case 'ROLL_IN_SWITCH_OFF':
            {
              shape.on = false;
              shape.roll = 'IN';
              fillColor = 'none';
            }
            break;
          case 'ROLL_IN_SWITCH_ERROR':
            {
              // hide position if exists
              shape.position = false;
              shape.roll = 'IN';
              // apply colors
              fillColor = VCLASS.UNRELIABLE_INFO;
              // show question mark
              cell.question.setVisible(true);
            }
            break;
          case 'ROLL_IN_SWITCH_DAMAGE':
            {
              // hide position if exists
              shape.position = false;
              shape.roll = 'IN';
              // apply colors
              fillColor = 'none';
              cell.damage.setVisible(true);
            }
            break;
          case 'ROLL_CONTROL_SWITCH_ON':
            {
              shape.on = true;
              shape.roll = 'CONTROL';
            }
            break;
          case 'ROLL_CONTROL_SWITCH_OFF':
            {
              shape.on = false;
              shape.roll = 'CONTROL';
              fillColor = 'none';
            }
            break;
          case 'ROLL_CONTROL_SWITCH_ERROR':
            {
              // hide position if exists
              shape.position = false;
              shape.roll = 'CONTROL';
              // apply colors
              fillColor = VCLASS.UNRELIABLE_INFO;
              // show question mark
              cell.question.setVisible(true);
            }
            break;
          case 'ROLL_CONTROL_SWITCH_DAMAGE':
            {
              // hide position if exists
              shape.position = false;
              shape.roll = 'CONTROL';
              // apply colors
              fillColor = 'none';
              cell.damage.setVisible(true);
            }
            break;
          case 'ROLL_DAMAGE_SWITCH_ON':
            {
              // hide position if exists
              shape.on = true;
              shape.position = false;
              shape.roll = 'DAMAGE';
              // apply colors
              cell.roll_damage.setVisible(true);
            }
            break;
          case 'ROLL_DAMAGE_SWITCH_OFF':
            {
              // hide position if exists
              shape.on = false;
              shape.position = false;
              shape.roll = 'DAMAGE';
              // apply colors
              cell.roll_damage.setVisible(true);
            }
            break;
          case 'ROLL_DAMAGE_SWITCH_ERROR':
            {
              // hide position if exists
              shape.position = false;
              shape.roll = 'DAMAGE';
              // apply colors
              fillColor = VCLASS.UNRELIABLE_INFO;
              // show question mark
              cell.question.setVisible(true);
              cell.roll_damage.setVisible(true);
            }
            break;
          case 'ROLL_DAMAGE_SWITCH_DAMAGE':
            {
              // hide position if exists
              shape.position = false;
              shape.roll = 'DAMAGE|DAMAGE';
              // apply colors
              fillColor = 'none';
              cell.roll_damage.setVisible(true);
            }
            break;
          case 'SERVICE':
            // hide position if exists
            shape.position = false;
            fillColor = 'none';
            borderColor = VCLASS.SERVICE;
            break;
          default:
            {
              // hide position if exists
              shape.position = false;
              // apply colors
              fillColor = VCLASS.UNRELIABLE_INFO;
              // show question mark
              cell.question.setVisible(true);
            }
            break;
        }
      }
  
      // apply colors
      this.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, fillColor, [cell]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      // update cell
      this.graph.cellRenderer.redrawShape(cellState, true);
    }
  };
  
  function RollDisconnectorScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(RollDisconnectorScriptAPI, ShapeAPI);
  RollDisconnectorScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
  
    let geo = this.graph.getCellGeometry(cell);
    if (cell.damage == null) {
      cell.damage = this.graph.insertVertex(cell, null, '', -1, 0, geo.width * 3, geo.height, 'line;strokeColor=#FF0000;strokeWidth=2;fillColor=none;pointerEvents=0;rotation=-45;', true);
      cell.damage.getTooltip = function () {};
    }
  };
  RollDisconnectorScriptAPI.prototype.state = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
  
    let current = result.bad ? 'UNKNOWN' : result.value;
    if (result.state == null && current != 'UNKNOWN') current = result.value != null && result.value ? 'ROLL_IN' : 'ROLL_CONTROL';
  
    // hide damage
    cell.damage.setVisible(false);
  
    var cellState = this.graph.view.getState(cell);
    if (cellState != null && cellState.shape != null) {
      let shape = cellState.shape;
  
      let fontColor = cell.origin.style.fontColor || 'none';
      let borderColor = cell.origin.style.strokeColor || 'none';
  
      // reset colors
      this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, fontColor, [cell.question]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      let targetColor = !VCLASS.isDefaultValue(cell.vclass) ? VCLASS.getColor(cell.vclass) : borderColor;
      switch (current) {
        case 'ROLL_IN':
          {
            shape.roll = 'IN';
            borderColor = targetColor;
          }
          break;
        case 'ROLL_CONTROL':
          {
            shape.roll = 'CONTROL';
            borderColor = targetColor;
          }
          break;
        case 'ROLL_DAMAGE':
          {
            shape.roll = 'DAMAGE';
            borderColor = targetColor;
            cell.damage.setVisible(true);
          }
          break;
        case 'SERVICE':
          {
            borderColor = VCLASS.SERVICE;
          }
          break;
        default:
          {
            borderColor = targetColor;
          }
          break;
      }
  
      // apply colors
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      // update cell
      this.graph.cellRenderer.redrawShape(cellState, true);
    }
  };
  
  function DisconnectorScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(DisconnectorScriptAPI, ShapeAPI);
  DisconnectorScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
  
    let geo = this.graph.getCellGeometry(cell);
    if (cell.question == null) {
      cell.question = this.graph.insertVertex(cell, null, '?', 0 + geo.width / 5, geo.height / 8, geo.width - geo.width / 2.5, geo.height - geo.height / 4, 'text;align=center;verticalAlign=middle;pointerEvents=0;fontSize=' + (geo.height / 10) * 7 + ';fillColor=' + VCLASS.UNRELIABLE_INFO, false);
      cell.question.getTooltip = function () {};
    }
    if (cell.damage == null) {
      cell.damage = this.graph.insertVertex(cell, null, null, -0.5, -0.5, geo.width * 2, geo.height * 2, 'line;strokeColor=#FF0000;strokeWidth=2;fillColor=none;pointerEvents=0;rotation=-45;', true);
      cell.damage.getTooltip = function () {};
    }
  };
  DisconnectorScriptAPI.prototype.state = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
  
    let current = result.bad ? 'UNKNOWN' : result.value;
    if (result.state == null && current != 'UNKNOWN') current = result.value != null && result.value ? 'ON' : 'OFF';
  
    // hide question
    cell.question.setVisible(false);
    // hide damage
    cell.damage.setVisible(false);
  
    var cellState = this.graph.view.getState(cell);
    if (cellState != null && cellState.shape != null) {
      let shape = cellState.shape;
  
      let fontColor = cell.origin.style.fontColor || 'none';
      let borderColor = cell.origin.style.strokeColor || 'none';
  
      // reset colors
      this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, fontColor, [cell.question]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      let targetColor = !VCLASS.isDefaultValue(cell.vclass) ? VCLASS.getColor(cell.vclass) : borderColor;
      switch (current) {
        case 'ON':
          {
            shape._state = 'ON';
            borderColor = targetColor;
          }
          break;
        case 'OFF':
          {
            shape._state = 'OFF';
            borderColor = targetColor;
          }
          break;
        case 'MIDDLE':
          {
            shape._state = 'MIDDLE';
            borderColor = targetColor;
          }
          break;
        case 'DAMAGE':
          {
            shape._state = 'DAMAGE';
            borderColor = targetColor;
            cell.damage.setVisible(true);
          }
          break;
        case 'SERVICE':
          {
            shape._state = 'OFF';
            borderColor = VCLASS.SERVICE;
          }
          break;
        case 'ERROR':
        default:
          {
            shape._state = 'ERROR';
            borderColor = targetColor;
            // show question mark
            cell.question.setVisible(true);
            this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, targetColor, [cell.question]);
          }
          break;
      }
  
      // apply colors
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      // update cell
      this.graph.cellRenderer.redrawShape(cellState, true);
    }
  };
  
  function SeparatorScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(SeparatorScriptAPI, ShapeAPI);
  SeparatorScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
  
    let geo = this.graph.getCellGeometry(cell);
    if (cell.question == null) {
      cell.question = this.graph.insertVertex(cell, null, '?', 0 + geo.width / 5, geo.height / 8, geo.width - geo.width / 2.5, geo.height - geo.height / 4, 'text;align=center;verticalAlign=middle;pointerEvents=0;fontSize=' + (geo.height / 10) * 7 + ';fillColor=' + VCLASS.UNRELIABLE_INFO, false);
      cell.question.getTooltip = function () {};
    }
    if (cell.damage == null) {
      cell.damage = this.graph.insertVertex(cell, null, null, -0.5, -0.5, geo.width * 2, geo.height * 2, 'line;strokeColor=#FF0000;strokeWidth=2;fillColor=none;pointerEvents=0;rotation=-45;', true);
      cell.damage.getTooltip = function () {};
    }
  };
  SeparatorScriptAPI.prototype.state = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
  
    let current = result.bad ? 'UNKNOWN' : result.value;
    if (result.state == null && current != 'UNKNOWN') current = result.value != null && result.value ? 'ON' : 'OFF';
  
    // hide question
    cell.question.setVisible(false);
    // hide damage
    cell.damage.setVisible(false);
  
    var cellState = this.graph.view.getState(cell);
    if (cellState != null && cellState.shape != null) {
      let shape = cellState.shape;
  
      let fontColor = cell.origin.style.fontColor || 'none';
      let borderColor = cell.origin.style.strokeColor || 'none';
  
      // reset colors
      this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, fontColor, [cell.question]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      let targetColor = !VCLASS.isDefaultValue(cell.vclass) ? VCLASS.getColor(cell.vclass) : borderColor;
      switch (current) {
        case 'ON':
          {
            shape._state = 'ON';
            borderColor = targetColor;
          }
          break;
        case 'OFF':
          {
            shape._state = 'OFF';
            borderColor = targetColor;
          }
          break;
        case 'MIDDLE':
          {
            shape._state = 'MIDDLE';
            borderColor = targetColor;
          }
          break;
        case 'DAMAGE':
          {
            shape._state = 'DAMAGE';
            borderColor = targetColor;
            cell.damage.setVisible(true);
          }
          break;
        case 'SERVICE':
          {
            shape._state = 'OFF';
            borderColor = VCLASS.SERVICE;
          }
          break;
        case 'ERROR':
        default:
          {
            shape._state = 'ERROR';
            borderColor = targetColor;
            // show question mark
            cell.question.setVisible(true);
            this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, targetColor, [cell.question]);
          }
          break;
      }
  
      // apply colors
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      // update cell
      this.graph.cellRenderer.redrawShape(cellState, true);
    }
  };
  
  function GroundScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(GroundScriptAPI, ShapeAPI);
  GroundScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
  
    let geo = this.graph.getCellGeometry(cell);
    if (cell.question == null) {
      cell.question = this.graph.insertVertex(cell, null, '?', 0, geo.height / 10, geo.width, geo.height - geo.height / 5, 'text;align=center;verticalAlign=middle;pointerEvents=0;fontSize=' + (geo.height / 10) * 7 + ';fillColor=' + VCLASS.UNRELIABLE_INFO, false);
      cell.question.getTooltip = function () {};
    }
    if (cell.damage == null) {
      cell.damage = this.graph.insertVertex(cell, null, null, -0.5, -0.5, geo.width * 2, geo.height * 2, 'line;strokeColor=#FF0000;strokeWidth=2;fillColor=none;pointerEvents=0;rotation=-45;', true);
      cell.damage.getTooltip = function () {};
    }
  };
  GroundScriptAPI.prototype.state = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
  
    let current = result.bad ? 'UNKNOWN' : result.value;
    if (result.state == null && current != 'UNKNOWN') current = result.value != null && result.value ? 'ON' : 'OFF';
  
    // hide question
    cell.question.setVisible(false);
    // hide damage
    cell.damage.setVisible(false);
  
    var cellState = this.graph.view.getState(cell);
    if (cellState != null && cellState.shape != null) {
      let shape = cellState.shape;
  
      let fontColor = cell.origin.style.fontColor || 'none';
      let borderColor = cell.origin.style.strokeColor || 'none';
  
      // reset colors
      this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, fontColor, [cell.question]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      let targetColor = !VCLASS.isDefaultValue(cell.vclass) ? VCLASS.getColor(cell.vclass) : borderColor;
      switch (current) {
        case 'ON':
          {
            shape._state = 'ON';
            borderColor = targetColor;
          }
          break;
        case 'OFF':
          {
            shape._state = 'OFF';
            borderColor = targetColor;
          }
          break;
        case 'MIDDLE':
          {
            shape._state = 'MIDDLE';
            borderColor = targetColor;
          }
          break;
        case 'DAMAGE':
          {
            shape._state = 'DAMAGE';
            borderColor = targetColor;
            cell.damage.setVisible(true);
          }
          break;
        case 'SERVICE':
          {
            shape._state = 'OFF';
            borderColor = VCLASS.SERVICE;
          }
          break;
        case 'ERROR':
        default:
          {
            shape._state = 'ERROR';
            borderColor = targetColor;
            // show question mark
            cell.question.setVisible(true);
            this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, targetColor, [cell.question]);
          }
          break;
      }
  
      // apply colors
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      // update cell
      this.graph.cellRenderer.redrawShape(cellState, true);
    }
  };
  
  function RollElementScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(RollElementScriptAPI, ShapeAPI);
  RollElementScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
  
    let geo = this.graph.getCellGeometry(cell);
    if (cell.damage == null) {
      cell.damage = this.graph.insertVertex(cell, null, '', -0.5, -0.5, geo.width * 2, geo.height * 2, 'line;strokeColor=#FF0000;strokeWidth=2;fillColor=none;pointerEvents=0;rotation=-45;', true);
      cell.damage.getTooltip = function () {};
    }
  };
  RollElementScriptAPI.prototype.state = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
  
    let current = result.bad ? 'UNKNOWN' : result.value;
    if (result.state == null && current != 'UNKNOWN') current = result.value != null && result.value ? 'ROLL_IN' : 'ROLL_CONTROL';
  
    // hide damage
    cell.damage.setVisible(false);
  
    var cellState = this.graph.view.getState(cell);
    if (cellState != null && cellState.shape != null) {
      let shape = cellState.shape;
  
      let borderColor = cell.origin.style.strokeColor || 'none';
  
      // reset colors
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      let targetColor = !VCLASS.isDefaultValue(cell.vclass) ? VCLASS.getColor(cell.vclass) : borderColor;
      switch (current) {
        case 'ROLL_IN':
          {
            shape._state = 'IN';
            borderColor = targetColor;
          }
          break;
        case 'ROLL_CONTROL':
          {
            shape._state = 'CONTROL';
            borderColor = targetColor;
          }
          break;
        case 'ROLL_DAMAGE':
          {
            shape._state = 'DAMAGE';
            borderColor = targetColor;
            cell.damage.setVisible(true);
          }
          break;
        case 'SERVICE':
          {
            shape._state = 'SERVICE';
            borderColor = VCLASS.SERVICE;
          }
          break;
        default:
          {
            shape._state = 'UNKNOWN';
            borderColor = VCLASS.UNRELIABLE_INFO;
          }
          break;
      }
  
      // apply colors
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      // update cell
      this.graph.cellRenderer.redrawShape(cellState, true);
    }
  };
  
  function ActuatorScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(ActuatorScriptAPI, ShapeAPI);
  ActuatorScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
  
    let geo = this.graph.getCellGeometry(cell);
    if (cell.question == null) {
      cell.question = this.graph.insertVertex(cell, null, '?', 0, 0.5, geo.width, geo.height, 'text;pointerEvents=0;fontSize=' + (geo.height / 10) * 8, true);
      cell.question.getTooltip = function () {};
    }
  };
  ActuatorScriptAPI.prototype.state = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
  
    let current = result.bad ? 'UNKNOWN' : result.value;
    if (result.state == null && current != 'UNKNOWN') current = result.value != null && result.value ? 'OPEN' : 'CLOSE';
  
    // hide question
    cell.question.setVisible(false);
  
    var cellState = this.graph.view.getState(cell);
    if (cellState != null && cellState.shape != null) {
      let shape = cellState.shape;
  
      let fontColor = cell.origin.style.fontColor || 'none';
      let fillColor = cell.origin.style.fillColor || 'none';
      let borderColor = cell.origin.style.strokeColor || 'none';
  
      // reset colors
      this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, fontColor, [cell.question]);
      this.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, fillColor, [cell]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      shape.fill_1 = null;
      shape.fill_2 = null;
  
      let targetColor = !VCLASS.isDefaultValue(cell.vclass) ? VCLASS.getColor(cell.vclass) : fillColor;
      switch (current) {
        case 'OPEN':
          {
            shape._state = 'OPEN';
            fillColor = targetColor;
          }
          break;
        case 'CLOSE':
          {
            shape._state = 'CLOSE';
            fillColor = 'none';
            borderColor = targetColor;
          }
          break;
        case 'MIDDLE':
          {
            shape._state = 'MIDDLE';
            fillColor = 'none';
            shape.fill_1 = targetColor;
          }
          break;
        case 'SERVICE':
          {
            shape._state = 'SERVICE';
            fillColor = 'none';
            borderColor = VCLASS.SERVICE;
          }
          break;
        case 'ERROR':
        default:
          {
            shape._state = 'ERROR';
            fillColor = '#FFFFFF';
            cell.question.setVisible(true);
            this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, targetColor, [cell.question]);
          }
          break;
      }
  
      // apply colors
      this.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, fillColor, [cell]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      // update cell
      this.graph.cellRenderer.redrawShape(cellState, true);
    }
  };
  
  function SimpleSwitchScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(SimpleSwitchScriptAPI, ShapeAPI);
  SimpleSwitchScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
  
    let geo = this.graph.getCellGeometry(cell);
    //let angle = mxUtils.getValue(this.graph.view.getState(cell).style, mxConstants.STYLE_ROTATION, 0);
    if (cell.question == null) {
      cell.question = this.graph.insertVertex(cell, null, '?', 0, geo.height / 20, geo.width, geo.height - geo.height / 10, 'text;align=center;verticalAlign=middle;pointerEvents=0;fontSize=' + (geo.height / 10) * 7 + ';fillColor=' + VCLASS.UNRELIABLE_INFO, false);
      cell.question.getTooltip = function () {};
    }
    if (cell.damage == null) {
      cell.damage = this.graph.insertVertex(cell, null, null, -0.5, -0.5, geo.width * 2, geo.height * 2, 'line;strokeColor=#FF0000;strokeWidth=2;fillColor=none;pointerEvents=0;rotation=-45;', true);
      cell.damage.getTooltip = function () {};
    }
  };
  SimpleSwitchScriptAPI.prototype.state = function (cell, binding, value) {
    if (cell == null || value == null) return;
  
    let result = this.processValue(cell, value);
  
    let current = result.bad ? 'UNKNOWN' : result.value;
    if (result.state == null && current != 'UNKNOWN') current = result.value != null && result.value ? 'ON' : 'OFF';
  
    // hide question
    cell.question.setVisible(false);
    // hide damage
    cell.damage.setVisible(false);
  
    var cellState = this.graph.view.getState(cell);
    if (cellState != null && cellState.shape != null) {
      let shape = cellState.shape;
  
      let fontColor = cell.origin.style.fontColor || 'none';
      let borderColor = cell.origin.style.strokeColor || 'none';
  
      // reset colors
      this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, fontColor, [cell.question]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, borderColor, [cell]);
  
      let targetColor = !VCLASS.isDefaultValue(cell.vclass) ? VCLASS.getColor(cell.vclass) : borderColor;
      switch (current) {
        case 'ON':
          {
            shape._state = 'ON';
          }
          break;
        case 'OFF':
          {
            shape._state = 'OFF';
          }
          break;
        case 'DAMAGE':
          {
            shape._state = 'DAMAGE';
            cell.damage.setVisible(true);
          }
          break;
        case 'SERVICE':
          {
            shape._state = 'OFF';
            targetColor = VCLASS.SERVICE;
          }
          break;
        case 'ERROR':
        default:
          {
            shape._state = 'ERROR';
            // show question mark
            cell.question.setVisible(true);
            this.graph.setCellStyles(mxConstants.STYLE_FONTCOLOR, targetColor, [cell.question]);
          }
          break;
      }
  
      // apply colors
      this.graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, targetColor, [cell]);
      this.graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, targetColor, [cell]);
  
      // update cell
      this.graph.cellRenderer.redrawShape(cellState, true);
    }
  };
  
  function BMRZScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(BMRZScriptAPI, ShapeAPI);
  BMRZScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
    // fake action
    cell.action = function () {};
    cell.getTooltip = function () {
      return 'Подключиться';
    };
  };
  BMRZScriptAPI.prototype.buildConfig = function (cell) {
    let config = { type: 'usb' };
    let type = cell.getBinding('connection.type');
    if (type != null && type.value != null) config.type = JSON.parse(type.value);
  
    switch (config.type) {
      case 'usb':
        break;
      case 'com':
        {
          config.com = {};
          // port
          config.com.port = 'COM1';
          let port = cell.getBinding('com.port');
          if (port != null && port.value != null) config.com.port = JSON.parse(port.value).trim();
          // address
          config.com.address = '55';
          let address = cell.getBinding('com.address');
          if (address != null && address.value != null) config.com.address = JSON.parse(address.value).trim();
          // speed
          config.com.speed = '19200';
          let speed = cell.getBinding('com.speed');
          if (speed != null && speed.value != null) config.com.speed = JSON.parse(speed.value).trim();
          // parity
          config.com.parity = '0';
          let parity = cell.getBinding('com.parity');
          if (parity != null && parity.value != null) config.com.parity = JSON.parse(parity.value).trim();
          // stop_bits
          config.com.stop_bits = '1';
          let stop_bits = cell.getBinding('com.stop_bits');
          if (stop_bits != null && stop_bits.value != null) config.com.stop_bits = JSON.parse(stop_bits.value).trim();
          // period
          config.com.period = '0';
          let period = cell.getBinding('com.period');
          if (period != null && period.value != null) config.com.period = JSON.parse(period.value).trim();
          // echo
          config.com.echo = false;
          let echo = cell.getBinding('com.echo');
          if (echo != null && echo.value != null) config.com.echo = JSON.parse(echo.value) == '1';
        }
        break;
      case 'eth':
        {
          config.eth = {};
          // ip
          config.eth.ip = '1.1.1.1';
          let ip = cell.getBinding('eth.ip');
          if (ip != null && ip.value != null) config.eth.ip = JSON.parse(ip.value).trim();
          // port
          config.eth.port = '503';
          let port = cell.getBinding('eth.port');
          if (port != null && port.value != null) config.eth.port = JSON.parse(port.value).trim();
        }
        break;
      default:
        return;
    }
  
    // pmk
    config.pmk = '';
    let pmk = cell.getBinding('path.pmk');
    if (pmk != null && pmk.value != null) config.pmk = JSON.parse(pmk.value).text.trim();
    // bfpo
    config.bfpo = '';
    let bfpo = cell.getBinding('path.bfpo');
    if (bfpo != null && bfpo.value != null) config.bfpo = JSON.parse(bfpo.value).text.trim();
  
    // connect
    config.connect = false;
    let connect = cell.getBinding('options.connect');
    if (connect != null && connect.value != null) config.connect = JSON.parse(connect.value) == '1';
    // read_pmk
    config.readpmk = false;
    let read_pmk = cell.getBinding('options.read_pmk');
    if (read_pmk != null && read_pmk.value != null) config.readpmk = JSON.parse(read_pmk.value) == '1';
  
    return config;
  };
  BMRZScriptAPI.prototype.execAction = function (cell) {
    if (cell == null) return;
  
    cell.config = cell.config || this.buildConfig(cell);
    if (cell.config == null) {
      console.log('Ошибка параметризации')
      //messageError('Ошибка параметризации');
      return;
    }
  
    // exec command
    AJAX.post(
      '/linkmt/cfgmt/exec',
      null,
      cell.config,
      function (xhr, resp) {
        console.log('common.messages.command_sent_to_server')
        //messageDebug(translate('common.messages.command_sent_to_server'));
      },
      function (xhr, err) {
        console.log('common.errors.command_execution')
        //messageError(translate('common.errors.command_execution'));
      }
    );
  };
  
  function PosterScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(PosterScriptAPI, ShapeAPI);
  PosterScriptAPI.prototype.setup = function (cell) {
   
    shapeSetup.apply(this, arguments);
  
    var bindingsHandler = new BindingsHandler(this.ui);
    // init bindings
  
    if (typeof BindingsHandler == 'function') {
      bindingsHandler.graph.view.validatePosterState(cell);
    }
    //unstick cells
    mxGraph.prototype.isValidDropTarget = function (target, cells, evt) {
      return target._type == 'phase' && cells.every((c) => c._type != 'phase');
    };
  
    cell.getTooltip = function () {
      return this._model ? `[${API.FORMAT.getDateString(this._model.ts)}]: ${this._model.modifiedBy}.\n${this._model.data.title}` : null;
    };
  };
  PosterScriptAPI.prototype.state = function (cell, binding, value) {
    cell._model = value;
    this.graph.cellRenderer.redrawShape(this.graph.view.getState(cell), true);
  };
  
  function DispatcherMarkScriptAPI(editorUI) {
    ShapeAPI.call(this, editorUI);
  }
  mxUtils.extend(DispatcherMarkScriptAPI, ShapeAPI);
  DispatcherMarkScriptAPI.prototype.setup = function (cell) {
    shapeSetup.apply(this, arguments);
  
    cell.getTooltip = function () {
      return this._model ? `[${API.FORMAT.getDateString(this._model.ts)}]: ${this._model.modifiedBy}.\n${this._model.data.title}` : null;
    };
  };
  DispatcherMarkScriptAPI.prototype.state = function (cell, binding, value) {
    cell._model = value;
    this.graph.cellRenderer.redrawShape(this.graph.view.getState(cell), true);
  };
  

  //MArkservice.js

  // import * as mxgraph from 'mxgraph';
// import { API } from './scada'
// import { HELP, AJAX } from './client'
// import * as webix from 'webix/webix.js';
// import 'webix/webix.css';
// import { SidebarWindow } from './Dialogs'
// const {
//   $$
//   } = webix


// let { 
//     mxRectangle,
//     mxEvent,
//     mxCell,
//     mxGeometry,
// } = mxgraph();


//export default function MarksService(editorUI) {

 function MarksService(editorUI) {
    this.ui = editorUI;
    this.editor = editorUI.editor;
    this.graph = editorUI.editor.graph;
  
    this.editedCells = new Map();
    this.insertedCells = new Map();
    this.deletedCells = new Map();
  
    this.modeEnabled = false;
  
    this.setupGraph();
    this.setupListeners();
  };
  
  MarksService.prototype.TYPES = {
    POSTER: 0,
    MARK: 1,
  };
  MarksService.prototype.TYPE_FROM_NAME = {
    ['poster']: 0,
    ['dispatcher_mark']: 1,
  };
  MarksService.prototype.NAME_FROM_TYPE = {
    0: 'poster',
    1: 'dispatcher_mark',
  };
  MarksService.prototype.DEFAULT_MODELS = {
    0: function () {
      return {
        createdAt: '',
        createdBy: '',
        data: {
          message: '',
          title: '',
          type: '',
          width: 200,
          height: 100,
          x: 20,
          y: 20,
        },
        id: '',
        modifiedBy: '',
        schemeId: '',
        ts: '',
      };
    },
    1: function () {
      return {
        createdAt: '',
        createdBy: '',
        data: {
          message: '',
          title: '',
          type: 'info',
          width: 100,
          height: 100,
          x: 20,
          y: 20,
        },
        id: '',
        modifiedBy: '',
        schemeId: '',
        ts: '',
      };
    },
  };
  
  MarksService.prototype.getCellType = function (cell) {
    const type = this.TYPE_FROM_NAME[cell.value.tagName];
    return type > -1 ? type : -1;
  };
  
  MarksService.prototype.getCellStyle = function (type) {
    return this.NAME_FROM_TYPE[type];
  };
  
  MarksService.prototype.getCellDefaultModel = function (cell) {
    const type = this.getCellType(cell);
    const model = this.DEFAULT_MODELS[type]();
    model.id = '_' + cell.id;
    return model;
  };
  
  MarksService.prototype.setupGraph = function () {
    this.graph.isEnabled = () => this.isEnabled();
  
    this.graph.panningHandler.usePopupTrigger = false;
  
    /* disable connection */
    this.graph.connectionHandler.mouseMove = function () {
      return;
    };
  
    /* disable rotation */
    this.graph.isCellRotatable = function (cell) {
      return false;
    };
  
    /* disable inserting text action on double click */
    this.graph.dblClick = function () {
      return;
    };
  
    /* disable connection arrows */
    this.graph.connectionArrowsEnabled = false;
  
    /* bind the delete key */
    this.ui.keyHandler.bindAction(46, false, 'delete'); // Delete
  
    /* create new layer ontop for posters and marks */
    this.marksLayer = this.graph.model.getRoot().insert(new mxCell('Плакаты / пометки'));
    this.graph.setDefaultParent(this.marksLayer);
  };
  
  MarksService.prototype.setupListeners = function () {
    this.graph.addListener('cellsInserted', (sender, evt) => {
      const cells = evt.getProperty('cells');
      if (Array.isArray(cells)) {
        this.onCellInserted(cells[0]);
      }
    });
  
    this.graph.addListener(mxEvent.CELLS_MOVED, (sender, evt) => {
      const cells = evt.getProperty('cells');
      if (Array.isArray(cells)) {
        this.onCellsChanged(cells.filter((cell) => cell.value !== ''));
      }
    });
  
    this.graph.addListener(mxEvent.CELLS_RESIZED, (sender, evt) => {
      const cells = evt.getProperty('cells');
      if (Array.isArray(cells)) {
        this.onCellsChanged(cells.filter((cell) => cell.value !== ''));
      }
    });
  
    this.graph.addListener(mxEvent.CELLS_REMOVED, (sender, evt) => {
      const cells = evt.getProperty('cells');
      if (Array.isArray(cells)) {
        this.onCellsDeleted(cells);
      }
    });
  };
  
  MarksService.prototype.isEnabled = function () {
    // @if !LINKMT
    return this.modeEnabled;
    // @endif
    // @if LINKMT
    return false;
    // @endif
  };
  
  MarksService.prototype.resetAndUpdate = function () {
    /* refresh page to clear changes */
    HELP.pageRedirect(HELP.buildUrl('scheme/view', 'id=' + HELP.queryStringParam('id')));
  };
  
  MarksService.prototype.onConflict = function () {
    webix
      .modalbox({
        title: 'Возможный конфликт',
        buttons: ['Ок'],
        width: 500,
        text: 'Плакаты и пометки на данной схеме были изменены другим пользователем.\nЧтобы избежать конфликтов, текущие изменения будут отменены.',
      })
      .then(() => {
        this.resetAndUpdate();
      });
  };
  
  MarksService.prototype.createSnackBar = function () {
    this.snackBar = webix.ui({
      view: 'toolbar',
      id: 'dispatcher-mode-snackbar',
      css: 'poster-snackbar',
      height: 40,
      paddingX: 8,
      width: 400,
      cols: [
        {
          view: 'label',
          label: 'Режим установки плакатов, пометок',
        },
        {
          view: 'button',
          value: 'common.exit',
          align: 'center',
          css: 'webix_danger',
          width: 100,
          click: () => {
            this.onModeButtonClick();
          },
        },
      ],
    });
  };
  
  MarksService.prototype.showSnackbar = function (isVisible) {
    if (!this.snackBar) {
      return;
    }
    const snackNode = this.snackBar.getNode();
    snackNode.style.top = $$('toolbar').$height + 4 + 'px';
    if (isVisible) {
      this.snackBar.show();
    } else {
      this.snackBar.hide();
    }
  };
  
  MarksService.prototype.setSnackbarTitle = function () {
    if (!this.snackBar) {
      return;
    }
    const isEdited = this.insertedCells.size + this.editedCells.size + this.deletedCells.size > 0;
    const label = this.snackBar.getChildViews()[0];
    const currentString = label.getValue().length > 0 ? label.getValue() : label.config.label;
    const originString = currentString.charAt(currentString.length - 1) === '*' ? currentString.slice(0, -1) : currentString;
    if (isEdited) {
      label.setValue(originString + ' *');
    } else {
      label.setValue(originString);
    }
  };
  
  MarksService.prototype.onCellInserted = function (cell) {
    /* return if cell inserted from hub */
    if (cell._fromHub) {
      delete cell._fromHub;
      return;
    }
    /* add model for new cell */
    cell._model = this.getCellDefaultModel(cell);
    this.ui.viewHandler.scripts.setup(cell);
    cell._tempInsert = true;
    /* add cell to temp list */
    this.insertedCells.set(cell._model.id, cell);
    /* open properties window */
    const type = this.getCellType(cell);
    if (type === this.TYPES.POSTER) {
      API.POSTERS.openPosterEditor(this.graph, cell, true);
    } else if (type === this.TYPES.MARK) {
      API.DISPATCHER_MARKS.openMarkEditor(this.graph, cell, true);
    }
    /* update snack bar title */
    this.setSnackbarTitle();
  };
  
  MarksService.prototype.onCellsChanged = function (cells) {
    cells.forEach((cell) => {
      /* return if cell updated from hub */
      if (cell._fromHub) {
        delete cell._fromHub;
        return;
      }
      /* update geometry in poster model */
      const geometry = cell.getGeometry();
      cell._model.data.x = geometry.x;
      cell._model.data.y = geometry.y;
      cell._model.data.width = geometry.width;
      cell._model.data.height = geometry.height;
      /* manage temp lists */
      if (this.insertedCells.has(cell._model.id)) {
        this.insertedCells.set(cell._model.id, cell);
      } else {
        this.editedCells.set(cell._model.id, cell);
      }
      /* update children cell geometry */
      if (cell.children) {
        const childCell = cell.children[0];
        const childGeometry = new mxGeometry(0, 0, geometry.width, geometry.height);
        this.graph.getModel().setGeometry(childCell, childGeometry);
      }
    });
  
    /* update snack bar title */
    this.setSnackbarTitle();
  };
  
  MarksService.prototype.onCellsDeleted = function (cells) {
    cells.forEach((cell) => {
      /* manage temp lists */
      this.insertedCells.delete(cell._model.id);
      this.editedCells.delete(cell._model.id);
      /* check if cell was not temporary for inserting process or deleted from hub */
      if (!cell._tempInsert && !cell._fromHub) {
        this.deletedCells.set(cell._model.id, cell);
        this.ui.viewHandler.cellMap.delete(cell._model.id);
      } else {
        delete cell._tempInsert;
        delete cell._fromHub;
      }
    });
    /* update snack bar title */
    this.setSnackbarTitle();
  };
  
  MarksService.prototype.updatePosterLayer = function () {
    /* lock or unlock other layers */
    const layerCount = this.graph.model.getChildCount(this.graph.model.root);
    for (let i = 0; i < layerCount; i++) {
      /* get the layer */
      const layer = this.graph.model.getChildAt(this.graph.model.root, i);
      /* check if this layer is not the marks layer */
      if (layer.mxObjectId === this.marksLayer.mxObjectId) continue;
      /* set locked style */
      this.graph.model.beginUpdate();
      try {
        this.graph.setCellStyles('locked', null, [layer]);
        this.graph.setCellStyles('locked', '1', [layer]);
      } finally {
        this.graph.model.endUpdate();
      }
    }
  };
  
  MarksService.prototype.toggleMode = function () {
    if (!this.modeEnabled) {
      this.insertedCells.clear();
      this.editedCells.clear();
      this.deletedCells.clear();
    }
    /* CREATE */
    if (this.modeEnabled && this.insertedCells.size > 0) {
      const postersData = [];
      const dispatcherMarksData = [];
      const tempCells = []; // need this because insertedCells is a map
  
      /* fill data arrays */
      this.insertedCells.forEach((cell) => {
        const type = this.getCellType(cell);
        if (type === this.TYPES.POSTER) {
          postersData.push(cell._model.data);
        } else if (type === this.TYPES.MARK) {
          dispatcherMarksData.push(cell._model.data);
        }
        tempCells.push(cell);
      });
  
      /* POST to server */
      if (postersData.length > 0) {
        AJAX.post(
          'api/scheme/posters',
          //--->fix---//
           null,
           //'schemeId=' + viewer.scheme.id,
          //--->fix---//
          postersData,
          (xhr, res) => {},
          // (xhr, err) => messageError('Ошибка сохранения.')
          (xhr, err) => console.log('Ошибка сохранения.')
         
        );
      }
      if (dispatcherMarksData.length > 0) {
        AJAX.post(
          'api/scheme/marks',
         //--->fix---//
         null,
         //'schemeId=' + viewer.scheme.id,
        //--->fix---//
          dispatcherMarksData,
          (xhr, res) => {},
          // (xhr, err) => messageError('Ошибка сохранения.')
          (xhr, err) => console.log('Ошибка сохранения.')
        );
      }
  
      /* new cells will be inserted from hub event, so we need to remove temp cells */
      try {
        this.graph.model.beginUpdate();
        this.graph.removeCells(tempCells);
      } finally {
        this.graph.model.endUpdate();
        this.insertedCells.clear();
      }
    }
  
    /* UPDATE */
    if (this.modeEnabled && this.editedCells.size > 0) {
      const posters = [];
      const dispatcherMarks = [];
  
      this.editedCells.forEach((cell) => {
        const type = this.getCellType(cell);
        if (type === this.TYPES.POSTER) {
          posters.push(cell._model);
        } else if (type === this.TYPES.MARK) {
          dispatcherMarks.push(cell._model);
        }
      });
  
      /* PATCH to server */
      if (posters.length > 0) {
        AJAX.patch(
          'api/scheme/posters',
          //--->fix---//
          null,
          //'schemeId=' + viewer.scheme.id,
         //--->fix---//
          posters,
          (xhr, res) => {},
          // (xhr, err) => messageError('Ошибка сохранения.')
          (xhr, err) => console.log('Ошибка сохранения.')
        );
      }
      if (dispatcherMarks.length > 0) {
        AJAX.patch(
          'api/scheme/marks',
          //--->fix---//
          null,
          //'schemeId=' + viewer.scheme.id,
         //--->fix---//
          dispatcherMarks,
          (xhr, res) => {},
          //(xhr, err) => messageError('Ошибка сохранения.')
          (xhr, err) => console.log('Ошибка сохранения.')
        );
      }
  
      /* cells will be updated from hub event */
      this.editedCells.clear();
    }
  
    /* DELETE */
    if (this.modeEnabled && this.deletedCells.size > 0) {
      const postersIds = [];
      const dispatcherMarksIds = [];
  
      this.deletedCells.forEach((cell) => {
        const type = this.getCellType(cell);
        if (type === this.TYPES.POSTER) {
          postersIds.push(cell._model.id);
        } else if (type === this.TYPES.MARK) {
          dispatcherMarksIds.push(cell._model.id);
        }
      });
  
      /* DELETE to sever */
      if (postersIds.length > 0) {
        AJAX.delete(
          'api/scheme/posters',
         //--->fix---//
         null,
         //'schemeId=' + viewer.scheme.id,
        //--->fix---//
          postersIds,
          (xhr, res) => {
            if (res.posters.length > 0) {
              res.posters.forEach((poster) => {
                this.ui.viewHandler.cellMap.delete(poster.id);
              });
            }
          },
          //(xhr, err) => messageError('Ошибка сохранения.')
          (xhr, err) => console.log('Ошибка сохранения.')
        );
      }
      if (dispatcherMarksIds.length > 0) {
        AJAX.delete(
          'api/scheme/marks',
         //--->fix---//
         null,
         //'schemeId=' + viewer.scheme.id,
        //--->fix---//
          dispatcherMarksIds,
          (xhr, res) => {
            if (res.dispatcherMarks.length > 0) {
              res.dispatcherMarks.forEach((mark) => {
                this.ui.viewHandler.cellMap.delete(mark.id);
              });
            }
          },
          //(xhr, err) => messageError('Ошибка сохранения.')
          (xhr, err) => console.log('Ошибка сохранения.')
        );
      }
  
      /* cells will be deleted from hub event */
      this.deletedCells.clear();
    }
  
    /* change mode */
    this.modeEnabled = !this.modeEnabled;
  
    /* show sidebar panel */
    if (!this.sidebarWindow) {
      this.sidebarWindow = new SidebarWindow(this.ui, 256, 256, 170, 101);
      this.sidebarWindow.window.setClosable(false);
      this.sidebarWindow.window.setResizable(false);
    } else {
      this.sidebarWindow.window.setVisible(this.modeEnabled);
    }
  
    /* reset selection */
    this.graph.selectionModel.removeCells(this.graph.selectionModel.cells);
  
    /* lock or unlock other layers */
    const layerCount = this.graph.model.getChildCount(this.graph.model.root);
    for (let i = 0; i < layerCount; i++) {
      /* get the layer */
      const layer = this.graph.model.getChildAt(this.graph.model.root, i);
      /* check if this layer is not the marks layer */
      if (layer.mxObjectId === this.marksLayer.mxObjectId) continue;
      /* set locked style */
      this.graph.model.beginUpdate();
      try {
        this.graph.setCellStyles('locked', this.modeEnabled ? '1' : null, [layer]);
      } finally {
        this.graph.model.endUpdate();
      }
    }
  
    /* show snackbar */
    if (!this.snackBar) {
      this.createSnackBar();
    }
    this.showSnackbar(this.modeEnabled);
  };
  
  MarksService.prototype.onModeButtonClick = function () {
    const title = 'Редактирование плакатов и пометок';
    const entryMessage = this.modeEnabled ? 'Выйти из режима редактирования?' : 'Войти в режим редактирования?';
    webix
      .modalbox({
        type: 'alert-warning',
        title,
        buttons: ['common.yes', 'common.no'],
        width: 'auto',
        text: entryMessage,
      })
      .then((result) => {
        if (result !== '0') {
          return;
        } else if (!this.modeEnabled) {
          this.toggleMode();
        } else {
          webix
            .modalbox({
              type: 'alert-warning',
              title,
              buttons: ['common.yes','common.no'],
              width: 'auto',
              text: 'Сохранить внесенные изменения?',
            })
            .then((result) => {
              if (result === '0') {
                this.toggleMode();
              } else {
                this.resetAndUpdate();
              }
            });
        }
      });
  };
  
  MarksService.prototype.addCells = function (items, type) {
    if (!Array.isArray(items)) return;
  
    if (this.modeEnabled) {
      this.onConflict();
      return;
    }
  
    this.graph.stopEditing();
  
    this.graph.model.beginUpdate();
    try {
      items.forEach((item) => {
        const cell = this.graph.insertVertex(this.marksLayer, null, null, Math.round(item.data.x), Math.round(item.data.y), Math.round(item.data.width), Math.round(item.data.height), this.getCellStyle(type));
  
        cell._model = item;
  
        if (!cell) return;
  
        // find scriptor
        this.ui.viewHandler.scripts.setup(cell);
        if (cell.scriptor == null) return;
  
        // save original cell params for dynamic changes
        if (cell.origin == null) {
          cell.origin = {};
          cell.origin.style = this.graph.getCellStyle(cell);
          cell.origin.state = this.graph.view.getState(cell, true).clone();
          const geometry = this.graph.getCellGeometry(cell);
          cell.origin.geometry = geometry != null ? geometry.clone() : null;
        }
  
        // cell binding map
        if (cell.bindingMap == null) cell.bindingMap = {};
  
        const map = { tag: [], eq: [] };
        cell.scriptor.visit(cell, map);
  
        // process binding
        if (this.ui.viewHandler.names.indexOf(item.id) < 0) this.ui.viewHandler.names.push(item.id);
  
        this.ui.viewHandler.updateCellMapping(cell, item.id);
        this.ui.viewHandler.updateBindMapping(cell, item.id);
  
        this.graph.view.invalidate(cell, true);
      });
    } finally {
      this.graph.model.endUpdate();
    }
  };
  
  MarksService.prototype.updateCells = function (item, type) {
    if (this.modeEnabled) {
      this.onConflict();
      return;
    }
  
    const targetCells = this.ui.viewHandler.findMappedCells(item.id);
    targetCells.forEach((targetCell) => {
      targetCell._fromHub = true; // custom source property for update cell event handler
      const bounds = new mxRectangle(item.data.x, item.data.y, item.data.width, item.data.height);
      this.graph.resizeCells([targetCell], [bounds]);
      targetCell.scriptor.state(targetCell, null, item);
    });
    /* add new item if cell was deleted in editing mode */
    if (targetCells.length === 0 && this.deletedCells.has(item.id)) {
      this.addCells([item], type);
      this.deletedCells.delete(item.id);
    }
  };
  
  MarksService.prototype.removeCells = function (item) {
    if (this.modeEnabled) {
      this.onConflict();
      return;
    }
  
    const targetCells = this.ui.viewHandler.findMappedCells(item.id);
    targetCells.forEach((cell) => (cell._fromHub = true)); // custom source property for CELLS_REMOVED event handler
    this.graph.removeCells(targetCells);
    this.ui.viewHandler.cellMap.delete(item.id);
  };
  
  MarksService.prototype.addPosters = function (posters) {
    this.addCells(posters, this.TYPES.POSTER);
  };
  
  MarksService.prototype.updatePoster = function (poster) {
    this.updateCells(poster, this.TYPES.POSTER);
  };
  
  MarksService.prototype.removePoster = function (poster) {
    this.removeCells(poster);
  };
  
  MarksService.prototype.addDispatcherMarks = function (marks) {
    this.addCells(marks, this.TYPES.MARK);
  };
  
  MarksService.prototype.updateDispatcherMark = function (mark) {
    this.updateCells(mark, this.TYPES.MARK);
  };
  
  MarksService.prototype.removeDispatcherMark = function (mark) {
    this.removeCells(mark);
  };
  
    MarksService.prototype.fetchPosters = function () {
      //---->fix<--------//
      AJAX.get(
        null,
        null,
        (xhr, res) => {
        //render posters 
        res = {
          "posters": [
            {
              "id": "277972a7-96c2-4c1d-9af7-b7dbbbc7573f",
              "data": {
                "title": "2",
                "message": "2",
                "type": "grounded",
                "x": 590.5,
                "y": 596.0,
                "width": 194.0,
                "height": 98.0
              },
              "schemeId": "2251b1c0-f0a3-4979-99c3-caa251ff3cd2",
              "modifiedBy": "система",
              "createdBy": "система",
              "ts": "2023-07-21T13:32:10.3376830Z",
              "createdAt": "2023-07-21T13:32:10.3376830Z",
              "isRemoved": false
            },
            {
              "id": "7404ab0f-b86e-4147-b074-235d025337b5",
              "data": {
                "title": "1",
                "message": "",
                "type": "workOnLine",
                "x": 313.0,
                "y": 469.0,
                "width": 141.0,
                "height": 71.0
              },
              "schemeId": "2251b1c0-f0a3-4979-99c3-caa251ff3cd2",
              "modifiedBy": "система",
              "createdBy": "система",
              "ts": "2023-07-21T13:32:10.4776802Z",
              "createdAt": "2023-07-20T11:11:50.6344934Z",
              "isRemoved": false
            },
            {
              "id": "818cc327-bb3a-4724-a6a5-77ca72e07ce4",
              "data": {
                "title": "3",
                "message": "3",
                "type": "workUnderVoltage-transit",
                "x": 559.5,
                "y": 320.5,
                "width": 171.0,
                "height": 86.0
              },
              "schemeId": "2251b1c0-f0a3-4979-99c3-caa251ff3cd2",
              "modifiedBy": "система",
              "createdBy": "система",
              "ts": "2023-07-21T13:32:10.5847440Z",
              "createdAt": "2023-07-21T13:32:10.5847440Z",
              "isRemoved": false
            }
          ]
        }
          if (Array.isArray(res.posters)) {
            this.addPosters(res.posters);
          } else {
            console.log('Ошибка получения плакатов')
            // messageError('Ошибка получения плакатов');
          }
          /* if we have poster id in query */
          const posterId = HELP.queryStringParam('poster');
          const cells = posterId ? this.ui.viewHandler.cellMap.get(posterId) : null;
          if (Array.isArray(cells) && cells.length > 0) {
            this.graph.addSelectionCells(cells);
            API.POSTERS.openPosterViewer(cells[0]._model, this.graph, cells[0]);
          }
        },
        // (xhr, err) => messageError('Ошибка получения плакатов')
        (xhr, err) => console.log('Ошибка получения плакатов')
      );
       //---->fix<--------//
    };
  
  
  MarksService.prototype.fetchMarks = function () {
     //---->fix<--------//
    AJAX.get(
      null,
      null,
      (xhr, res) => {
        /* render marks */
          res = {
          dispatcherMarks:[
            {
              "id": "decbc6fd-0bd1-4ea2-8219-79b0728bf60c",
              "data": {
                  "title": "1",
                  "message": "1",
                  "number": "",
                  "type": "portableGrounding",
                  "x": 891,
                  "y": 583,
                  "width": 124,
                  "height": 124
              },
              "schemeId": "2251b1c0-f0a3-4979-99c3-caa251ff3cd2",
              "modifiedBy": "система",
              "createdBy": "система",
              "ts": "2023-07-21T13:32:10.3532889Z",
              "createdAt": "2023-07-21T13:32:10.3532889Z",
              "isRemoved": false
          },
          {
            "id": "3bcb8734-11d0-47d0-bd71-3b4ae0ef5fc9",
            "data": {
                "title": "1",
                "message": "",
                "number": "",
                "type": "info",
                "x": 822.5,
                "y": 344.5,
                "width": 200,
                "height": 200
            },
            "schemeId": "2251b1c0-f0a3-4979-99c3-caa251ff3cd2",
            "modifiedBy": "система",
            "createdBy": "система",
            "ts": "2023-07-21T13:32:10.5261483Z",
            "createdAt": "2023-07-20T11:11:50.6494786Z",
            "isRemoved": false
        },
        {
          "id": "7a1d9e14-29ba-4ba8-a529-ea4683526f53",
          "data": {
              "title": "2",
              "message": "2",
              "number": "",
              "type": "relayProtection",
              "x": 1035,
              "y": 263.5,
              "width": 125,
              "height": 125
          },
          "schemeId": "2251b1c0-f0a3-4979-99c3-caa251ff3cd2",
          "modifiedBy": "система",
          "createdBy": "система",
          "ts": "2023-07-21T13:32:10.5867107Z",
          "createdAt": "2023-07-21T13:32:10.5867107Z",
          "isRemoved": false
      }
          ]
        }
        if (Array.isArray(res.dispatcherMarks)) {
          this.addDispatcherMarks(res.dispatcherMarks);
        } else {
          console.log('Ошибка получения пометок')
          // messageError('Ошибка получения пометок');
        }
        /* if we have mark id in query */
        const markId = HELP.queryStringParam('mark');
        const cells = markId ? this.ui.viewHandler.cellMap.get(markId) : null;
        if (Array.isArray(cells) && cells.length > 0) {
          this.graph.addSelectionCells(cells);
          API.DISPATCHER_MARKS.openMarkViewer(cells[0]._model, this.graph, cells[0]);
        }
      },
      // (xhr, err) => messageError('Ошибка получения пометок')
      (xhr, err) => console.log('Ошибка получения пометок')
    );
     //---->fix<--------//
  };
  
export{
    Graph,
    EditorUi,
    Editor,
    BindingsHandler
}

  

